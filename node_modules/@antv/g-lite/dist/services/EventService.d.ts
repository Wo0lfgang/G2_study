import type { FederatedEvent } from '../dom/FederatedEvent';
import { FederatedPointerEvent } from '../dom/FederatedPointerEvent';
import { FederatedWheelEvent } from '../dom/FederatedWheelEvent';
import type { IEventTarget } from '../dom/interfaces';
import type { PointLike } from '../shapes';
import type { Cursor, EventPosition } from '../types';
import type { CanvasContext, GlobalRuntime } from '..';
type Picker = (position: EventPosition) => Promise<IEventTarget | null>;
export type EmitterListeners = Record<string, {
    fn: (...args: any[]) => any;
    context: any;
    once: boolean;
}[] | {
    fn: (...args: any[]) => any;
    context: any;
    once: boolean;
}>;
export declare class EventService {
    private globalRuntime;
    private context;
    constructor(globalRuntime: GlobalRuntime, context: CanvasContext);
    private rootTarget;
    private emitter;
    cursor: Cursor | null;
    private mappingTable;
    private mappingState;
    private eventPool;
    private pickHandler;
    private tmpMatrix;
    private tmpVec3;
    init(): void;
    destroy(): void;
    client2Viewport(client: PointLike): PointLike;
    viewport2Client(canvas: PointLike): PointLike;
    viewport2Canvas({ x, y }: PointLike): PointLike;
    canvas2Viewport(canvasP: PointLike): PointLike;
    setPickHandler(pickHandler: Picker): void;
    addEventMapping(type: string, fn: (e: FederatedEvent) => Promise<void>): void;
    mapEvent(e: FederatedEvent): void;
    onPointerDown: (from: FederatedPointerEvent) => Promise<void>;
    onPointerUp: (from: FederatedPointerEvent) => Promise<void>;
    onPointerMove: (from: FederatedPointerEvent) => Promise<void>;
    onPointerOut: (from: FederatedPointerEvent) => Promise<void>;
    onPointerOver: (from: FederatedPointerEvent) => Promise<void>;
    onPointerUpOutside: (from: FederatedPointerEvent) => Promise<void>;
    onWheel: (from: FederatedWheelEvent) => Promise<void>;
    dispatchEvent(e: FederatedEvent, type?: string, skipPropagate?: boolean): void;
    propagate(e: FederatedEvent, type?: string): void;
    propagationPath(target: IEventTarget): IEventTarget[];
    hitTest(position: EventPosition): Promise<IEventTarget | null>;
    /**
     * whether the native event trigger came from Canvas,
     * should account for HTML shape
     */
    private isNativeEventFromCanvas;
    private getExistedHTML;
    private pickTarget;
    private createPointerEvent;
    private createWheelEvent;
    private trackingData;
    cloneWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent;
    clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent;
    private copyPointerData;
    private copyMouseData;
    private copyWheelData;
    private copyData;
    private allocateEvent;
    private freeEvent;
    private notifyTarget;
    private notifyListeners;
    /**
     * some detached nodes may exist in propagation path, need to skip them
     */
    private findMountedTarget;
    private getCursor;
}
export {};
//# sourceMappingURL=EventService.d.ts.map