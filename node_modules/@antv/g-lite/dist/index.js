'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var RBush = require('rbush/rbush.js');
var util = require('@antv/util');
var d3 = require('d3-color');
var glMatrix = require('gl-matrix');
var gMath = require('@antv/g-math');
var EventEmitter = require('eventemitter3');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var RBush__default = /*#__PURE__*/_interopDefaultLegacy(RBush);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type
 */
(function (PropertySyntax) {
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#coordinate
   */
  PropertySyntax["COORDINATE"] = "<coordinate>";
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#color
   */
  PropertySyntax["COLOR"] = "<color>";
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#paint
   */
  PropertySyntax["PAINT"] = "<paint>";
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#number
   */
  PropertySyntax["NUMBER"] = "<number>";
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle
   */
  PropertySyntax["ANGLE"] = "<angle>";
  /**
   * <number> with range 0..1
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#opacity_value
   */
  PropertySyntax["OPACITY_VALUE"] = "<opacity-value>";
  /**
   * <number> with range 0..Infinity
   */
  PropertySyntax["SHADOW_BLUR"] = "<shadow-blur>";
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#length
   */
  PropertySyntax["LENGTH"] = "<length>";
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#percentage
   */
  PropertySyntax["PERCENTAGE"] = "<percentage>";
  PropertySyntax["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
  PropertySyntax["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/margin#formal_syntax
   */
  PropertySyntax["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#list-of-ts
   */
  PropertySyntax["LIST_OF_POINTS"] = "<list-of-points>";
  PropertySyntax["PATH"] = "<path>";
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/filter#formal_syntax
   */
  PropertySyntax["FILTER"] = "<filter>";
  PropertySyntax["Z_INDEX"] = "<z-index>";
  PropertySyntax["OFFSET_DISTANCE"] = "<offset-distance>";
  PropertySyntax["DEFINED_PATH"] = "<defined-path>";
  PropertySyntax["MARKER"] = "<marker>";
  PropertySyntax["TRANSFORM"] = "<transform>";
  PropertySyntax["TRANSFORM_ORIGIN"] = "<transform-origin>";
  PropertySyntax["TEXT"] = "<text>";
  PropertySyntax["TEXT_TRANSFORM"] = "<text-transform>";
})(exports.PropertySyntax || (exports.PropertySyntax = {}));

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

// These units are iterated through, so be careful when adding or changing the
(function (UnitType) {
  UnitType[UnitType["kUnknown"] = 0] = "kUnknown";
  UnitType[UnitType["kNumber"] = 1] = "kNumber";
  UnitType[UnitType["kPercentage"] = 2] = "kPercentage";
  // Length units
  UnitType[UnitType["kEms"] = 3] = "kEms";
  // kExs,
  UnitType[UnitType["kPixels"] = 4] = "kPixels";
  // kCentimeters,
  // kMillimeters,
  // kInches,
  // kPoints,
  // kPicas,
  // kQuarterMillimeters,
  // https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
  //
  // See also IsViewportPercentageLength.
  // kViewportWidth,
  // kViewportHeight,
  // kViewportInlineSize,
  // kViewportBlockSize,
  // kViewportMin,
  // kViewportMax,
  // kSmallViewportWidth,
  // kSmallViewportHeight,
  // kSmallViewportInlineSize,
  // kSmallViewportBlockSize,
  // kSmallViewportMin,
  // kSmallViewportMax,
  // kLargeViewportWidth,
  // kLargeViewportHeight,
  // kLargeViewportInlineSize,
  // kLargeViewportBlockSize,
  // kLargeViewportMin,
  // kLargeViewportMax,
  // kDynamicViewportWidth,
  // kDynamicViewportHeight,
  // kDynamicViewportInlineSize,
  // kDynamicViewportBlockSize,
  // kDynamicViewportMin,
  // kDynamicViewportMax,
  // https://drafts.csswg.org/css-contain-3/#container-lengths
  //
  // See also IsContainerPercentageLength.
  // kContainerWidth,
  // kContainerHeight,
  // kContainerInlineSize,
  // kContainerBlockSize,
  // kContainerMin,
  // kContainerMax,
  UnitType[UnitType["kRems"] = 5] = "kRems";
  // kChs,
  // kUserUnits, // The SVG term for unitless lengths
  // Angle units
  UnitType[UnitType["kDegrees"] = 6] = "kDegrees";
  UnitType[UnitType["kRadians"] = 7] = "kRadians";
  UnitType[UnitType["kGradians"] = 8] = "kGradians";
  UnitType[UnitType["kTurns"] = 9] = "kTurns";
  // Time units
  UnitType[UnitType["kMilliseconds"] = 10] = "kMilliseconds";
  UnitType[UnitType["kSeconds"] = 11] = "kSeconds";
  // kHertz,
  // kKilohertz,
  // Resolution
  // kDotsPerPixel,
  // kDotsPerInch,
  // kDotsPerCentimeter,
  // Other units
  // kFraction,
  UnitType[UnitType["kInteger"] = 12] = "kInteger";
  // This value is used to handle quirky margins in reflow roots (body, td,
  // and th) like WinIE. The basic idea is that a stylesheet can use the value
  // __qem (for quirky em) instead of em. When the quirky value is used, if
  // you're in quirks mode, the margin will collapse away inside a table cell.
  // This quirk is specified in the HTML spec but our impl is different.
  // TODO: Remove this. crbug.com/443952
  // kQuirkyEms,
})(exports.UnitType || (exports.UnitType = {}));
var UnitCategory;
(function (UnitCategory) {
  UnitCategory[UnitCategory["kUNumber"] = 0] = "kUNumber";
  UnitCategory[UnitCategory["kUPercent"] = 1] = "kUPercent";
  UnitCategory[UnitCategory["kULength"] = 2] = "kULength";
  UnitCategory[UnitCategory["kUAngle"] = 3] = "kUAngle";
  UnitCategory[UnitCategory["kUTime"] = 4] = "kUTime";
  // kUFrequency,
  // kUResolution,
  UnitCategory[UnitCategory["kUOther"] = 5] = "kUOther";
})(UnitCategory || (UnitCategory = {}));
var ValueRange;
(function (ValueRange) {
  ValueRange[ValueRange["kAll"] = 0] = "kAll";
  ValueRange[ValueRange["kNonNegative"] = 1] = "kNonNegative";
  ValueRange[ValueRange["kInteger"] = 2] = "kInteger";
  ValueRange[ValueRange["kNonNegativeInteger"] = 3] = "kNonNegativeInteger";
  ValueRange[ValueRange["kPositiveInteger"] = 4] = "kPositiveInteger";
})(ValueRange || (ValueRange = {}));
var Nested;
(function (Nested) {
  Nested[Nested["kYes"] = 0] = "kYes";
  Nested[Nested["kNo"] = 1] = "kNo";
})(Nested || (Nested = {}));
var ParenLess;
(function (ParenLess) {
  ParenLess[ParenLess["kYes"] = 0] = "kYes";
  ParenLess[ParenLess["kNo"] = 1] = "kNo";
})(ParenLess || (ParenLess = {}));

// This file specifies the unit strings used in CSSPrimitiveValues.
var data = [{
  name: 'em',
  unit_type: exports.UnitType.kEms
},
// {
//   name: 'ex',
//   unit_type: UnitType.kExs,
// },
{
  name: 'px',
  unit_type: exports.UnitType.kPixels
},
// {
//   name: "cm",
//   unit_type: UnitType.kCentimeters,
// },
// {
//   name: "mm",
//   unit_type: UnitType.kMillimeters,
// },
// {
//   name: "q",
//   unit_type: UnitType.kQuarterMillimeters,
// },
// {
//   name: "in",
//   unit_type: UnitType.kInches,
// },
// {
//   name: "pt",
//   unit_type: UnitType.kPoints,
// },
// {
//   name: "pc",
//   unit_type: UnitType.kPicas,
// },
{
  name: 'deg',
  unit_type: exports.UnitType.kDegrees
}, {
  name: 'rad',
  unit_type: exports.UnitType.kRadians
}, {
  name: 'grad',
  unit_type: exports.UnitType.kGradians
}, {
  name: 'ms',
  unit_type: exports.UnitType.kMilliseconds
}, {
  name: 's',
  unit_type: exports.UnitType.kSeconds
},
// {
//   name: "hz",
//   unit_type: UnitType.kHertz,
// },
// {
//   name: "khz",
//   unit_type: UnitType.kKilohertz,
// },
// {
//   name: "dpi",
//   unit_type: "kDotsPerInch",
// },
// {
//   name: "dpcm",
//   unit_type: "kDotsPerCentimeter",
// },
// {
//   name: "dppx",
//   unit_type: "kDotsPerPixel",
// },
// {
//   name: "x",
//   unit_type: "kDotsPerPixel",
// },
// {
//   name: "vw",
//   unit_type: "kViewportWidth",
// },
// {
//   name: "vh",
//   unit_type: "kViewportHeight",
// },
// {
//   name: "vi",
//   unit_type: "kViewportInlineSize",
// },
// {
//   name: "vb",
//   unit_type: "kViewportBlockSize",
// },
// {
//   name: "vmin",
//   unit_type: UnitType.kViewportMin,
// },
// {
//   name: "vmax",
//   unit_type: UnitType.kViewportMax,
// },
// {
//   name: "svw",
//   unit_type: "kSmallViewportWidth",
// },
// {
//   name: "svh",
//   unit_type: "kSmallViewportHeight",
// },
// {
//   name: "svi",
//   unit_type: "kSmallViewportInlineSize",
// },
// {
//   name: "svb",
//   unit_type: "kSmallViewportBlockSize",
// },
// {
//   name: "svmin",
//   unit_type: "kSmallViewportMin",
// },
// {
//   name: "svmax",
//   unit_type: "kSmallViewportMax",
// },
// {
//   name: "lvw",
//   unit_type: "kLargeViewportWidth",
// },
// {
//   name: "lvh",
//   unit_type: "kLargeViewportHeight",
// },
// {
//   name: "lvi",
//   unit_type: "kLargeViewportInlineSize",
// },
// {
//   name: "lvb",
//   unit_type: "kLargeViewportBlockSize",
// },
// {
//   name: "lvmin",
//   unit_type: UnitType.kLargeViewportMin,
// },
// {
//   name: "lvmax",
//   unit_type: UnitType.kLargeViewportMax,
// },
// {
//   name: "dvw",
//   unit_type: UnitType.kDynamicViewportWidth,
// },
// {
//   name: "dvh",
//   unit_type: UnitType.kDynamicViewportHeight,
// },
// {
//   name: "dvi",
//   unit_type: UnitType.kDynamicViewportInlineSize,
// },
// {
//   name: "dvb",
//   unit_type: UnitType.kDynamicViewportBlockSize,
// },
// {
//   name: "dvmin",
//   unit_type: UnitType.kDynamicViewportMin,
// },
// {
//   name: "dvmax",
//   unit_type: UnitType.kDynamicViewportMax,
// },
// {
//   name: "cqw",
//   unit_type: UnitType.kContainerWidth,
// },
// {
//   name: "cqh",
//   unit_type: UnitType.kContainerHeight,
// },
// {
//   name: "cqi",
//   unit_type: UnitType.kContainerInlineSize,
// },
// {
//   name: "cqb",
//   unit_type: UnitType.kContainerBlockSize,
// },
// {
//   name: "cqmin",
//   unit_type: UnitType.kContainerMin,
// },
// {
//   name: "cqmax",
//   unit_type: UnitType.kContainerMax,
// },
{
  name: 'rem',
  unit_type: exports.UnitType.kRems
},
// {
//   name: 'fr',
//   unit_type: UnitType.kFraction,
// },
{
  name: 'turn',
  unit_type: exports.UnitType.kTurns
}
// {
//   name: 'ch',
//   unit_type: UnitType.kChs,
// },
// {
//   name: '__qem',
//   unit_type: UnitType.kQuirkyEms,
// },
];

var CSSStyleValueType;
(function (CSSStyleValueType) {
  CSSStyleValueType[CSSStyleValueType["kUnknownType"] = 0] = "kUnknownType";
  CSSStyleValueType[CSSStyleValueType["kUnparsedType"] = 1] = "kUnparsedType";
  CSSStyleValueType[CSSStyleValueType["kKeywordType"] = 2] = "kKeywordType";
  // Start of CSSNumericValue subclasses
  CSSStyleValueType[CSSStyleValueType["kUnitType"] = 3] = "kUnitType";
  CSSStyleValueType[CSSStyleValueType["kSumType"] = 4] = "kSumType";
  CSSStyleValueType[CSSStyleValueType["kProductType"] = 5] = "kProductType";
  CSSStyleValueType[CSSStyleValueType["kNegateType"] = 6] = "kNegateType";
  CSSStyleValueType[CSSStyleValueType["kInvertType"] = 7] = "kInvertType";
  CSSStyleValueType[CSSStyleValueType["kMinType"] = 8] = "kMinType";
  CSSStyleValueType[CSSStyleValueType["kMaxType"] = 9] = "kMaxType";
  CSSStyleValueType[CSSStyleValueType["kClampType"] = 10] = "kClampType";
  // End of CSSNumericValue subclasses
  CSSStyleValueType[CSSStyleValueType["kTransformType"] = 11] = "kTransformType";
  CSSStyleValueType[CSSStyleValueType["kPositionType"] = 12] = "kPositionType";
  CSSStyleValueType[CSSStyleValueType["kURLImageType"] = 13] = "kURLImageType";
  CSSStyleValueType[CSSStyleValueType["kColorType"] = 14] = "kColorType";
  CSSStyleValueType[CSSStyleValueType["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
})(CSSStyleValueType || (CSSStyleValueType = {}));
// function parseCSSStyleValue(propertyName: string, value: string): CSSStyleValue[] {
//   // const propertyId = cssPropertyID(propertyName);
//   // if (propertyId === CSSPropertyID.kInvalid) {
//   //   return [];
//   // }
//   // const customPropertyName = propertyId === CSSPropertyID.kVariable ? propertyName : null;
//   // return fromString(propertyId, customPropertyName, value);
//   return [];
// }
var stringToUnitType = function stringToUnitType(name) {
  return data.find(function (item) {
    return item.name === name;
  }).unit_type;
};
var unitFromName = function unitFromName(name) {
  if (!name) {
    return exports.UnitType.kUnknown;
  }
  if (name === 'number') {
    return exports.UnitType.kNumber;
  }
  if (name === 'percent' || name === '%') {
    return exports.UnitType.kPercentage;
  }
  return stringToUnitType(name);
};
var unitTypeToUnitCategory = function unitTypeToUnitCategory(type) {
  switch (type) {
    case exports.UnitType.kNumber:
    case exports.UnitType.kInteger:
      return UnitCategory.kUNumber;
    case exports.UnitType.kPercentage:
      return UnitCategory.kUPercent;
    case exports.UnitType.kPixels:
      // case UnitType.kCentimeters:
      // case UnitType.kMillimeters:
      // case UnitType.kQuarterMillimeters:
      // case UnitType.kInches:
      // case UnitType.kPoints:
      // case UnitType.kPicas:
      // case UnitType.kUserUnits:
      return UnitCategory.kULength;
    case exports.UnitType.kMilliseconds:
    case exports.UnitType.kSeconds:
      return UnitCategory.kUTime;
    case exports.UnitType.kDegrees:
    case exports.UnitType.kRadians:
    case exports.UnitType.kGradians:
    case exports.UnitType.kTurns:
      return UnitCategory.kUAngle;
    // case UnitType.kHertz:
    // case UnitType.kKilohertz:
    //   return UnitCategory.kUFrequency;
    // case UnitType.kDotsPerPixel:
    // case UnitType.kDotsPerInch:
    // case UnitType.kDotsPerCentimeter:
    //   return UnitCategory.kUResolution;
    default:
      return UnitCategory.kUOther;
  }
};
var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory(category) {
  // The canonical unit type is chosen according to the way
  // CSSPropertyParser.ValidUnit() chooses the default unit in each category
  // (based on unitflags).
  switch (category) {
    case UnitCategory.kUNumber:
      return exports.UnitType.kNumber;
    case UnitCategory.kULength:
      return exports.UnitType.kPixels;
    case UnitCategory.kUPercent:
      return exports.UnitType.kPercentage;
    // return UnitType.kUnknown; // Cannot convert between numbers and percent.
    case UnitCategory.kUTime:
      return exports.UnitType.kSeconds;
    case UnitCategory.kUAngle:
      return exports.UnitType.kDegrees;
    // case UnitCategory.kUFrequency:
    //   return UnitType.kHertz;
    // case UnitCategory.kUResolution:
    //   return UnitType.kDotsPerPixel;
    default:
      return exports.UnitType.kUnknown;
  }
};
/**
 * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/css_primitive_value.cc#353
 */
var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor(unit_type) {
  var factor = 1.0;
  // FIXME: the switch can be replaced by an array of scale factors.
  switch (unit_type) {
    // These are "canonical" units in their respective categories.
    case exports.UnitType.kPixels:
    // case UnitType.kUserUnits:
    case exports.UnitType.kDegrees:
    case exports.UnitType.kSeconds:
      // case UnitType.kHertz:
      break;
    case exports.UnitType.kMilliseconds:
      factor = 0.001;
      break;
    // case UnitType.kCentimeters:
    //   // factor = kCssPixelsPerCentimeter;
    //   break;
    // case UnitType.kDotsPerCentimeter:
    //   // factor = 1 / kCssPixelsPerCentimeter;
    //   break;
    // case UnitType.kMillimeters:
    //   // factor = kCssPixelsPerMillimeter;
    //   break;
    // case UnitType.kQuarterMillimeters:
    //   // factor = kCssPixelsPerQuarterMillimeter;
    //   break;
    // case UnitType.kInches:
    //   // factor = kCssPixelsPerInch;
    //   break;
    // case UnitType.kDotsPerInch:
    //   // factor = 1 / kCssPixelsPerInch;
    //   break;
    // case UnitType.kPoints:
    //   // factor = kCssPixelsPerPoint;
    //   break;
    // case UnitType.kPicas:
    //   // factor = kCssPixelsPerPica;
    //   break;
    case exports.UnitType.kRadians:
      factor = 180 / Math.PI;
      break;
    case exports.UnitType.kGradians:
      factor = 0.9;
      break;
    case exports.UnitType.kTurns:
      factor = 360;
      break;
  }
  return factor;
};
var unitTypeToString = function unitTypeToString(type) {
  switch (type) {
    case exports.UnitType.kNumber:
    case exports.UnitType.kInteger:
      // case UnitType.kUserUnits:
      return '';
    case exports.UnitType.kPercentage:
      return '%';
    case exports.UnitType.kEms:
      // case UnitType.kQuirkyEms:
      return 'em';
    // case UnitType.kExs:
    //   return 'ex';
    case exports.UnitType.kRems:
      return 'rem';
    // case UnitType.kChs:
    //   return 'ch';
    case exports.UnitType.kPixels:
      return 'px';
    // case UnitType.kCentimeters:
    //   return 'cm';
    // case UnitType.kDotsPerPixel:
    //   return 'dppx';
    // case UnitType.kDotsPerInch:
    //   return 'dpi';
    // case UnitType.kDotsPerCentimeter:
    //   return 'dpcm';
    // case UnitType.kMillimeters:
    //   return 'mm';
    // case UnitType.kQuarterMillimeters:
    //   return 'q';
    // case UnitType.kInches:
    //   return 'in';
    // case UnitType.kPoints:
    //   return 'pt';
    // case UnitType.kPicas:
    //   return 'pc';
    case exports.UnitType.kDegrees:
      return 'deg';
    case exports.UnitType.kRadians:
      return 'rad';
    case exports.UnitType.kGradians:
      return 'grad';
    case exports.UnitType.kMilliseconds:
      return 'ms';
    case exports.UnitType.kSeconds:
      return 's';
    // case UnitType.kHertz:
    //   return 'hz';
    // case UnitType.kKilohertz:
    //   return 'khz';
    case exports.UnitType.kTurns:
      return 'turn';
  }
  return '';
};
/**
 * CSSStyleValue is the base class for all CSS values accessible from Typed OM.
 * Values that are not yet supported as specific types are also returned as base CSSStyleValues.
 *
 * Spec @see https://drafts.css-houdini.org/css-typed-om/#stylevalue-objects
 * Docs @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleValue
 */
var CSSStyleValue = /*#__PURE__*/function () {
  function CSSStyleValue() {}
  // static parse(propertyName: string, value: string): CSSStyleValue {
  //   return parseCSSStyleValue(propertyName, value)[0];
  // }
  // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
  //   return parseCSSStyleValue(propertyName, value);
  // }
  CSSStyleValue.isAngle = function isAngle(unit) {
    return unit === exports.UnitType.kDegrees || unit === exports.UnitType.kRadians || unit === exports.UnitType.kGradians || unit === exports.UnitType.kTurns;
  }
  // static isViewportPercentageLength(type: UnitType) {
  //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
  // }
  // static isContainerPercentageLength(type: UnitType) {
  //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
  // }
  ;
  CSSStyleValue.isLength = function isLength(type) {
    // return (type >= UnitType.kEms && type <= UnitType.kUserUnits) || type == UnitType.kQuirkyEms;
    return type >= exports.UnitType.kEms && type < exports.UnitType.kDegrees;
  };
  CSSStyleValue.isRelativeUnit = function isRelativeUnit(type) {
    return type === exports.UnitType.kPercentage || type === exports.UnitType.kEms ||
    // type === UnitType.kExs ||
    type === exports.UnitType.kRems
    // type === UnitType.kChs ||
    // this.isViewportPercentageLength(type) ||
    // this.isContainerPercentageLength(type)
    ;
  };
  CSSStyleValue.isTime = function isTime(unit) {
    return unit === exports.UnitType.kSeconds || unit === exports.UnitType.kMilliseconds;
  }
  // protected abstract toCSSValue(): CSSValue;
  ;
  var _proto = CSSStyleValue.prototype;
  _proto.toString = function toString() {
    return this.buildCSSText(Nested.kNo, ParenLess.kNo, '');
  };
  _proto.isNumericValue = function isNumericValue() {
    return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
  };
  return CSSStyleValue;
}();

/**
 * CSSColorValue is the base class used for the various CSS color interfaces.
 *
 * @see https://drafts.css-houdini.org/css-typed-om-1/#colorvalue-objects
 */
var CSSColorValue = /*#__PURE__*/function (_CSSStyleValue) {
  _inheritsLoose(CSSColorValue, _CSSStyleValue);
  function CSSColorValue(colorSpace) {
    var _this;
    _this = _CSSStyleValue.call(this) || this;
    _this.colorSpace = void 0;
    _this.colorSpace = colorSpace;
    return _this;
  }
  var _proto = CSSColorValue.prototype;
  _proto.getType = function getType() {
    return CSSStyleValueType.kColorType;
  }
  // buildCSSText(n: Nested, p: ParenLess, result: string): string {
  //   let text = '';
  //   if (this.colorSpace === 'rgb') {
  //     text = `rgba(${this.channels.join(',')},${this.alpha})`;
  //   }
  //   return (result += text);
  // }
  /**
   * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
   */;
  _proto.to = function to(colorSpace) {
    return this;
  };
  return CSSColorValue;
}(CSSStyleValue);

(function (GradientType) {
  GradientType[GradientType["Constant"] = 0] = "Constant";
  GradientType[GradientType["LinearGradient"] = 1] = "LinearGradient";
  GradientType[GradientType["RadialGradient"] = 2] = "RadialGradient";
})(exports.GradientType || (exports.GradientType = {}));
var CSSGradientValue = /*#__PURE__*/function (_CSSStyleValue) {
  _inheritsLoose(CSSGradientValue, _CSSStyleValue);
  function CSSGradientValue(type, value) {
    var _this;
    _this = _CSSStyleValue.call(this) || this;
    _this.type = void 0;
    _this.value = void 0;
    _this.type = type;
    _this.value = value;
    return _this;
  }
  var _proto = CSSGradientValue.prototype;
  _proto.clone = function clone() {
    return new CSSGradientValue(this.type, this.value);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result;
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kColorType;
  };
  return CSSGradientValue;
}(CSSStyleValue);

/**
 * CSSKeywordValue represents CSS Values that are specified as keywords
 * eg. 'initial'
 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSKeywordValue
 * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_keyword_value.idl
 */
var CSSKeywordValue = /*#__PURE__*/function (_CSSStyleValue) {
  _inheritsLoose(CSSKeywordValue, _CSSStyleValue);
  function CSSKeywordValue(value) {
    var _this;
    _this = _CSSStyleValue.call(this) || this;
    _this.value = void 0;
    _this.value = value;
    return _this;
  }
  var _proto = CSSKeywordValue.prototype;
  _proto.clone = function clone() {
    return new CSSKeywordValue(this.value);
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kKeywordType;
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result + this.value;
  };
  return CSSKeywordValue;
}(CSSStyleValue);

function memoize(func, resolver) {
  if (typeof func !== 'function' || resolver != null && typeof resolver !== 'function') {
    throw new TypeError('Expected a function');
  }
  var memoized = function memoized() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || Map)();
  return memoized;
}
memoize.Cache = Map;

var camelCase = memoize(function (str) {
  if (str === void 0) {
    str = '';
  }
  return str.replace(/-([a-z])/g, function (g) {
    return g[1].toUpperCase();
  });
});
var kebabize = function kebabize(str) {
  return str.split('').map(function (letter, idx) {
    return letter.toUpperCase() === letter ? "" + (idx !== 0 ? '-' : '') + letter.toLowerCase() : letter;
  }).join('');
};

function DCHECK(bool) {
  if (!bool) {
    throw new Error();
  }
}
function isFunction(func) {
  return typeof func === 'function';
}
function isSymbol(value) {
  // @see https://github.com/lodash/lodash/blob/master/isSymbol.js
  return typeof value === 'symbol';
}
var definedProps = function definedProps(obj) {
  return Object.fromEntries(Object.entries(obj).filter(function (_ref) {
    var v = _ref[1];
    return v !== undefined;
  }));
};
var FORMAT_ATTR_MAP = {
  d: {
    alias: 'path'
  },
  strokeDasharray: {
    alias: 'lineDash'
  },
  strokeWidth: {
    alias: 'lineWidth'
  },
  textAnchor: {
    alias: 'textAlign'
  },
  src: {
    alias: 'img'
  }
};
var formatAttributeName = memoize(function (name) {
  var attributeName = camelCase(name);
  var map = FORMAT_ATTR_MAP[attributeName];
  attributeName = (map === null || map === void 0 ? void 0 : map.alias) || attributeName;
  return attributeName;
});

// type CSSNumericBaseType =
//   | 'length'
//   | 'angle'
//   | 'time'
//   | 'frequency'
//   | 'resolution'
//   | 'flex'
//   | 'percent';
// https://drafts.css-houdini.org/css-typed-om/#dictdef-cssnumerictype
// interface CSSNumericType {
//   length: number;
//   angle: number;
//   time: number;
//   frequency: number;
//   resolution: number;
//   flex: number;
//   percent: number;
//   percentHint: CSSNumericBaseType;
// }
var formatInfinityOrNaN = function formatInfinityOrNaN(number, suffix) {
  if (suffix === void 0) {
    suffix = '';
  }
  var result = '';
  if (!Number.isFinite(number)) {
    if (number > 0) result = 'infinity';else result = '-infinity';
  } else {
    DCHECK(Number.isNaN(number));
    result = 'NaN';
  }
  return result += suffix;
};
var toCanonicalUnit = function toCanonicalUnit(unit) {
  return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
};
/**
 * CSSNumericValue is the base class for numeric and length typed CSS Values.
 * @see https://drafts.css-houdini.org/css-typed-om/#numeric-objects
 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue
 * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.idl
 */
/**
 * Represents numeric values that can be expressed as a single number plus a
 * unit (or a naked number or percentage).
 * @see https://drafts.css-houdini.org/css-typed-om/#cssunitvalue
 */
var CSSUnitValue = /*#__PURE__*/function (_CSSStyleValue) {
  _inheritsLoose(CSSUnitValue, _CSSStyleValue);
  function CSSUnitValue(value, unitOrName) {
    var _this;
    if (unitOrName === void 0) {
      unitOrName = exports.UnitType.kNumber;
    }
    _this = _CSSStyleValue.call(this) || this;
    _this.unit = void 0;
    _this.value = void 0;
    var unit;
    if (typeof unitOrName === 'string') {
      unit = unitFromName(unitOrName);
    } else {
      unit = unitOrName;
    }
    _this.unit = unit;
    _this.value = value;
    return _this;
  }
  var _proto = CSSUnitValue.prototype;
  _proto.clone = function clone() {
    return new CSSUnitValue(this.value, this.unit);
  };
  _proto.equals = function equals(other) {
    var other_unit_value = other;
    return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
  };
  _proto.getType = function getType() {
    return CSSStyleValueType.kUnitType;
  };
  _proto.convertTo = function convertTo(target_unit) {
    if (this.unit === target_unit) {
      return new CSSUnitValue(this.value, this.unit);
    }
    // Instead of defining the scale factors for every unit to every other unit,
    // we simply convert to the canonical unit and back since we already have
    // the scale factors for canonical units.
    var canonical_unit = toCanonicalUnit(this.unit);
    if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === exports.UnitType.kUnknown) {
      return null;
    }
    var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
    return new CSSUnitValue(this.value * scale_factor, target_unit);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    var text;
    switch (this.unit) {
      case exports.UnitType.kUnknown:
        // FIXME
        break;
      case exports.UnitType.kInteger:
        text = Number(this.value).toFixed(0);
        break;
      case exports.UnitType.kNumber:
      case exports.UnitType.kPercentage:
      case exports.UnitType.kEms:
      // case UnitType.kQuirkyEms:
      // case UnitType.kExs:
      case exports.UnitType.kRems:
      // case UnitType.kChs:
      case exports.UnitType.kPixels:
      // case UnitType.kCentimeters:
      // case UnitType.kDotsPerPixel:
      // case UnitType.kDotsPerInch:
      // case UnitType.kDotsPerCentimeter:
      // case UnitType.kMillimeters:
      // case UnitType.kQuarterMillimeters:
      // case UnitType.kInches:
      // case UnitType.kPoints:
      // case UnitType.kPicas:
      // case UnitType.kUserUnits:
      case exports.UnitType.kDegrees:
      case exports.UnitType.kRadians:
      case exports.UnitType.kGradians:
      case exports.UnitType.kMilliseconds:
      case exports.UnitType.kSeconds:
      // case UnitType.kHertz:
      // case UnitType.kKilohertz:
      case exports.UnitType.kTurns:
        // case UnitType.kContainerMax: { // case UnitType.kContainerMin: // case UnitType.kContainerBlockSize: // case UnitType.kContainerInlineSize: // case UnitType.kContainerHeight: // case UnitType.kContainerWidth: // case UnitType.kDynamicViewportMax: // case UnitType.kDynamicViewportMin: // case UnitType.kDynamicViewportBlockSize: // case UnitType.kDynamicViewportInlineSize: // case UnitType.kDynamicViewportHeight: // case UnitType.kDynamicViewportWidth: // case UnitType.kLargeViewportMax: // case UnitType.kLargeViewportMin: // case UnitType.kLargeViewportBlockSize: // case UnitType.kLargeViewportInlineSize: // case UnitType.kLargeViewportHeight: // case UnitType.kLargeViewportWidth: // case UnitType.kSmallViewportMax: // case UnitType.kSmallViewportMin: // case UnitType.kSmallViewportBlockSize: // case UnitType.kSmallViewportInlineSize: // case UnitType.kSmallViewportHeight: // case UnitType.kSmallViewportWidth: // case UnitType.kViewportMax: // case UnitType.kViewportMin: // case UnitType.kViewportBlockSize: // case UnitType.kViewportInlineSize: // case UnitType.kViewportHeight: // case UnitType.kViewportWidth: // case UnitType.kFraction:
        {
          var kMinInteger = -999999;
          var kMaxInteger = 999999;
          var value = this.value;
          var unit = unitTypeToString(this.unit);
          if (value < kMinInteger || value > kMaxInteger) {
            var _unit = unitTypeToString(this.unit);
            if (!Number.isFinite(value) || Number.isNaN(value)) {
              text = formatInfinityOrNaN(value, _unit);
            } else {
              text = value + (_unit || '');
            }
          } else {
            text = "" + value + unit;
          }
        }
    }
    result += text;
    return result;
  };
  return CSSUnitValue;
}(CSSStyleValue);
var Opx = new CSSUnitValue(0, 'px');
var Lpx = new CSSUnitValue(1, 'px');
var Odeg = new CSSUnitValue(0, 'deg');

/**
 * The CSSRGB class represents the CSS rgb()/rgba() functions.
 *
 * @see https://drafts.css-houdini.org/css-typed-om-1/#cssrgb
 */
var CSSRGB = /*#__PURE__*/function (_CSSColorValue) {
  _inheritsLoose(CSSRGB, _CSSColorValue);
  function CSSRGB(r, g, b, alpha,
  /**
   * 'transparent' & 'none' has the same rgba data
   */
  isNone) {
    var _this;
    if (alpha === void 0) {
      alpha = 1;
    }
    if (isNone === void 0) {
      isNone = false;
    }
    _this = _CSSColorValue.call(this, 'rgb') || this;
    _this.r = void 0;
    _this.g = void 0;
    _this.b = void 0;
    _this.alpha = void 0;
    _this.isNone = void 0;
    _this.r = r;
    _this.g = g;
    _this.b = b;
    _this.alpha = alpha;
    _this.isNone = isNone;
    return _this;
  }
  var _proto = CSSRGB.prototype;
  _proto.clone = function clone() {
    return new CSSRGB(this.r, this.g, this.b, this.alpha);
  };
  _proto.buildCSSText = function buildCSSText(n, p, result) {
    return result + ("rgba(" + this.r + "," + this.g + "," + this.b + "," + this.alpha + ")");
  };
  return CSSRGB;
}(CSSColorValue);

/**
 * holds useful CSS-related methods.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS
 *
 * * CSS Typed OM @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/factory_functions
 * * register property @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
 * * CSS Layout API
 */
var CSS = {
  /**
   * <number>
   * @see https://drafts.csswg.org/css-values-4/#number-value
   */
  number: function number(n) {
    return new CSSUnitValue(n);
  },
  /**
   * <percentage>
   * @see https://drafts.csswg.org/css-values-4/#percentage-value
   */
  percent: function percent(n) {
    return new CSSUnitValue(n, '%');
  },
  /**
   * <length>
   */
  px: function px(n) {
    return new CSSUnitValue(n, 'px');
  },
  /**
   * <length>
   */
  em: function em(n) {
    return new CSSUnitValue(n, 'em');
  },
  rem: function rem(n) {
    return new CSSUnitValue(n, 'rem');
  },
  /**
   * <angle>
   */
  deg: function deg(n) {
    return new CSSUnitValue(n, 'deg');
  },
  /**
   * <angle>
   */
  grad: function grad(n) {
    return new CSSUnitValue(n, 'grad');
  },
  /**
   * <angle>
   */
  rad: function rad(n) {
    return new CSSUnitValue(n, 'rad');
  },
  /**
   * <angle>
   */
  turn: function turn(n) {
    return new CSSUnitValue(n, 'turn');
  },
  /**
   * <time>
   */
  s: function s(n) {
    return new CSSUnitValue(n, 's');
  },
  /**
   * <time>
   */
  ms: function ms(n) {
    return new CSSUnitValue(n, 'ms');
  },
  /**
   * CSS Properties & Values API
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
   * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   */
  registerProperty: function registerProperty(definition) {
    var name = definition.name,
      inherits = definition.inherits,
      interpolable = definition.interpolable,
      initialValue = definition.initialValue,
      syntax = definition.syntax;
    runtime.styleValueRegistry.registerMetadata({
      n: name,
      inh: inherits,
      int: interpolable,
      d: initialValue,
      syntax: syntax
    });
  },
  /**
   * CSS Layout API
   * register layout
   *
   * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
   * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
   */
  registerLayout: function registerLayout(name, clazz) {
    runtime.layoutRegistry.registerLayout(name, clazz);
  }
};

/**
 * CSSKeywordValue
 */
var unsetKeywordValue = new CSSKeywordValue('unset');
var initialKeywordValue = new CSSKeywordValue('initial');
var inheritKeywordValue = new CSSKeywordValue('inherit');
var keywordCache = {
  '': unsetKeywordValue,
  unset: unsetKeywordValue,
  initial: initialKeywordValue,
  inherit: inheritKeywordValue
};
var getOrCreateKeyword = function getOrCreateKeyword(name) {
  if (!keywordCache[name]) {
    keywordCache[name] = new CSSKeywordValue(name);
  }
  return keywordCache[name];
};
/**
 * CSSColor
 */
var noneColor = new CSSRGB(0, 0, 0, 0, true);
var transparentColor = new CSSRGB(0, 0, 0, 0);
var getOrCreateRGBA = memoize(function (r, g, b, a) {
  return new CSSRGB(r, g, b, a);
}, function (r, g, b, a) {
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
});
// export const getOrCreateUnitValue = memoize(
//   (value: number, unitOrName: UnitType | string = UnitType.kNumber) => {
//     return new CSSUnitValue(value, unitOrName);
//   },
//   (value: number, unitOrName: UnitType | string = UnitType.kNumber) => {
//     return `${value}${unitOrName}`;
//   },
// );
var getOrCreateUnitValue = function getOrCreateUnitValue(value, unitOrName) {
  if (unitOrName === void 0) {
    unitOrName = exports.UnitType.kNumber;
  }
  return new CSSUnitValue(value, unitOrName);
};

var canvasMap = {};
var defaultCanvasIdCounter = 0;
/**
 * destroy existed canvas with the same id
 */
function cleanExistedCanvas(container, canvas) {
  if (container) {
    var id = typeof container === 'string' ? container : container.id || defaultCanvasIdCounter++;
    if (canvasMap[id]) {
      canvasMap[id].destroy();
    }
    canvasMap[id] = canvas;
  }
}
var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

function sortByZIndex(o1, o2) {
  var zIndex1 = Number(o1.parsedStyle.zIndex);
  var zIndex2 = Number(o2.parsedStyle.zIndex);
  if (zIndex1 === zIndex2) {
    // return o1.entity.getComponent(Sortable).lastSortedIndex - o2.entity.getComponent(Sortable).lastSortedIndex;
    var parent = o1.parentNode;
    if (parent) {
      var children = parent.childNodes || [];
      return children.indexOf(o1) - children.indexOf(o2);
    }
  }
  return zIndex1 - zIndex2;
}
function findClosestClipPathTarget(object) {
  var el = object;
  do {
    var _el$style;
    var clipPath = (_el$style = el.style) === null || _el$style === void 0 ? void 0 : _el$style.clipPath;
    if (clipPath) return el;
    el = el.parentElement;
  } while (el !== null);
  return null;
}
var PX_SUFFIX = 'px';
function setDOMSize($el, width, height) {
  if (isBrowser && $el.style) {
    $el.style.width = width + PX_SUFFIX;
    $el.style.height = height + PX_SUFFIX;
  }
}
function getStyle($el, property) {
  if (isBrowser) {
    return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
  }
}
function getWidth($el) {
  var width = getStyle($el, 'width');
  if (width === 'auto') {
    return $el.offsetWidth;
  }
  return parseFloat(width);
}
function getHeight($el) {
  var height = getStyle($el, 'height');
  if (height === 'auto') {
    return $el.offsetHeight;
  }
  return parseFloat(height);
}

var ERROR_MSG_METHOD_NOT_IMPLEMENTED = 'Method not implemented.';
var ERROR_MSG_USE_DOCUMENT_ELEMENT = 'Use document.documentElement instead.';
var ERROR_MSG_APPEND_DESTROYED_ELEMENT = 'Cannot append a destroyed element.';

// borrow from hammer.js
var MOUSE_POINTER_ID = 1;
var TOUCH_TO_POINTER = {
  touchstart: 'pointerdown',
  touchend: 'pointerup',
  touchendoutside: 'pointerupoutside',
  touchmove: 'pointermove',
  touchcancel: 'pointercancel'
};

function copyVec3(a, b) {
  a[0] = b[0];
  a[1] = b[1];
  a[2] = b[2];
  return a;
}
function subVec3(o, a, b) {
  o[0] = a[0] - b[0];
  o[1] = a[1] - b[1];
  o[2] = a[2] - b[2];
  return o;
}
function addVec3(o, a, b) {
  o[0] = a[0] + b[0];
  o[1] = a[1] + b[1];
  o[2] = a[2] + b[2];
  return o;
}
function scaleVec3(o, a, b) {
  o[0] = a[0] * b;
  o[1] = a[1] * b;
  o[2] = a[2] * b;
  return o;
}
function maxVec3(o, a, b) {
  o[0] = Math.max(a[0], b[0]);
  o[1] = Math.max(a[1], b[1]);
  o[2] = Math.max(a[2], b[2]);
  return o;
}
function minVec3(o, a, b) {
  o[0] = Math.min(a[0], b[0]);
  o[1] = Math.min(a[1], b[1]);
  o[2] = Math.min(a[2], b[2]);
  return o;
}
function getAngle(angle) {
  if (angle === undefined) {
    return 0;
  } else if (angle > 360 || angle < -360) {
    return angle % 360;
  }
  return angle;
}
function createVec3(x, y, z) {
  if (y === void 0) {
    y = 0;
  }
  if (z === void 0) {
    z = 0;
  }
  if (Array.isArray(x) && x.length === 3) {
    return glMatrix.vec3.clone(x);
  }
  if (util.isNumber(x)) {
    return glMatrix.vec3.fromValues(x, y, z);
  }
  return glMatrix.vec3.fromValues(x[0], x[1] || y, x[2] || z);
}
function deg2rad(deg) {
  return deg * (Math.PI / 180);
}
function rad2deg(rad) {
  return rad * (180 / Math.PI);
}
function grad2deg(grads) {
  grads = grads % 400;
  if (grads < 0) {
    grads += 400;
  }
  return grads / 400 * 360;
}
function deg2turn(deg) {
  return deg / 360;
}
function turn2deg(turn) {
  return 360 * turn;
}
function getEulerFromQuat(out, quat) {
  var x = quat[0];
  var y = quat[1];
  var z = quat[2];
  var w = quat[3];
  var x2 = x * x;
  var y2 = y * y;
  var z2 = z * z;
  var w2 = w * w;
  var unit = x2 + y2 + z2 + w2;
  var test = x * w - y * z;
  if (test > 0.499995 * unit) {
    // TODO: Use glmatrix.EPSILON
    // singularity at the north pole
    out[0] = Math.PI / 2;
    out[1] = 2 * Math.atan2(y, x);
    out[2] = 0;
  } else if (test < -0.499995 * unit) {
    //TODO: Use glmatrix.EPSILON
    // singularity at the south pole
    out[0] = -Math.PI / 2;
    out[1] = 2 * Math.atan2(y, x);
    out[2] = 0;
  } else {
    out[0] = Math.asin(2 * (x * z - w * y));
    out[1] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (z2 + w2));
    out[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y2 + z2));
  }
  // TODO: Return them as degrees and not as radians
  return out;
}
function getEulerFromMat4(out, m) {
  var x;
  var z;
  var halfPi = Math.PI * 0.5;
  var _mat4$getScaling = glMatrix.mat4.getScaling(glMatrix.vec3.create(), m),
    sx = _mat4$getScaling[0],
    sy = _mat4$getScaling[1],
    sz = _mat4$getScaling[2];
  var y = Math.asin(-m[2] / sx);
  if (y < halfPi) {
    if (y > -halfPi) {
      x = Math.atan2(m[6] / sy, m[10] / sz);
      z = Math.atan2(m[1] / sx, m[0] / sx);
    } else {
      // Not a unique solution
      z = 0;
      x = -Math.atan2(m[4] / sy, m[5] / sy);
    }
  } else {
    // Not a unique solution
    z = 0;
    x = Math.atan2(m[4] / sy, m[5] / sy);
  }
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * @see https://github.com/toji/gl-matrix/issues/329
 * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions
 */
function getEuler(out, quat) {
  if (quat.length === 16) {
    return getEulerFromMat4(out, quat);
  } else {
    return getEulerFromQuat(out, quat);
  }
}
function fromRotationTranslationScale(rotation, x, y, scaleX, scaleY) {
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  return glMatrix.mat3.fromValues(scaleX * cos, scaleY * sin, 0, -scaleX * sin, scaleY * cos, 0, x, y, 1);
}
function makePerspective(out, left, right, top, bottom, near, far) {
  var x = 2 * near / (right - left);
  var y = 2 * near / (top - bottom);
  var a = (right + left) / (right - left);
  var b = (top + bottom) / (top - bottom);
  var c = -(far + near) / (far - near);
  var d = -2 * far * near / (far - near);
  out[0] = x;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = y;
  out[6] = 0;
  out[7] = 0;
  out[8] = a;
  out[9] = b;
  out[10] = c;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = d;
  out[15] = 0;
  return out;
}
function decompose(mat) {
  var row0x = mat[0];
  var row0y = mat[1];
  var row1x = mat[3];
  var row1y = mat[4];
  // decompose 3x3 matrix
  // @see https://www.w3.org/TR/css-transforms-1/#decomposing-a-2d-matrix
  var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
  var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
  // If determinant is negative, one axis was flipped.
  var determinant = row0x * row1y - row0y * row1x;
  if (determinant < 0) {
    // Flip axis with minimum unit vector dot product.
    if (row0x < row1y) {
      scalingX = -scalingX;
    } else {
      scalingY = -scalingY;
    }
  }
  // Renormalize matrix to remove scale.
  if (scalingX) {
    row0x *= 1 / scalingX;
    row0y *= 1 / scalingX;
  }
  if (scalingY) {
    row1x *= 1 / scalingY;
    row1y *= 1 / scalingY;
  }
  // Compute rotation and renormalize matrix.
  var rotation = Math.atan2(row0y, row0x);
  var angle = rad2deg(rotation);
  return [mat[6], mat[7], scalingX, scalingY, angle];
}
var tmp = glMatrix.mat4.create();
var perspectiveMatrix = glMatrix.mat4.create();
var tmpVec4 = glMatrix.vec4.create();
var row = [glMatrix.vec3.create(), glMatrix.vec3.create(), glMatrix.vec3.create()];
var pdum3 = glMatrix.vec3.create();
/*
Input:  matrix      ; a 4x4 matrix
Output: translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Returns false if the matrix cannot be decomposed, true if it can


References:
https://github.com/kamicane/matrix3d/blob/master/lib/Matrix3d.js
https://github.com/ChromiumWebApps/chromium/blob/master/ui/gfx/transform_util.cc
http://www.w3.org/TR/css3-transforms/#decomposing-a-3d-matrix
*/
function decomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {
  //normalize, if not possible then bail out early
  if (!normalize(tmp, matrix)) return false;
  // perspectiveMatrix is used to solve for perspective, but it also provides
  // an easy way to test for singularity of the upper 3x3 component.
  glMatrix.mat4.copy(perspectiveMatrix, tmp);
  perspectiveMatrix[3] = 0;
  perspectiveMatrix[7] = 0;
  perspectiveMatrix[11] = 0;
  perspectiveMatrix[15] = 1;
  // If the perspectiveMatrix is not invertible, we are also unable to
  // decompose, so we'll bail early. Constant taken from SkMatrix44::invert.
  if (Math.abs(glMatrix.mat4.determinant(perspectiveMatrix)) < 1e-8) return false;
  var a03 = tmp[3],
    a13 = tmp[7],
    a23 = tmp[11],
    a30 = tmp[12],
    a31 = tmp[13],
    a32 = tmp[14],
    a33 = tmp[15];
  // First, isolate perspective.
  if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
    tmpVec4[0] = a03;
    tmpVec4[1] = a13;
    tmpVec4[2] = a23;
    tmpVec4[3] = a33;
    // Solve the equation by inverting perspectiveMatrix and multiplying
    // rightHandSide by the inverse.
    // resuing the perspectiveMatrix here since it's no longer needed
    var ret = glMatrix.mat4.invert(perspectiveMatrix, perspectiveMatrix);
    if (!ret) return false;
    glMatrix.mat4.transpose(perspectiveMatrix, perspectiveMatrix);
    //multiply by transposed inverse perspective matrix, into perspective vec4
    glMatrix.vec4.transformMat4(perspective, tmpVec4, perspectiveMatrix);
  } else {
    //no perspective
    perspective[0] = perspective[1] = perspective[2] = 0;
    perspective[3] = 1;
  }
  // Next take care of translation
  translation[0] = a30;
  translation[1] = a31;
  translation[2] = a32;
  // Now get scale and shear. 'row' is a 3 element array of 3 component vectors
  mat3from4(row, tmp);
  // Compute X scale factor and normalize first row.
  scale[0] = glMatrix.vec3.length(row[0]);
  glMatrix.vec3.normalize(row[0], row[0]);
  // Compute XY shear factor and make 2nd row orthogonal to 1st.
  skew[0] = glMatrix.vec3.dot(row[0], row[1]);
  combine(row[1], row[1], row[0], 1.0, -skew[0]);
  // Now, compute Y scale and normalize 2nd row.
  scale[1] = glMatrix.vec3.length(row[1]);
  glMatrix.vec3.normalize(row[1], row[1]);
  skew[0] /= scale[1];
  // Compute XZ and YZ shears, orthogonalize 3rd row
  skew[1] = glMatrix.vec3.dot(row[0], row[2]);
  combine(row[2], row[2], row[0], 1.0, -skew[1]);
  skew[2] = glMatrix.vec3.dot(row[1], row[2]);
  combine(row[2], row[2], row[1], 1.0, -skew[2]);
  // Next, get Z scale and normalize 3rd row.
  scale[2] = glMatrix.vec3.length(row[2]);
  glMatrix.vec3.normalize(row[2], row[2]);
  skew[1] /= scale[2];
  skew[2] /= scale[2];
  // At this point, the matrix (in rows) is orthonormal.
  // Check for a coordinate system flip.  If the determinant
  // is -1, then negate the matrix and the scaling factors.
  glMatrix.vec3.cross(pdum3, row[1], row[2]);
  if (glMatrix.vec3.dot(row[0], pdum3) < 0) {
    for (var i = 0; i < 3; i++) {
      scale[i] *= -1;
      row[i][0] *= -1;
      row[i][1] *= -1;
      row[i][2] *= -1;
    }
  }
  // Now, get the rotations out
  quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
  quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
  quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
  quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
  if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];
  if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];
  if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];
  return true;
}
function normalize(out, mat) {
  var m44 = mat[15];
  // Cannot normalize.
  if (m44 === 0) return false;
  var scale = 1 / m44;
  for (var i = 0; i < 16; i++) {
    out[i] = mat[i] * scale;
  }
  return true;
}
//gets upper-left of a 4x4 matrix into a 3x3 of vectors
function mat3from4(out, mat4x4) {
  out[0][0] = mat4x4[0];
  out[0][1] = mat4x4[1];
  out[0][2] = mat4x4[2];
  out[1][0] = mat4x4[4];
  out[1][1] = mat4x4[5];
  out[1][2] = mat4x4[6];
  out[2][0] = mat4x4[8];
  out[2][1] = mat4x4[9];
  out[2][2] = mat4x4[10];
}
function combine(out, a, b, scale1, scale2) {
  out[0] = a[0] * scale1 + b[0] * scale2;
  out[1] = a[1] * scale1 + b[1] * scale2;
  out[2] = a[2] * scale1 + b[2] * scale2;
}
var tmpMat4 = glMatrix.mat4.create();
function parsedTransformToMat4(transform, object) {
  if (transform && transform.length) {
    var defX = 0;
    var defY = 0;
    if (object) {
      defX = object.parsedStyle.defX || 0;
      defY = object.parsedStyle.defY || 0;
      // reset transform
      object.resetLocalTransform();
      object.setLocalPosition(defX, defY);
    } else {
      object = new DisplayObject({});
    }
    transform.forEach(function (parsed) {
      var t = parsed.t,
        d = parsed.d;
      if (t === 'scale') {
        // scale(1) scale(1, 1)
        var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) {
          return s.value;
        })) || [1, 1];
        object.scaleLocal(newScale[0], newScale[1], 1);
      } else if (t === 'scalex') {
        var _newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) {
          return s.value;
        })) || [1];
        object.scaleLocal(_newScale[0], 1, 1);
      } else if (t === 'scaley') {
        var _newScale2 = (d === null || d === void 0 ? void 0 : d.map(function (s) {
          return s.value;
        })) || [1];
        object.scaleLocal(1, _newScale2[0], 1);
      } else if (t === 'scalez') {
        var _newScale3 = (d === null || d === void 0 ? void 0 : d.map(function (s) {
          return s.value;
        })) || [1];
        object.scaleLocal(1, 1, _newScale3[0]);
      } else if (t === 'scale3d') {
        var _newScale4 = (d === null || d === void 0 ? void 0 : d.map(function (s) {
          return s.value;
        })) || [1, 1, 1];
        object.scaleLocal(_newScale4[0], _newScale4[1], _newScale4[2]);
      } else if (t === 'translate') {
        var newTranslation = d || [Opx, Opx];
        object.translateLocal(newTranslation[0].value, newTranslation[1].value, 0);
      } else if (t === 'translatex') {
        var _newTranslation = d || [Opx];
        object.translateLocal(_newTranslation[0].value, 0, 0);
      } else if (t === 'translatey') {
        var _newTranslation2 = d || [Opx];
        object.translateLocal(0, _newTranslation2[0].value, 0);
      } else if (t === 'translatez') {
        var _newTranslation3 = d || [Opx];
        object.translateLocal(0, 0, _newTranslation3[0].value);
      } else if (t === 'translate3d') {
        var _newTranslation4 = d || [Opx, Opx, Opx];
        object.translateLocal(_newTranslation4[0].value, _newTranslation4[1].value, _newTranslation4[2].value);
      } else if (t === 'rotate') {
        var newAngles = d || [Odeg];
        object.rotateLocal(0, 0, convertAngleUnit(newAngles[0]));
      } else if (t === 'rotatex') {
        var _newAngles = d || [Odeg];
        object.rotateLocal(convertAngleUnit(_newAngles[0]), 0, 0);
      } else if (t === 'rotatey') {
        var _newAngles2 = d || [Odeg];
        object.rotateLocal(0, convertAngleUnit(_newAngles2[0]), 0);
      } else if (t === 'rotatez') {
        var _newAngles3 = d || [Odeg];
        object.rotateLocal(0, 0, convertAngleUnit(_newAngles3[0]));
      } else if (t === 'rotate3d') ; else if (t === 'skew') {
        var newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) {
          return s.value;
        })) || [0, 0];
        object.setLocalSkew(deg2rad(newSkew[0]), deg2rad(newSkew[1]));
      } else if (t === 'skewx') {
        var _newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) {
          return s.value;
        })) || [0];
        object.setLocalSkew(deg2rad(_newSkew[0]), object.getLocalSkew()[1]);
      } else if (t === 'skewy') {
        var _newSkew2 = (d === null || d === void 0 ? void 0 : d.map(function (s) {
          return s.value;
        })) || [0];
        object.setLocalSkew(object.getLocalSkew()[0], deg2rad(_newSkew2[0]));
      } else if (t === 'matrix') {
        var _d$map = d.map(function (s) {
            return s.value;
          }),
          a = _d$map[0],
          b = _d$map[1],
          c = _d$map[2],
          dd = _d$map[3],
          tx = _d$map[4],
          ty = _d$map[5];
        object.setLocalTransform(glMatrix.mat4.set(tmpMat4, a, b, 0, 0, c, dd, 0, 0, 0, 0, 1, 0, tx + defX, ty + defY, 0, 1));
      } else if (t === 'matrix3d') {
        // @ts-ignore
        glMatrix.mat4.set.apply(glMatrix.mat4, [tmpMat4].concat(d.map(function (s) {
          return s.value;
        })));
        tmpMat4[12] += defX;
        tmpMat4[13] += defY;
        object.setLocalTransform(tmpMat4);
      }
    });
  }
  return object.getLocalTransform();
}

/**
 * borrow from gradient-parser, but we delete some browser compatible prefix such as `-webkit-`
 * @see https://github.com/rafaelcaricio/gradient-parser
 */
function colorStopToString(colorStop) {
  var type = colorStop.type,
    value = colorStop.value;
  if (type === 'hex') {
    return "#" + value;
  } else if (type === 'literal') {
    return value;
  } else if (type === 'rgb') {
    return "rgb(" + value.join(',') + ")";
  } else {
    return "rgba(" + value.join(',') + ")";
  }
}
var parseGradient = function () {
  var tokens = {
    linearGradient: /^(linear\-gradient)/i,
    repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
    /**
     * @see https://projects.verou.me/conic-gradient/
     */
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = '';
  function error(msg) {
    throw new Error(input + ': ' + msg);
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error('Invalid input not EOF');
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient('linear-gradient', tokens.linearGradient, matchLinearOrientation) || matchGradient('repeating-linear-gradient', tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient('radial-gradient', tokens.radialGradient, matchListRadialOrientations) || matchGradient('repeating-radial-gradient', tokens.repeatingRadialGradient, matchListRadialOrientations) || matchGradient('conic-gradient', tokens.conicGradient, matchListRadialOrientations);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function (captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error('Missing comma before color stops');
        }
      }
      return {
        type: gradientType,
        orientation: orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens.startCall)) {
        error('Missing (');
      }
      var result = callback(captures);
      if (!scan(tokens.endCall)) {
        error('Missing )');
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match('directional', tokens.sideOrCorner, 1);
  }
  function matchAngle() {
    return match('angular', tokens.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations,
      radialOrientation = matchRadialOrientation(),
      lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      // @ts-ignore
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          // @ts-ignore
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: 'default-radial',
            // @ts-ignore
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle = match('shape', /^(circle)/i, 0);
    if (circle) {
      // @ts-ignore
      circle.style = matchLength() || matchExtentKeyword();
    }
    return circle;
  }
  function matchEllipse() {
    var ellipse = match('shape', /^(ellipse)/i, 0);
    if (ellipse) {
      // @ts-ignore
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match('extent-keyword', tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match('position', /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error('Missing positioning value');
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: 'position',
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher();
    var result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error('One extra comma');
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color = matchColor();
    if (!color) {
      error('Expected color definition');
    }
    color.length = matchDistance();
    return color;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match('literal', tokens.literalColor, 0);
  }
  function matchHexColor() {
    return match('hex', tokens.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function () {
      return {
        type: 'rgb',
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function () {
      return {
        type: 'rgba',
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens.number)[1];
  }
  function matchDistance() {
    return match('%', tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match('position-keyword', tokens.positionKeywords, 1);
  }
  function matchLength() {
    return match('px', tokens.pixelValue, 1) || match('em', tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type: type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    var captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size) {
    input = input.substring(size);
  }
  return function (code) {
    input = code;
    return getAST();
  };
}();
function computeLinearGradient(width, height, angle) {
  var rad = deg2rad(angle.value);
  var rx = 0;
  var ry = 0;
  var rcx = rx + width / 2;
  var rcy = ry + height / 2;
  // get the length of gradient line
  // @see https://observablehq.com/@danburzo/css-gradient-line
  var length = Math.abs(width * Math.cos(rad)) + Math.abs(height * Math.sin(rad));
  var x1 = rcx - Math.cos(rad) * length / 2;
  var y1 = rcy - Math.sin(rad) * length / 2;
  var x2 = rcx + Math.cos(rad) * length / 2;
  var y2 = rcy + Math.sin(rad) * length / 2;
  return {
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2
  };
}
function computeRadialGradient(width, height, cx, cy, size) {
  // 'px'
  var x = cx.value;
  var y = cy.value;
  // TODO: 'em'
  // '%'
  if (cx.unit === exports.UnitType.kPercentage) {
    x = cx.value / 100 * width;
  }
  if (cy.unit === exports.UnitType.kPercentage) {
    y = cy.value / 100 * height;
  }
  // default to farthest-side
  var r = Math.max(util.distanceSquareRoot([0, 0], [x, y]), util.distanceSquareRoot([0, height], [x, y]), util.distanceSquareRoot([width, height], [x, y]), util.distanceSquareRoot([width, 0], [x, y]));
  if (size) {
    if (size instanceof CSSUnitValue) {
      r = size.value;
    } else if (size instanceof CSSKeywordValue) {
      // @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Using_CSS_gradients#example_closest-side_for_circles
      if (size.value === 'closest-side') {
        r = Math.min(x, width - x, y, height - y);
      } else if (size.value === 'farthest-side') {
        r = Math.max(x, width - x, y, height - y);
      } else if (size.value === 'closest-corner') {
        r = Math.min(util.distanceSquareRoot([0, 0], [x, y]), util.distanceSquareRoot([0, height], [x, y]), util.distanceSquareRoot([width, height], [x, y]), util.distanceSquareRoot([width, 0], [x, y]));
      }
    }
  }
  return {
    x: x,
    y: y,
    r: r
  };
}

(function (Shape) {
  Shape["GROUP"] = "g";
  Shape["CIRCLE"] = "circle";
  Shape["ELLIPSE"] = "ellipse";
  Shape["IMAGE"] = "image";
  Shape["RECT"] = "rect";
  Shape["LINE"] = "line";
  Shape["POLYLINE"] = "polyline";
  Shape["POLYGON"] = "polygon";
  Shape["TEXT"] = "text";
  Shape["PATH"] = "path";
  Shape["HTML"] = "html";
  Shape["MESH"] = "mesh";
})(exports.Shape || (exports.Shape = {}));

function getOrCalculatePathTotalLength(path) {
  if (path.parsedStyle.path.totalLength === 0) {
    path.parsedStyle.path.totalLength = util.getTotalLength(path.parsedStyle.path.absolutePath);
  }
  return path.parsedStyle.path.totalLength;
}
function hasArcOrBezier(path) {
  var hasArc = false;
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];
    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {
      hasArc = true;
      break;
    }
  }
  return hasArc;
}
function extractPolygons(pathArray) {
  var polygons = [];
  var polylines = [];
  var points = []; // 防止第一个命令不是 'M'
  for (var i = 0; i < pathArray.length; i++) {
    var params = pathArray[i];
    var cmd = params[0];
    if (cmd === 'M') {
      // 遇到 'M' 判定是否是新数组，新数组中没有点
      if (points.length) {
        // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形
        polylines.push(points);
        points = []; // 创建新的点
      }

      points.push([params[1], params[2]]);
    } else if (cmd === 'Z') {
      if (points.length) {
        // 存在点
        polygons.push(points);
        points = []; // 开始新的点集合
      }
      // 如果不存在点，同时 'Z'，则说明是错误，不处理
    } else {
      points.push([params[1], params[2]]);
    }
  }
  // 说明 points 未放入 polygons 或者 polyline
  // 仅当只有一个 M，没有 Z 时会发生这种情况
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons: polygons,
    polylines: polylines
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getPathBBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint,
      params = segment.params,
      prePoint = segment.prePoint;
    var box = void 0;
    switch (segment.command) {
      case 'Q':
        box = gMath.Quad.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case 'C':
        box = gMath.Cubic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case 'A':
        var arcParams = segment.arcParams;
        box = gMath.Arc.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box) {
      segment.box = box;
      xArr.push(box.x, box.x + box.width);
      yArr.push(box.y, box.y + box.height);
    }
    if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  // bbox calculation should ignore NaN for path attribute
  // ref: https://github.com/antvis/g/issues/210
  // ref: https://github.com/antvis/G2/issues/3109
  xArr = xArr.filter(function (item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function (item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = util.min(xArr);
  var minY = util.min(yArr);
  var maxX = util.max(xArr);
  var maxY = util.max(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
    var _segment = segmentsWithAngle[_i];
    var _currentPoint = _segment.currentPoint;
    var extra = void 0;
    if (_currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (_currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (_currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (_currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint,
    currentPoint = segment.currentPoint,
    nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  // 以 currentPoint 为顶点的夹角
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度
  // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等
  if (!currentAngle || Math.sin(currentAngle) === 0 || util.isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  // 将夹角转为锐角
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  // 这里不考虑在水平和垂直方向的投影，直接使用最大差值
  // 由于上层统一加减了二分之一线宽，这里需要进行弥补
  var extra = {
    // 水平方向投影
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 垂直方向投影
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
// 点对称
function toSymmetry(point, center) {
  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}
var angleBetween = function angleBetween(v0, v1) {
  var p = v0.x * v1.x + v0.y * v1.y;
  var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
  var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
  var angle = sign * Math.acos(p / n);
  return angle;
};
/**
 * @see https://github.com/rveciana/svg-path-properties/blob/b6bd9a322966f6ef7a311872d80c56e3718de861/src/arc.ts#L121
 */
var pointOnEllipticalArc = function pointOnEllipticalArc(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
  // In accordance to: http://www.w3.org/TR/SVG/implnote.html#ArcOutOfRangeParameters
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  xAxisRotation = util.mod(xAxisRotation, 360);
  var xAxisRotationRadians = deg2rad(xAxisRotation);
  // If the endpoints are identical, then this is equivalent to omitting the elliptical arc segment entirely.
  if (p0.x === p1.x && p0.y === p1.y) {
    return {
      x: p0.x,
      y: p0.y,
      ellipticalArcAngle: 0
    }; // Check if angle is correct
  }
  // If rx = 0 or ry = 0 then this arc is treated as a straight line segment joining the endpoints.
  if (rx === 0 || ry === 0) {
    //return this.pointOnLine(p0, p1, t);
    return {
      x: 0,
      y: 0,
      ellipticalArcAngle: 0
    }; // Check if angle is correct
  }
  // Following "Conversion from endpoint to center parameterization"
  // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter
  // Step #1: Compute transformedPoint
  var dx = (p0.x - p1.x) / 2;
  var dy = (p0.y - p1.y) / 2;
  var transformedPoint = {
    x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
    y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
  };
  // Ensure radii are large enough
  var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
  if (radiiCheck > 1) {
    rx = Math.sqrt(radiiCheck) * rx;
    ry = Math.sqrt(radiiCheck) * ry;
  }
  // Step #2: Compute transformedCenter
  var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
  var cRadicand = cSquareNumerator / cSquareRootDenom;
  // Make sure this never drops below zero because of precision
  cRadicand = cRadicand < 0 ? 0 : cRadicand;
  var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
  var transformedCenter = {
    x: cCoef * (rx * transformedPoint.y / ry),
    y: cCoef * (-(ry * transformedPoint.x) / rx)
  };
  // Step #3: Compute center
  var center = {
    x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
    y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
  };
  // Step #4: Compute start/sweep angles
  // Start angle of the elliptical arc prior to the stretch and rotate operations.
  // Difference between the start and end angles
  var startVector = {
    x: (transformedPoint.x - transformedCenter.x) / rx,
    y: (transformedPoint.y - transformedCenter.y) / ry
  };
  var startAngle = angleBetween({
    x: 1,
    y: 0
  }, startVector);
  var endVector = {
    x: (-transformedPoint.x - transformedCenter.x) / rx,
    y: (-transformedPoint.y - transformedCenter.y) / ry
  };
  var sweepAngle = angleBetween(startVector, endVector);
  if (!sweepFlag && sweepAngle > 0) {
    sweepAngle -= 2 * Math.PI;
  } else if (sweepFlag && sweepAngle < 0) {
    sweepAngle += 2 * Math.PI;
  }
  // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)
  sweepAngle %= 2 * Math.PI;
  // From http://www.w3.org/TR/SVG/implnote.html#ArcParameterizationAlternatives
  var angle = startAngle + sweepAngle * t;
  var ellipseComponentX = rx * Math.cos(angle);
  var ellipseComponentY = ry * Math.sin(angle);
  var point = {
    x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,
    y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,
    ellipticalArcStartAngle: startAngle,
    ellipticalArcEndAngle: startAngle + sweepAngle,
    ellipticalArcAngle: angle,
    ellipticalArcCenter: center,
    resultantRx: rx,
    resultantRy: ry
  };
  return point;
};
function path2Segments(path) {
  var segments = [];
  var currentPoint = null; // 当前图形
  var nextParams = null; // 下一节点的 path 参数
  var startMovePoint = null; // 开始 M 的点，可能会有多个
  var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引
  var count = path.length;
  for (var i = 0; i < count; i++) {
    var params = path[i];
    nextParams = path[i + 1];
    var command = params[0];
    // 数学定义上的参数，便于后面的计算
    var segment = {
      command: command,
      prePoint: currentPoint,
      params: params,
      startTangent: null,
      endTangent: null,
      currentPoint: null,
      nextPoint: null,
      arcParams: null,
      box: null,
      cubicParams: null
    };
    switch (command) {
      case 'M':
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case 'A':
        var arcParams = getArcParams(currentPoint, params);
        segment.arcParams = arcParams;
        break;
    }
    if (command === 'Z') {
      // 有了 Z 后，当前节点从开始 M 的点开始
      currentPoint = startMovePoint;
      // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
    if (nextParams && nextParams[0] === 'Z') {
      // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment.currentPoint = currentPoint;
    // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment.nextPoint = nextPoint;
    // Add startTangent and endTangent
    var prePoint = segment.prePoint;
    if (['L', 'H', 'V'].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === 'Q') {
      // 二次贝塞尔曲线只有一个控制点
      var cp = [params[1], params[2]];
      // 二次贝塞尔曲线的终点为 currentPoint
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === 'T') {
      var preSegment = segments[i - 1];
      var _cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === 'Q') {
        segment.command = 'Q';
        segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
        segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
      } else {
        // @ts-ignore
        segment.command = 'TL';
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === 'C') {
      // 三次贝塞尔曲线有两个控制点
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === 'S') {
      var _preSegment = segments[i - 1];
      var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
      var _cp3 = [params[1], params[2]];
      if (_preSegment.command === 'C') {
        segment.command = 'C'; // 将 S 命令变换为 C 命令
        segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      } else {
        // @ts-ignore
        segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令
        segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
        segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
      }
    } else if (command === 'A') {
      var _getTangentAtRatio = getTangentAtRatio(segment, 0),
        dx1 = _getTangentAtRatio.x,
        dy1 = _getTangentAtRatio.y;
      var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false),
        dx2 = _getTangentAtRatio2.x,
        dy2 = _getTangentAtRatio2.y;
      segment.startTangent = [dx1, dy1];
      segment.endTangent = [dx2, dy2];
    }
    segments.push(segment);
  }
  return segments;
}
/**
 * Use length instead of ratio
 */
function getTangentAtRatio(segment, ratio, sign) {
  if (sign === void 0) {
    sign = true;
  }
  var _segment$arcParams = segment.arcParams,
    _segment$arcParams$rx = _segment$arcParams.rx,
    rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx,
    _segment$arcParams$ry = _segment$arcParams.ry,
    ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry,
    xRotation = _segment$arcParams.xRotation,
    arcFlag = _segment$arcParams.arcFlag,
    sweepFlag = _segment$arcParams.sweepFlag;
  var p1 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, ratio);
  var p2 = pointOnEllipticalArc({
    x: segment.prePoint[0],
    y: segment.prePoint[1]
  }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
    x: segment.currentPoint[0],
    y: segment.currentPoint[1]
  }, sign ? ratio + 0.005 : ratio - 0.005);
  var xDist = p2.x - p1.x;
  var yDist = p2.y - p1.y;
  var dist = Math.sqrt(xDist * xDist + yDist * yDist);
  return {
    x: -xDist / dist,
    y: -yDist / dist
  };
}
// 向量长度
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
// u.v/|u||v|，计算夹角的余弦值
function vRatio(u, v) {
  // 当存在一个向量的长度为 0 时，夹角也为 0，即夹角的余弦值为 1
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
// 向量角度
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = util.mod(deg2rad(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  // 弧形起点坐标
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  // 弧形终点坐标
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  // 旋转前的起点坐标，且当长半轴和短半轴的长度为 0 时，坐标按 (0, 0) 处理
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  // 椭圆圆心坐标
  var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  // 起始点的单位向量
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  // 终止点的单位向量
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  // 计算起始点和圆心的连线，与 x 轴正方向的夹角
  var theta = vAngle([1, 0], u);
  // 计算圆弧起始点和终止点与椭圆圆心连线的夹角
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx: cx,
    cy: cy,
    // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation: xRotation,
    arcFlag: arcFlag,
    sweepFlag: sweepFlag
  };
}
function commandsToPathString(commands, object, transform) {
  var _object$parsedStyle = object.parsedStyle,
    _object$parsedStyle$d = _object$parsedStyle.defX,
    defX = _object$parsedStyle$d === void 0 ? 0 : _object$parsedStyle$d,
    _object$parsedStyle$d2 = _object$parsedStyle.defY,
    defY = _object$parsedStyle$d2 === void 0 ? 0 : _object$parsedStyle$d2;
  return commands.reduce(function (prev, cur) {
    var path = '';
    if (cur[0] === 'M' || cur[0] === 'L') {
      var p = glMatrix.vec3.fromValues(cur[1] - defX, cur[2] - defY, 0);
      if (transform) {
        glMatrix.vec3.transformMat4(p, p, transform);
      }
      path = "" + cur[0] + p[0] + "," + p[1];
    } else if (cur[0] === 'Z') {
      path = cur[0];
    } else if (cur[0] === 'C') {
      var p1 = glMatrix.vec3.fromValues(cur[1] - defX, cur[2] - defY, 0);
      var p2 = glMatrix.vec3.fromValues(cur[3] - defX, cur[4] - defY, 0);
      var p3 = glMatrix.vec3.fromValues(cur[5] - defX, cur[6] - defY, 0);
      if (transform) {
        glMatrix.vec3.transformMat4(p1, p1, transform);
        glMatrix.vec3.transformMat4(p2, p2, transform);
        glMatrix.vec3.transformMat4(p3, p3, transform);
      }
      path = "" + cur[0] + p1[0] + "," + p1[1] + "," + p2[0] + "," + p2[1] + "," + p3[0] + "," + p3[1];
    } else if (cur[0] === 'A') {
      var c = glMatrix.vec3.fromValues(cur[6] - defX, cur[7] - defY, 0);
      if (transform) {
        glMatrix.vec3.transformMat4(c, c, transform);
      }
      path = "" + cur[0] + cur[1] + "," + cur[2] + "," + cur[3] + "," + cur[4] + "," + cur[5] + "," + c[0] + "," + c[1];
    } else if (cur[0] === 'Q') {
      var _p = glMatrix.vec3.fromValues(cur[1] - defX, cur[2] - defY, 0);
      var _p2 = glMatrix.vec3.fromValues(cur[3] - defX, cur[4] - defY, 0);
      if (transform) {
        glMatrix.vec3.transformMat4(_p, _p, transform);
        glMatrix.vec3.transformMat4(_p2, _p2, transform);
      }
      path = "" + cur[0] + cur[1] + "," + cur[2] + "," + cur[3] + "," + cur[4] + "}";
    }
    return prev += path;
  }, '');
}
function lineToCommands(x1, y1, x2, y2) {
  return [['M', x1, y1], ['L', x2, y2]];
}
function ellipseToCommands(rx, ry, cx, cy) {
  var factor = (-1 + Math.sqrt(2)) / 3 * 4;
  var dx = rx * factor;
  var dy = ry * factor;
  var left = cx - rx;
  var right = cx + rx;
  var top = cy - ry;
  var bottom = cy + ry;
  return [['M', left, cy], ['C', left, cy - dy, cx - dx, top, cx, top], ['C', cx + dx, top, right, cy - dy, right, cy], ['C', right, cy + dy, cx + dx, bottom, cx, bottom], ['C', cx - dx, bottom, left, cy + dy, left, cy], ['Z']];
}
function polygonToCommands(points, closed) {
  var result = points.map(function (point, i) {
    return [i === 0 ? 'M' : 'L', point[0], point[1]];
  });
  if (closed) {
    result.push(['Z']);
  }
  return result;
}
function rectToCommands(width, height, x, y, radius) {
  // @see https://gist.github.com/danielpquinn/dd966af424030d47e476
  if (radius) {
    var tlr = radius[0],
      trr = radius[1],
      brr = radius[2],
      blr = radius[3];
    var signX = width > 0 ? 1 : -1;
    var signY = height > 0 ? 1 : -1;
    // sweep-flag @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths#arcs
    var sweepFlag = signX + signY !== 0 ? 1 : 0;
    return [['M', signX * tlr + x, y], ['L', width - signX * trr + x, y], trr ? ['A', trr, trr, 0, 0, sweepFlag, width + x, signY * trr + y] : null, ['L', width + x, height - signY * brr + y], brr ? ['A', brr, brr, 0, 0, sweepFlag, width + x - signX * brr, height + y] : null, ['L', x + signX * blr, height + y], blr ? ['A', blr, blr, 0, 0, sweepFlag, x, height + y - signY * blr] : null, ['L', x, signY * tlr + y], tlr ? ['A', tlr, tlr, 0, 0, sweepFlag, signX * tlr + x, y] : null, ['Z']].filter(function (command) {
      return command;
    });
  }
  return [['M', x, y], ['L', x + width, y], ['L', x + width, y + height], ['L', x, y + height], ['Z']];
}
/**
 * convert object to path, should account for:
 * * transform & origin
 * * anchor
 * * lineWidth
 */
function convertToPath(object, transform) {
  if (transform === void 0) {
    transform = object.getLocalTransform();
  }
  var commands = [];
  switch (object.nodeName) {
    case exports.Shape.LINE:
      var _object$parsedStyle2 = object.parsedStyle,
        x1 = _object$parsedStyle2.x1,
        y1 = _object$parsedStyle2.y1,
        x2 = _object$parsedStyle2.x2,
        y2 = _object$parsedStyle2.y2;
      commands = lineToCommands(x1, y1, x2, y2);
      break;
    case exports.Shape.CIRCLE:
      {
        var _object$parsedStyle3 = object.parsedStyle,
          r = _object$parsedStyle3.r,
          cx = _object$parsedStyle3.cx,
          cy = _object$parsedStyle3.cy;
        commands = ellipseToCommands(r, r, cx, cy);
        break;
      }
    case exports.Shape.ELLIPSE:
      {
        var _object$parsedStyle4 = object.parsedStyle,
          rx = _object$parsedStyle4.rx,
          ry = _object$parsedStyle4.ry,
          _cx = _object$parsedStyle4.cx,
          _cy = _object$parsedStyle4.cy;
        commands = ellipseToCommands(rx, ry, _cx, _cy);
        break;
      }
    case exports.Shape.POLYLINE:
    case exports.Shape.POLYGON:
      var points = object.parsedStyle.points;
      commands = polygonToCommands(points.points, object.nodeName === exports.Shape.POLYGON);
      break;
    case exports.Shape.RECT:
      var _object$parsedStyle5 = object.parsedStyle,
        width = _object$parsedStyle5.width,
        height = _object$parsedStyle5.height,
        x = _object$parsedStyle5.x,
        y = _object$parsedStyle5.y,
        radius = _object$parsedStyle5.radius;
      var hasRadius = radius && radius.some(function (r) {
        return r !== 0;
      });
      commands = rectToCommands(width, height, x, y, hasRadius && radius.map(function (r) {
        return util.clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
      }));
      break;
    case exports.Shape.PATH:
      var absolutePath = object.parsedStyle.path.absolutePath;
      commands = [].concat(absolutePath);
      break;
  }
  if (commands.length) {
    return commandsToPathString(commands, object, transform);
  }
}
function translatePathToString(absolutePath, defX, defY, startOffsetX, startOffsetY, endOffsetX, endOffsetY) {
  if (startOffsetX === void 0) {
    startOffsetX = 0;
  }
  if (startOffsetY === void 0) {
    startOffsetY = 0;
  }
  if (endOffsetX === void 0) {
    endOffsetX = 0;
  }
  if (endOffsetY === void 0) {
    endOffsetY = 0;
  }
  var newValue = absolutePath.map(function (params, i) {
    var command = params[0];
    var nextSegment = absolutePath[i + 1];
    var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
    var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === 'M' || nextSegment[0] === 'Z')) && endOffsetX !== 0 && endOffsetY !== 0;
    switch (command) {
      case 'M':
        // Use start marker offset
        if (useStartOffset) {
          return "M " + (params[1] - defX + startOffsetX) + "," + (params[2] - defY + startOffsetY) + " L " + (params[1] - defX) + "," + (params[2] - defY);
        } else {
          return "M " + (params[1] - defX) + "," + (params[2] - defY);
        }
      case 'L':
        return "L " + (params[1] - defX + (useEndOffset ? endOffsetX : 0)) + "," + (params[2] - defY + (useEndOffset ? endOffsetY : 0));
      case 'Q':
        return "Q " + (params[1] - defX) + " " + (params[2] - defY) + "," + (params[3] - defX) + " " + (params[4] - defY) + (useEndOffset ? " L " + (params[3] - defX + endOffsetX) + "," + (params[4] - defY + endOffsetY) : '');
      case 'C':
        return "C " + (params[1] - defX) + " " + (params[2] - defY) + "," + (params[3] - defX) + " " + (params[4] - defY) + "," + (params[5] - defX) + " " + (params[6] - defY) + (useEndOffset ? " L " + (params[5] - defX + endOffsetX) + "," + (params[6] - defY + endOffsetY) : '');
      case 'A':
        return "A " + params[1] + " " + params[2] + " " + params[3] + " " + params[4] + " " + params[5] + " " + (params[6] - defX) + " " + (params[7] - defY) + (useEndOffset ? " L " + (params[6] - defX + endOffsetX) + "," + (params[7] - defY + endOffsetY) : '');
      case 'Z':
        return 'Z';
    }
  }).join(' ');
  if (~newValue.indexOf('NaN')) {
    return '';
  }
  return newValue;
}

function isFillOrStrokeAffected(pointerEvents, fill, stroke) {
  // account for pointerEvents
  // @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
  var hasFill = false;
  var hasStroke = false;
  var isFillOtherThanNone = !!fill && !fill.isNone;
  var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
  if (pointerEvents === 'visiblepainted' || pointerEvents === 'painted' || pointerEvents === 'auto') {
    hasFill = isFillOtherThanNone;
    hasStroke = isStrokeOtherThanNone;
  } else if (pointerEvents === 'visiblefill' || pointerEvents === 'fill') {
    hasFill = true;
  } else if (pointerEvents === 'visiblestroke' || pointerEvents === 'stroke') {
    hasStroke = true;
  } else if (pointerEvents === 'visible' || pointerEvents === 'all') {
    // The values of the fill and stroke do not affect event processing.
    hasFill = true;
    hasStroke = true;
  }
  return [hasFill, hasStroke];
}

// @ts-nocheck
// interface HookInterceptor<T, R, AdditionalOptions = UnsetAdditionalOptions> {
//   name?: string;
//   tap?: (tap: FullTap & IfSet<AdditionalOptions>) => void;
//   call?: (...args: any[]) => void;
//   loop?: (...args: any[]) => void;
//   error?: (err: Error) => void;
//   result?: (result: R) => void;
//   done?: () => void;
//   register?: (tap: FullTap & IfSet<AdditionalOptions>) => FullTap & IfSet<AdditionalOptions>;
// }
// type ArgumentNames<T extends any[]> = FixedSizeArray<T['length'], string>;
// export declare class AsyncHook<T, R, AdditionalOptions = UnsetAdditionalOptions> extends Hook<
//   T,
//   R,
//   AdditionalOptions
// > {
//   tapAsync(
//     options: string | (Tap & IfSet<AdditionalOptions>),
//     fn: (...args: Append<AsArray<T>, InnerCallback<Error, R>>) => void,
//   ): void;
//   tapPromise(
//     options: string | (Tap & IfSet<AdditionalOptions>),
//     fn: (...args: AsArray<T>) => Promise<R>,
//   ): void;
// }
var CALL_DELEGATE = function CALL_DELEGATE() {
  this.call = this._createCall('sync');
  return this.call.apply(this, arguments);
};
var CALL_ASYNC_DELEGATE = function CALL_ASYNC_DELEGATE() {
  this.callAsync = this._createCall('async');
  return this.callAsync.apply(this, arguments);
};
var PROMISE_DELEGATE = function PROMISE_DELEGATE() {
  this.promise = this._createCall('promise');
  return this.promise.apply(this, arguments);
};
var Hook = /*#__PURE__*/function () {
  function Hook(args, name) {
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = undefined;
    }
    this.name = void 0;
    this.taps = void 0;
    this.promise = void 0;
    this._promise = void 0;
    this._args = args;
    this.name = name;
    this.taps = [];
    this.interceptors = [];
    this._call = CALL_DELEGATE;
    this.call = CALL_DELEGATE;
    this._callAsync = CALL_ASYNC_DELEGATE;
    this.callAsync = CALL_ASYNC_DELEGATE;
    this._promise = PROMISE_DELEGATE;
    this.promise = PROMISE_DELEGATE;
    this._x = undefined;
    // this.compile = this.compile;
    // this.tap = this.tap;
    // this.tapAsync = this.tapAsync;
    // this.tapPromise = this.tapPromise;
  }
  var _proto = Hook.prototype;
  _proto.compile = function compile(options) {
    throw new Error('Abstract: should be overridden');
  };
  _proto._createCall = function _createCall(type) {
    return this.compile({
      taps: this.taps,
      interceptors: this.interceptors,
      args: this._args,
      type: type
    });
  };
  _proto._tap = function _tap(type, options, fn) {
    if (typeof options === 'string') {
      options = {
        name: options.trim()
      };
    } else if (typeof options !== 'object' || options === null) {
      throw new Error('Invalid tap options');
    }
    if (typeof options.name !== 'string' || options.name === '') {
      throw new Error('Missing name for tap');
    }
    // if (typeof options.context !== "undefined") {
    // 	deprecateContext();
    // }
    options = Object.assign({
      type: type,
      fn: fn
    }, options);
    options = this._runRegisterInterceptors(options);
    this._insert(options);
  };
  _proto.tap = function tap(options, fn) {
    this._tap('sync', options, fn);
  };
  _proto.tapAsync = function tapAsync(options, fn) {
    this._tap('async', options, fn);
  };
  _proto.tapPromise = function tapPromise(options, fn) {
    this._tap('promise', options, fn);
  };
  _proto._runRegisterInterceptors = function _runRegisterInterceptors(options) {
    for (var _iterator = _createForOfIteratorHelperLoose(this.interceptors), _step; !(_step = _iterator()).done;) {
      var interceptor = _step.value;
      if (interceptor.register) {
        var newOptions = interceptor.register(options);
        if (newOptions !== undefined) {
          options = newOptions;
        }
      }
    }
    return options;
  };
  _proto.withOptions = function withOptions(options) {
    var _this = this;
    var mergeOptions = function mergeOptions(opt) {
      return Object.assign({}, options, typeof opt === 'string' ? {
        name: opt
      } : opt);
    };
    return {
      name: this.name,
      tap: function tap(opt, fn) {
        return _this.tap(mergeOptions(opt), fn);
      },
      tapAsync: function tapAsync(opt, fn) {
        return _this.tapAsync(mergeOptions(opt), fn);
      },
      tapPromise: function tapPromise(opt, fn) {
        return _this.tapPromise(mergeOptions(opt), fn);
      },
      // intercept: (interceptor) => this.intercept(interceptor),
      isUsed: function isUsed() {
        return _this.isUsed();
      },
      withOptions: function withOptions(opt) {
        return _this.withOptions(mergeOptions(opt));
      }
    };
  };
  _proto.isUsed = function isUsed() {
    return this.taps.length > 0 || this.interceptors.length > 0;
  }
  // intercept(interceptor: HookInterceptor<T, R, AdditionalOptions>) {
  //   this._resetCompilation();
  //   this.interceptors.push(Object.assign({}, interceptor));
  //   if (interceptor.register) {
  //     for (let i = 0; i < this.taps.length; i++) {
  //       this.taps[i] = interceptor.register(this.taps[i]);
  //     }
  //   }
  // }
  ;
  _proto._resetCompilation = function _resetCompilation() {
    this.call = this._call;
    this.callAsync = this._callAsync;
    this.promise = this._promise;
  };
  _proto._insert = function _insert(item) {
    this._resetCompilation();
    var before;
    if (typeof item.before === 'string') {
      before = new Set([item.before]);
    } else if (Array.isArray(item.before)) {
      before = new Set(item.before);
    }
    var stage = 0;
    if (typeof item.stage === 'number') {
      stage = item.stage;
    }
    var i = this.taps.length;
    while (i > 0) {
      i--;
      var x = this.taps[i];
      this.taps[i + 1] = x;
      var xStage = x.stage || 0;
      if (before) {
        if (before.has(x.name)) {
          before.delete(x.name);
          continue;
        }
        if (before.size > 0) {
          continue;
        }
      }
      if (xStage > stage) {
        continue;
      }
      i++;
      break;
    }
    this.taps[i] = item;
  };
  return Hook;
}();
// Object.setPrototypeOf(Hook.prototype, null);

// @ts-nocheck
var HookCodeFactory = /*#__PURE__*/function () {
  function HookCodeFactory(config) {
    this.config = config;
    this.options = undefined;
    this._args = undefined;
  }
  var _proto = HookCodeFactory.prototype;
  _proto.create = function create(options) {
    this.init(options);
    var fn;
    switch (this.options.type) {
      case 'sync':
        fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
          onError: function onError(err) {
            return "throw " + err + ";\n";
          },
          onResult: function onResult(result) {
            return "return " + result + ";\n";
          },
          resultReturns: true,
          onDone: function onDone() {
            return '';
          },
          rethrowIfPossible: true
        }));
        break;
      case 'async':
        fn = new Function(this.args({
          after: '_callback'
        }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
          onError: function onError(err) {
            return "_callback(" + err + ");\n";
          },
          onResult: function onResult(result) {
            return "_callback(null, " + result + ");\n";
          },
          onDone: function onDone() {
            return '_callback();\n';
          }
        }));
        break;
      case 'promise':
        var errorHelperUsed = false;
        var content = this.contentWithInterceptors({
          onError: function onError(err) {
            errorHelperUsed = true;
            return "_error(" + err + ");\n";
          },
          onResult: function onResult(result) {
            return "_resolve(" + result + ");\n";
          },
          onDone: function onDone() {
            return '_resolve();\n';
          }
        });
        var code = '';
        code += '"use strict";\n';
        code += this.header();
        code += 'return new Promise((function(_resolve, _reject) {\n';
        if (errorHelperUsed) {
          code += 'var _sync = true;\n';
          code += 'function _error(_err) {\n';
          code += 'if(_sync)\n';
          code += '_resolve(Promise.resolve().then((function() { throw _err; })));\n';
          code += 'else\n';
          code += '_reject(_err);\n';
          code += '};\n';
        }
        code += content;
        if (errorHelperUsed) {
          code += '_sync = false;\n';
        }
        code += '}));\n';
        fn = new Function(this.args(), code);
        break;
    }
    this.deinit();
    return fn;
  };
  _proto.setup = function setup(instance, options) {
    instance._x = options.taps.map(function (t) {
      return t.fn;
    });
  }
  /**
   * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
   */;
  _proto.init = function init(options) {
    this.options = options;
    this._args = options.args.slice();
  };
  _proto.deinit = function deinit() {
    this.options = undefined;
    this._args = undefined;
  };
  _proto.contentWithInterceptors = function contentWithInterceptors(options) {
    var _this = this;
    if (this.options.interceptors.length > 0) {
      var onError = options.onError;
      var onResult = options.onResult;
      var onDone = options.onDone;
      var code = '';
      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];
        if (interceptor.call) {
          code += this.getInterceptor(i) + ".call(" + this.args({
            before: interceptor.context ? '_context' : undefined
          }) + ");\n";
        }
      }
      code += this.content(Object.assign(options, {
        onError: onError && function (err) {
          var code = '';
          for (var _i = 0; _i < _this.options.interceptors.length; _i++) {
            var _interceptor = _this.options.interceptors[_i];
            if (_interceptor.error) {
              code += _this.getInterceptor(_i) + ".error(" + err + ");\n";
            }
          }
          code += onError(err);
          return code;
        },
        onResult: onResult && function (result) {
          var code = '';
          for (var _i2 = 0; _i2 < _this.options.interceptors.length; _i2++) {
            var _interceptor2 = _this.options.interceptors[_i2];
            if (_interceptor2.result) {
              code += _this.getInterceptor(_i2) + ".result(" + result + ");\n";
            }
          }
          code += onResult(result);
          return code;
        },
        onDone: onDone && function () {
          var code = '';
          for (var _i3 = 0; _i3 < _this.options.interceptors.length; _i3++) {
            var _interceptor3 = _this.options.interceptors[_i3];
            if (_interceptor3.done) {
              code += _this.getInterceptor(_i3) + ".done();\n";
            }
          }
          code += onDone();
          return code;
        }
      }));
      return code;
    } else {
      return this.content(options);
    }
  };
  _proto.header = function header() {
    var code = '';
    if (this.needContext()) {
      code += 'var _context = {};\n';
    } else {
      code += 'var _context;\n';
    }
    code += 'var _x = this._x;\n';
    if (this.options.interceptors.length > 0) {
      code += 'var _taps = this.taps;\n';
      code += 'var _interceptors = this.interceptors;\n';
    }
    return code;
  };
  _proto.needContext = function needContext() {
    for (var _iterator = _createForOfIteratorHelperLoose(this.options.taps), _step; !(_step = _iterator()).done;) {
      var tap = _step.value;
      if (tap.context) return true;
    }
    return false;
  };
  _proto.callTap = function callTap(tapIndex, _ref) {
    var onError = _ref.onError,
      onResult = _ref.onResult,
      onDone = _ref.onDone,
      rethrowIfPossible = _ref.rethrowIfPossible;
    var code = '';
    var hasTapCached = false;
    for (var i = 0; i < this.options.interceptors.length; i++) {
      var interceptor = this.options.interceptors[i];
      if (interceptor.tap) {
        if (!hasTapCached) {
          code += "var _tap" + tapIndex + " = " + this.getTap(tapIndex) + ";\n";
          hasTapCached = true;
        }
        code += this.getInterceptor(i) + ".tap(" + (interceptor.context ? '_context, ' : '') + "_tap" + tapIndex + ");\n";
      }
    }
    code += "var _fn" + tapIndex + " = " + this.getTapFn(tapIndex) + ";\n";
    var tap = this.options.taps[tapIndex];
    switch (tap.type) {
      case 'sync':
        if (!rethrowIfPossible) {
          code += "var _hasError" + tapIndex + " = false;\n";
          code += 'try {\n';
        }
        if (onResult) {
          code += "var _result" + tapIndex + " = _fn" + tapIndex + "(" + this.args({
            before: tap.context ? '_context' : undefined
          }) + ");\n";
        } else {
          code += "_fn" + tapIndex + "(" + this.args({
            before: tap.context ? '_context' : undefined
          }) + ");\n";
        }
        if (!rethrowIfPossible) {
          code += '} catch(_err) {\n';
          code += "_hasError" + tapIndex + " = true;\n";
          code += onError('_err');
          code += '}\n';
          code += "if(!_hasError" + tapIndex + ") {\n";
        }
        if (onResult) {
          code += onResult("_result" + tapIndex);
        }
        if (onDone) {
          code += onDone();
        }
        if (!rethrowIfPossible) {
          code += '}\n';
        }
        break;
      case 'async':
        var cbCode = '';
        if (onResult) cbCode += "(function(_err" + tapIndex + ", _result" + tapIndex + ") {\n";else cbCode += "(function(_err" + tapIndex + ") {\n";
        cbCode += "if(_err" + tapIndex + ") {\n";
        cbCode += onError("_err" + tapIndex);
        cbCode += '} else {\n';
        if (onResult) {
          cbCode += onResult("_result" + tapIndex);
        }
        if (onDone) {
          cbCode += onDone();
        }
        cbCode += '}\n';
        cbCode += '})';
        code += "_fn" + tapIndex + "(" + this.args({
          before: tap.context ? '_context' : undefined,
          after: cbCode
        }) + ");\n";
        break;
      case 'promise':
        code += "var _hasResult" + tapIndex + " = false;\n";
        code += "var _promise" + tapIndex + " = _fn" + tapIndex + "(" + this.args({
          before: tap.context ? '_context' : undefined
        }) + ");\n";
        code += "if (!_promise" + tapIndex + " || !_promise" + tapIndex + ".then)\n";
        code += "  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise" + tapIndex + " + ')');\n";
        code += "_promise" + tapIndex + ".then((function(_result" + tapIndex + ") {\n";
        code += "_hasResult" + tapIndex + " = true;\n";
        if (onResult) {
          code += onResult("_result" + tapIndex);
        }
        if (onDone) {
          code += onDone();
        }
        code += "}), function(_err" + tapIndex + ") {\n";
        code += "if(_hasResult" + tapIndex + ") throw _err" + tapIndex + ";\n";
        code += onError("_err" + tapIndex);
        code += '});\n';
        break;
    }
    return code;
  };
  _proto.callTapsSeries = function callTapsSeries(_ref2) {
    var _this2 = this;
    var _onError = _ref2.onError,
      onResult = _ref2.onResult,
      resultReturns = _ref2.resultReturns,
      onDone = _ref2.onDone,
      doneReturns = _ref2.doneReturns,
      rethrowIfPossible = _ref2.rethrowIfPossible;
    if (this.options.taps.length === 0) return onDone();
    var firstAsync = this.options.taps.findIndex(function (t) {
      return t.type !== 'sync';
    });
    var somethingReturns = resultReturns || doneReturns;
    var code = '';
    var current = onDone;
    var unrollCounter = 0;
    var _loop = function _loop(j) {
      var i = j;
      var unroll = current !== onDone && (_this2.options.taps[i].type !== 'sync' || unrollCounter++ > 20);
      if (unroll) {
        unrollCounter = 0;
        code += "function _next" + i + "() {\n";
        code += current();
        code += "}\n";
        current = function current() {
          return (somethingReturns ? 'return ' : '') + "_next" + i + "();\n";
        };
      }
      var done = current;
      var doneBreak = function doneBreak(skipDone) {
        if (skipDone) return '';
        return onDone();
      };
      var content = _this2.callTap(i, {
        onError: function onError(error) {
          return _onError(i, error, done, doneBreak);
        },
        onResult: onResult && function (result) {
          return onResult(i, result, done, doneBreak);
        },
        onDone: !onResult && done,
        rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
      });
      current = function current() {
        return content;
      };
    };
    for (var j = this.options.taps.length - 1; j >= 0; j--) {
      _loop(j);
    }
    code += current();
    return code;
  };
  _proto.callTapsLooping = function callTapsLooping(_ref3) {
    var onError = _ref3.onError,
      onDone = _ref3.onDone,
      rethrowIfPossible = _ref3.rethrowIfPossible;
    if (this.options.taps.length === 0) return onDone();
    var syncOnly = this.options.taps.every(function (t) {
      return t.type === 'sync';
    });
    var code = '';
    if (!syncOnly) {
      code += 'var _looper = (function() {\n';
      code += 'var _loopAsync = false;\n';
    }
    code += 'var _loop;\n';
    code += 'do {\n';
    code += '_loop = false;\n';
    for (var i = 0; i < this.options.interceptors.length; i++) {
      var interceptor = this.options.interceptors[i];
      if (interceptor.loop) {
        code += this.getInterceptor(i) + ".loop(" + this.args({
          before: interceptor.context ? '_context' : undefined
        }) + ");\n";
      }
    }
    code += this.callTapsSeries({
      onError: onError,
      onResult: function onResult(i, result, next, doneBreak) {
        var code = '';
        code += "if(" + result + " !== undefined) {\n";
        code += '_loop = true;\n';
        if (!syncOnly) code += 'if(_loopAsync) _looper();\n';
        code += doneBreak(true);
        code += "} else {\n";
        code += next();
        code += "}\n";
        return code;
      },
      onDone: onDone && function () {
        var code = '';
        code += 'if(!_loop) {\n';
        code += onDone();
        code += '}\n';
        return code;
      },
      rethrowIfPossible: rethrowIfPossible && syncOnly
    });
    code += '} while(_loop);\n';
    if (!syncOnly) {
      code += '_loopAsync = true;\n';
      code += '});\n';
      code += '_looper();\n';
    }
    return code;
  };
  _proto.callTapsParallel = function callTapsParallel(_ref4) {
    var _this3 = this;
    var _onError2 = _ref4.onError,
      onResult = _ref4.onResult,
      onDone = _ref4.onDone,
      rethrowIfPossible = _ref4.rethrowIfPossible,
      _ref4$onTap = _ref4.onTap,
      onTap = _ref4$onTap === void 0 ? function (i, run) {
        return run();
      } : _ref4$onTap;
    if (this.options.taps.length <= 1) {
      return this.callTapsSeries({
        onError: _onError2,
        onResult: onResult,
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
    }
    var code = '';
    code += 'do {\n';
    code += "var _counter = " + this.options.taps.length + ";\n";
    if (onDone) {
      code += 'var _done = (function() {\n';
      code += onDone();
      code += '});\n';
    }
    var _loop2 = function _loop2(i) {
      var done = function done() {
        if (onDone) return 'if(--_counter === 0) _done();\n';else return '--_counter;';
      };
      var doneBreak = function doneBreak(skipDone) {
        if (skipDone || !onDone) return '_counter = 0;\n';else return '_counter = 0;\n_done();\n';
      };
      code += 'if(_counter <= 0) break;\n';
      code += onTap(i, function () {
        return _this3.callTap(i, {
          onError: function onError(error) {
            var code = '';
            code += 'if(_counter > 0) {\n';
            code += _onError2(i, error, done, doneBreak);
            code += '}\n';
            return code;
          },
          onResult: onResult && function (result) {
            var code = '';
            code += 'if(_counter > 0) {\n';
            code += onResult(i, result, done, doneBreak);
            code += '}\n';
            return code;
          },
          onDone: !onResult && function () {
            return done();
          },
          rethrowIfPossible: rethrowIfPossible
        });
      }, done, doneBreak);
    };
    for (var i = 0; i < this.options.taps.length; i++) {
      _loop2(i);
    }
    code += '} while(false);\n';
    return code;
  };
  _proto.args = function args(_temp) {
    var _ref5 = _temp === void 0 ? {} : _temp,
      before = _ref5.before,
      after = _ref5.after;
    var allArgs = this._args;
    if (before) allArgs = [before].concat(allArgs);
    if (after) allArgs = allArgs.concat(after);
    if (allArgs.length === 0) {
      return '';
    } else {
      return allArgs.join(', ');
    }
  };
  _proto.getTapFn = function getTapFn(idx) {
    return "_x[" + idx + "]";
  };
  _proto.getTap = function getTap(idx) {
    return "_taps[" + idx + "]";
  };
  _proto.getInterceptor = function getInterceptor(idx) {
    return "_interceptors[" + idx + "]";
  };
  return HookCodeFactory;
}();

var AsyncParallelHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inheritsLoose(AsyncParallelHookCodeFactory, _HookCodeFactory);
  function AsyncParallelHookCodeFactory() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = AsyncParallelHookCodeFactory.prototype;
  _proto.content = function content(_ref) {
    var _onError = _ref.onError,
      onDone = _ref.onDone;
    return this.callTapsParallel({
      onError: function onError(i, err, done, doneBreak) {
        return _onError(err) + doneBreak(true);
      },
      onDone: onDone
    });
  };
  return AsyncParallelHookCodeFactory;
}(HookCodeFactory);
var factory = new AsyncParallelHookCodeFactory();
var COMPILE = function COMPILE(options) {
  factory.setup(this, options);
  return factory.create(options);
};
var AsyncParallelHook = /*#__PURE__*/function (_Hook) {
  _inheritsLoose(AsyncParallelHook, _Hook);
  function AsyncParallelHook(args, name) {
    var _this;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = undefined;
    }
    _this = _Hook.call(this, args, name) || this;
    _this.compile = COMPILE;
    _this._call = undefined;
    _this.call = undefined;
    return _this;
  }
  return AsyncParallelHook;
}(Hook);
// export function AsyncParallelHook(args = [], name = undefined) {
//   const hook = new Hook(args, name);
//   hook.constructor = AsyncParallelHook;
//   hook.compile = COMPILE;
//   hook._call = undefined;
//   hook.call = undefined;
//   return hook;
// }
// AsyncParallelHook.prototype = null;

var AsyncSeriesWaterfallHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inheritsLoose(AsyncSeriesWaterfallHookCodeFactory, _HookCodeFactory);
  function AsyncSeriesWaterfallHookCodeFactory() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = AsyncSeriesWaterfallHookCodeFactory.prototype;
  _proto.content = function content(_ref) {
    var _this = this;
    var _onError = _ref.onError,
      onResult = _ref.onResult,
      onDone = _ref.onDone;
    return this.callTapsSeries({
      onError: function onError(i, err, next, doneBreak) {
        return _onError(err) + doneBreak(true);
      },
      onResult: function onResult(i, result, next) {
        var code = '';
        code += "if(" + result + " !== undefined) {\n";
        code += _this._args[0] + " = " + result + ";\n";
        code += "}\n";
        code += next();
        return code;
      },
      onDone: function onDone() {
        return onResult(_this._args[0]);
      }
    });
  };
  return AsyncSeriesWaterfallHookCodeFactory;
}(HookCodeFactory);
var factory$1 = new AsyncSeriesWaterfallHookCodeFactory();
var COMPILE$1 = function COMPILE(options) {
  factory$1.setup(this, options);
  return factory$1.create(options);
};
// export function AsyncSeriesWaterfallHook(args = [], name = undefined) {
//   if (args.length < 1) throw new Error('Waterfall hooks must have at least one argument');
//   const hook = new Hook(args, name);
//   hook.constructor = AsyncSeriesWaterfallHook;
//   hook.compile = COMPILE;
//   hook._call = undefined;
//   hook.call = undefined;
//   return hook;
// }
// AsyncSeriesWaterfallHook.prototype = null;
var AsyncSeriesWaterfallHook = /*#__PURE__*/function (_Hook) {
  _inheritsLoose(AsyncSeriesWaterfallHook, _Hook);
  function AsyncSeriesWaterfallHook(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = undefined;
    }
    _this2 = _Hook.call(this, args, name) || this;
    _this2.compile = COMPILE$1;
    _this2._call = undefined;
    _this2.call = undefined;
    return _this2;
  }
  return AsyncSeriesWaterfallHook;
}(Hook);

var SyncHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inheritsLoose(SyncHookCodeFactory, _HookCodeFactory);
  function SyncHookCodeFactory() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = SyncHookCodeFactory.prototype;
  _proto.content = function content(_ref) {
    var _onError = _ref.onError,
      onDone = _ref.onDone,
      rethrowIfPossible = _ref.rethrowIfPossible;
    return this.callTapsSeries({
      onError: function onError(i, err) {
        return _onError(err);
      },
      onDone: onDone,
      rethrowIfPossible: rethrowIfPossible
    });
  };
  return SyncHookCodeFactory;
}(HookCodeFactory);
var factory$2 = new SyncHookCodeFactory();
var TAP_ASYNC = function TAP_ASYNC() {
  throw new Error('tapAsync is not supported on a SyncHook');
};
var TAP_PROMISE = function TAP_PROMISE() {
  throw new Error('tapPromise is not supported on a SyncHook');
};
var COMPILE$2 = function COMPILE(options) {
  factory$2.setup(this, options);
  return factory$2.create(options);
};
var SyncHook = /*#__PURE__*/function (_Hook) {
  _inheritsLoose(SyncHook, _Hook);
  function SyncHook(args, name) {
    var _this;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = undefined;
    }
    _this = _Hook.call(this, args, name) || this;
    _this.tapAsync = TAP_ASYNC;
    _this.tapPromise = TAP_PROMISE;
    _this.compile = COMPILE$2;
    return _this;
  }
  return SyncHook;
}(Hook);
// export function SyncHook(args = [], name = undefined) {
//   const hook = new Hook(args, name);
//   hook.constructor = SyncHook;
//   hook.tapAsync = TAP_ASYNC;
//   hook.tapPromise = TAP_PROMISE;
//   hook.compile = COMPILE;
//   return hook;
// }
// SyncHook.prototype = null;

var SyncWaterfallHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
  _inheritsLoose(SyncWaterfallHookCodeFactory, _HookCodeFactory);
  function SyncWaterfallHookCodeFactory() {
    return _HookCodeFactory.apply(this, arguments) || this;
  }
  var _proto = SyncWaterfallHookCodeFactory.prototype;
  _proto.content = function content(_ref) {
    var _this = this;
    var _onError = _ref.onError,
      onResult = _ref.onResult,
      resultReturns = _ref.resultReturns,
      rethrowIfPossible = _ref.rethrowIfPossible;
    return this.callTapsSeries({
      onError: function onError(i, err) {
        return _onError(err);
      },
      onResult: function onResult(i, result, next) {
        var code = '';
        code += "if(" + result + " !== undefined) {\n";
        code += _this._args[0] + " = " + result + ";\n";
        code += "}\n";
        code += next();
        return code;
      },
      onDone: function onDone() {
        return onResult(_this._args[0]);
      },
      doneReturns: resultReturns,
      rethrowIfPossible: rethrowIfPossible
    });
  };
  return SyncWaterfallHookCodeFactory;
}(HookCodeFactory);
var factory$3 = new SyncWaterfallHookCodeFactory();
var TAP_ASYNC$1 = function TAP_ASYNC() {
  throw new Error('tapAsync is not supported on a SyncWaterfallHook');
};
var TAP_PROMISE$1 = function TAP_PROMISE() {
  throw new Error('tapPromise is not supported on a SyncWaterfallHook');
};
var COMPILE$3 = function COMPILE(options) {
  factory$3.setup(this, options);
  return factory$3.create(options);
};
var SyncWaterfallHook = /*#__PURE__*/function (_SyncHook) {
  _inheritsLoose(SyncWaterfallHook, _SyncHook);
  function SyncWaterfallHook(args, name) {
    var _this2;
    if (args === void 0) {
      args = [];
    }
    if (name === void 0) {
      name = undefined;
    }
    _this2 = _SyncHook.call(this, args, name) || this;
    _this2.tapAsync = TAP_ASYNC$1;
    _this2.tapPromise = TAP_PROMISE$1;
    _this2.compile = COMPILE$3;
    return _this2;
  }
  return SyncWaterfallHook;
}(SyncHook);
// export function SyncWaterfallHook(args = [], name = undefined) {
//   if (args.length < 1) throw new Error('Waterfall hooks must have at least one argument');
//   const hook = new Hook(args, name);
//   hook.constructor = SyncWaterfallHook;
//   hook.tapAsync = TAP_ASYNC;
//   hook.tapPromise = TAP_PROMISE;
//   hook.compile = COMPILE;
//   return hook;
// }
// SyncWaterfallHook.prototype = null;

var genericFontFamilies = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'];
var stringRegExp = /([\"\'])[^\'\"]+\1/;
function toFontString(attributes) {
  var fontSize = attributes.fontSize,
    fontFamily = attributes.fontFamily,
    fontStyle = attributes.fontStyle,
    fontVariant = attributes.fontVariant,
    fontWeight = attributes.fontWeight;
  // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
  // const fontSizeString: string = isNumber(fontSize) ? `${fontSize}px` : fontSize.toString();
  var fontSizeString = util.isNumber(fontSize) && fontSize + "px" || '16px';
  // Clean-up fontFamily property by quoting each font name
  // this will support font names with spaces
  // @ts-ignore
  var fontFamilies = util.isString(fontFamily) ? fontFamily.split(',') : [fontFamily];
  for (var i = fontFamilies.length - 1; i >= 0; i--) {
    // Trim any extra white-space
    var _fontFamily = fontFamilies[i].trim();
    // Check if font already contains strings
    if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
      _fontFamily = "\"" + _fontFamily + "\"";
    }
    fontFamilies[i] = _fontFamily;
  }
  return fontStyle + " " + fontVariant + " " + fontWeight + " " + fontSizeString + " " + fontFamilies.join(',');
}

/**
 * Thanks for following contributor of codes
 * https://gist.github.com/1866474
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 * https://github.com/Financial-Times/polyfill-library/blob/master/polyfills/requestAnimationFrame/polyfill.js
 **/
var uId = 1;
var uniqueId = function uniqueId() {
  return uId++;
};
// We use `self` instead of `window` for `WebWorker` support.
var root = typeof self === 'object' && self.self == self ? self :
// @ts-ignore
typeof global === 'object' && global.global == global ?
// @ts-ignore
global : {};
var nowOffset = Date.now();
// use performance api if exist, otherwise use Date.now.
// Date.now polyfill required.
var pnow = function pnow() {
  if (root.performance && typeof root.performance.now === 'function') {
    return root.performance.now();
  }
  // fallback
  return Date.now() - nowOffset;
};
var reservedCBs = {};
var lastTime = Date.now();
var polyfillRaf = function polyfillRaf(callback) {
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  var currentTime = Date.now();
  var gap = currentTime - lastTime;
  var delay = gap > 16 ? 0 : 16 - gap;
  var id = uniqueId();
  reservedCBs[id] = callback;
  // keys(reservedCBs).length > 1 의미는 이미 setTimeout 이 걸려있는 경우.
  // 함께 callback 이 실행될 수 있게 reservedCBs 에만 추가해주고 return
  if (Object.keys(reservedCBs).length > 1) return id;
  setTimeout(function () {
    lastTime = currentTime;
    var copied = reservedCBs;
    reservedCBs = {};
    Object.keys(copied).forEach(function (key) {
      return copied[key](pnow());
    });
  }, delay);
  return id;
};
var polyfillCaf = function polyfillCaf(id) {
  delete reservedCBs[id];
};
var vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o'];
var getRequestAnimationFrame = function getRequestAnimationFrame(vp) {
  if (typeof vp !== 'string') return polyfillRaf;
  if (vp === '') return root['requestAnimationFrame'];
  return root[vp + 'RequestAnimationFrame'];
};
var getCancelAnimationFrame = function getCancelAnimationFrame(vp) {
  if (typeof vp !== 'string') return polyfillCaf;
  if (vp === '') return root['cancelAnimationFrame'];
  return root[vp + 'CancelAnimationFrame'] || root[vp + 'CancelRequestAnimationFrame'];
};
var find = function find(arr, predicate) {
  var i = 0;
  while (arr[i] !== void 0) {
    if (predicate(arr[i])) return arr[i];
    i = i + 1;
  }
};
var vp = find(vendorPrefixes, function (vp) {
  return !!getRequestAnimationFrame(vp);
});
var raf = getRequestAnimationFrame(vp);
var caf = getCancelAnimationFrame(vp);
root.requestAnimationFrame = raf;
root.cancelAnimationFrame = caf;

var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function spaceColorStops(colorStops) {
  var _colorStops$length;
  var length = colorStops.length;
  colorStops[length - 1].length = (_colorStops$length = colorStops[length - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
    type: '%',
    value: '100'
  };
  if (length > 1) {
    var _colorStops$0$length;
    colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
      type: '%',
      value: '0'
    };
  }
  var previousIndex = 0;
  var previousOffset = Number(colorStops[0].length.value);
  for (var i = 1; i < length; i++) {
    var _colorStops$i$length;
    // support '%' & 'px'
    var offset = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
    if (!util.isNil(offset) && !util.isNil(previousOffset)) {
      for (var j = 1; j < i - previousIndex; j++) {
        colorStops[previousIndex + j].length = {
          type: '%',
          value: "" + (previousOffset + (Number(offset) - previousOffset) * j / (i - previousIndex))
        };
      }
      previousIndex = i;
      previousOffset = Number(offset);
    }
  }
}
// The position of the gradient line's starting point.
// different from CSS side(to top) @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#values
var SideOrCornerToDegMap = {
  left: 270 - 90,
  top: 0 - 90,
  bottom: 180 - 90,
  right: 90 - 90,
  'left top': 315 - 90,
  'top left': 315 - 90,
  'left bottom': 225 - 90,
  'bottom left': 225 - 90,
  'right top': 45 - 90,
  'top right': 45 - 90,
  'right bottom': 135 - 90,
  'bottom right': 135 - 90
};
var angleToDeg = memoize(function (orientation) {
  var angle;
  if (orientation.type === 'angular') {
    angle = Number(orientation.value);
  } else {
    angle = SideOrCornerToDegMap[orientation.value] || 0;
  }
  return getOrCreateUnitValue(angle, 'deg');
});
var positonToCSSUnitValue = memoize(function (position) {
  var cx = 50;
  var cy = 50;
  var unitX = '%';
  var unitY = '%';
  if ((position === null || position === void 0 ? void 0 : position.type) === 'position') {
    var _position$value = position.value,
      x = _position$value.x,
      y = _position$value.y;
    if ((x === null || x === void 0 ? void 0 : x.type) === 'position-keyword') {
      if (x.value === 'left') {
        cx = 0;
      } else if (x.value === 'center') {
        cx = 50;
      } else if (x.value === 'right') {
        cx = 100;
      } else if (x.value === 'top') {
        cy = 0;
      } else if (x.value === 'bottom') {
        cy = 100;
      }
    }
    if ((y === null || y === void 0 ? void 0 : y.type) === 'position-keyword') {
      if (y.value === 'left') {
        cx = 0;
      } else if (y.value === 'center') {
        cy = 50;
      } else if (y.value === 'right') {
        cx = 100;
      } else if (y.value === 'top') {
        cy = 0;
      } else if (y.value === 'bottom') {
        cy = 100;
      }
    }
    if ((x === null || x === void 0 ? void 0 : x.type) === 'px' || (x === null || x === void 0 ? void 0 : x.type) === '%' || (x === null || x === void 0 ? void 0 : x.type) === 'em') {
      unitX = x === null || x === void 0 ? void 0 : x.type;
      cx = Number(x.value);
    }
    if ((y === null || y === void 0 ? void 0 : y.type) === 'px' || (y === null || y === void 0 ? void 0 : y.type) === '%' || (y === null || y === void 0 ? void 0 : y.type) === 'em') {
      unitY = y === null || y === void 0 ? void 0 : y.type;
      cy = Number(y.value);
    }
  }
  return {
    cx: getOrCreateUnitValue(cx, unitX),
    cy: getOrCreateUnitValue(cy, unitY)
  };
});
var parseGradient$1 = memoize(function (colorStr) {
  if (colorStr.indexOf('linear') > -1 || colorStr.indexOf('radial') > -1) {
    var ast = parseGradient(colorStr);
    return ast.map(function (_ref) {
      var type = _ref.type,
        orientation = _ref.orientation,
        colorStops = _ref.colorStops;
      spaceColorStops(colorStops);
      var steps = colorStops.map(function (colorStop) {
        // TODO: only support % for now, should calc percentage of axis length when using px/em
        return {
          offset: getOrCreateUnitValue(Number(colorStop.length.value), '%'),
          color: colorStopToString(colorStop)
        };
      });
      if (type === 'linear-gradient') {
        return new CSSGradientValue(exports.GradientType.LinearGradient, {
          angle: orientation ? angleToDeg(orientation) : Odeg,
          steps: steps
        });
      } else if (type === 'radial-gradient') {
        if (!orientation) {
          orientation = [{
            type: 'shape',
            value: 'circle'
          }];
        }
        if (orientation[0].type === 'shape' && orientation[0].value === 'circle') {
          var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at),
            cx = _positonToCSSUnitValu.cx,
            cy = _positonToCSSUnitValu.cy;
          var size;
          if (orientation[0].style) {
            var _orientation$0$style = orientation[0].style,
              _type = _orientation$0$style.type,
              value = _orientation$0$style.value;
            if (_type === 'extent-keyword') {
              size = getOrCreateKeyword(value);
            } else {
              size = getOrCreateUnitValue(value, _type);
            }
          }
          return new CSSGradientValue(exports.GradientType.RadialGradient, {
            cx: cx,
            cy: cy,
            size: size,
            steps: steps
          });
        }
        // TODO: support ellipse shape
        // TODO: repeating-linear-gradient & repeating-radial-gradient
        // } else if (type === 'repeating-linear-gradient') {
        // } else if (type === 'repeating-radial-gradient') {
      }
    });
  }
  // legacy format, should be deprecated later
  var type = colorStr[0];
  if (colorStr[1] === '(' || colorStr[2] === '(') {
    if (type === 'l') {
      var arr = regexLG.exec(colorStr);
      if (arr) {
        var _arr$2$match;
        var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function (stop) {
          return stop.split(':');
        })) || [];
        return [new CSSGradientValue(exports.GradientType.LinearGradient, {
          angle: getOrCreateUnitValue(parseFloat(arr[1]), 'deg'),
          steps: steps.map(function (_ref2) {
            var offset = _ref2[0],
              color = _ref2[1];
            return {
              offset: getOrCreateUnitValue(Number(offset) * 100, '%'),
              color: color
            };
          })
        })];
      }
    } else if (type === 'r') {
      var parsedRadialGradient = parseRadialGradient(colorStr);
      if (parsedRadialGradient) {
        if (util.isString(parsedRadialGradient)) {
          colorStr = parsedRadialGradient;
        } else {
          return [new CSSGradientValue(exports.GradientType.RadialGradient, parsedRadialGradient)];
        }
      }
    } else if (type === 'p') {
      return parsePattern(colorStr);
    }
  }
});
function parseRadialGradient(gradientStr) {
  var arr = regexRG.exec(gradientStr);
  if (arr) {
    var _arr$4$match;
    var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function (stop) {
      return stop.split(':');
    })) || [];
    return {
      cx: getOrCreateUnitValue(50, '%'),
      cy: getOrCreateUnitValue(50, '%'),
      steps: steps.map(function (_ref3) {
        var offset = _ref3[0],
          color = _ref3[1];
        return {
          offset: getOrCreateUnitValue(Number(offset) * 100, '%'),
          color: color
        };
      })
    };
  }
  return null;
}
function parsePattern(patternStr) {
  var arr = regexPR.exec(patternStr);
  if (arr) {
    var repetition = arr[1];
    var src = arr[2];
    switch (repetition) {
      case 'a':
        repetition = 'repeat';
        break;
      case 'x':
        repetition = 'repeat-x';
        break;
      case 'y':
        repetition = 'repeat-y';
        break;
      case 'n':
        repetition = 'no-repeat';
        break;
      default:
        repetition = 'no-repeat';
    }
    return {
      image: src,
      // @ts-ignore
      repetition: repetition
    };
  }
  return null;
}

function isCSSGradientValue(object) {
  return !!object.type && !!object.value;
}
function isPattern(object) {
  return object && !!object.image;
}
function isCSSRGB(object) {
  return object && !util.isNil(object.r) && !util.isNil(object.g) && !util.isNil(object.b);
}
/**
 * @see https://github.com/WebKit/WebKit/blob/main/Source/WebCore/css/parser/CSSParser.cpp#L97
 */
var parseColor = memoize(function (colorStr) {
  if (isPattern(colorStr)) {
    return _extends({
      repetition: 'repeat'
    }, colorStr);
  }
  if (util.isNil(colorStr)) {
    colorStr = '';
  }
  if (colorStr === 'transparent') {
    // transparent black
    return transparentColor;
  } else if (colorStr === 'currentColor') {
    // @see https://github.com/adobe-webplatform/Snap.svg/issues/526
    colorStr = 'black';
  }
  // support CSS gradient syntax
  var g = parseGradient$1(colorStr);
  if (g) {
    return g;
  }
  // constants
  var color = d3.color(colorStr);
  var rgba = [0, 0, 0, 0];
  if (color !== null) {
    rgba[0] = color.r || 0;
    rgba[1] = color.g || 0;
    rgba[2] = color.b || 0;
    rgba[3] = color.opacity;
  }
  // return new CSSRGB(...rgba);
  return getOrCreateRGBA.apply(void 0, rgba);
});
function mergeColors(left, right) {
  // only support constant value, exclude gradient & pattern
  if (!isCSSRGB(left) || !isCSSRGB(right)) {
    return;
  }
  return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function (color) {
    var rgba = color.slice();
    if (rgba[3]) {
      for (var i = 0; i < 3; i++) {
        rgba[i] = Math.round(util.clamp(rgba[i], 0, 255));
      }
    }
    rgba[3] = util.clamp(rgba[3], 0, 1);
    return "rgba(" + rgba.join(',') + ")";
  }];
}

/**
 * Axis-Aligned Bounding Box
 * 为了便于后续 Frustum Culling，通过查找表定义 p-vertex 和 n-vertex
 * @see https://github.com/antvis/GWebGPUEngine/issues/3
 */
var AABB = /*#__PURE__*/function () {
  AABB.isEmpty = function isEmpty(aabb) {
    return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
  };
  // center: vec3 = vec3.create();
  // halfExtents: vec3 = vec3.create();
  // min: vec3 = vec3.create();
  // max: vec3 = vec3.create();
  function AABB(center, halfExtents) {
    if (center === void 0) {
      center = [0, 0, 0];
    }
    if (halfExtents === void 0) {
      halfExtents = [0, 0, 0];
    }
    this.center = [0, 0, 0];
    this.halfExtents = [0, 0, 0];
    this.min = [0, 0, 0];
    this.max = [0, 0, 0];
    this.update(center, halfExtents);
  }
  var _proto = AABB.prototype;
  _proto.update = function update(center, halfExtents) {
    copyVec3(this.center, center);
    copyVec3(this.halfExtents, halfExtents);
    subVec3(this.min, this.center, this.halfExtents);
    addVec3(this.max, this.center, this.halfExtents);
    // vec3.copy(this.center, center);
    // vec3.copy(this.halfExtents, halfExtents);
    // vec3.sub(this.min, this.center, this.halfExtents);
    // vec3.add(this.max, this.center, this.halfExtents);
  };
  _proto.setMinMax = function setMinMax(min, max) {
    // vec3.add(this.center, max, min);
    // vec3.scale(this.center, this.center, 0.5);
    // vec3.sub(this.halfExtents, max, min);
    // vec3.scale(this.halfExtents, this.halfExtents, 0.5);
    // vec3.copy(this.min, min);
    // vec3.copy(this.max, max);
    addVec3(this.center, max, min);
    scaleVec3(this.center, this.center, 0.5);
    subVec3(this.halfExtents, max, min);
    scaleVec3(this.halfExtents, this.halfExtents, 0.5);
    copyVec3(this.min, min);
    copyVec3(this.max, max);
  };
  _proto.getMin = function getMin() {
    return this.min;
  };
  _proto.getMax = function getMax() {
    return this.max;
  };
  _proto.add = function add(aabb) {
    if (AABB.isEmpty(aabb)) {
      return;
    }
    if (AABB.isEmpty(this)) {
      this.setMinMax(aabb.getMin(), aabb.getMax());
      return;
    }
    var tc = this.center;
    var tcx = tc[0];
    var tcy = tc[1];
    var tcz = tc[2];
    var th = this.halfExtents;
    var thx = th[0];
    var thy = th[1];
    var thz = th[2];
    var tminx = tcx - thx;
    var tmaxx = tcx + thx;
    var tminy = tcy - thy;
    var tmaxy = tcy + thy;
    var tminz = tcz - thz;
    var tmaxz = tcz + thz;
    var oc = aabb.center;
    var ocx = oc[0];
    var ocy = oc[1];
    var ocz = oc[2];
    var oh = aabb.halfExtents;
    var ohx = oh[0];
    var ohy = oh[1];
    var ohz = oh[2];
    var ominx = ocx - ohx;
    var omaxx = ocx + ohx;
    var ominy = ocy - ohy;
    var omaxy = ocy + ohy;
    var ominz = ocz - ohz;
    var omaxz = ocz + ohz;
    if (ominx < tminx) {
      tminx = ominx;
    }
    if (omaxx > tmaxx) {
      tmaxx = omaxx;
    }
    if (ominy < tminy) {
      tminy = ominy;
    }
    if (omaxy > tmaxy) {
      tmaxy = omaxy;
    }
    if (ominz < tminz) {
      tminz = ominz;
    }
    if (omaxz > tmaxz) {
      tmaxz = omaxz;
    }
    tc[0] = (tminx + tmaxx) * 0.5;
    tc[1] = (tminy + tmaxy) * 0.5;
    tc[2] = (tminz + tmaxz) * 0.5;
    th[0] = (tmaxx - tminx) * 0.5;
    th[1] = (tmaxy - tminy) * 0.5;
    th[2] = (tmaxz - tminz) * 0.5;
    this.min[0] = tminx;
    this.min[1] = tminy;
    this.min[2] = tminz;
    this.max[0] = tmaxx;
    this.max[1] = tmaxy;
    this.max[2] = tmaxz;
  };
  _proto.setFromTransformedAABB = function setFromTransformedAABB(aabb, m) {
    var bc = this.center;
    var br = this.halfExtents;
    var ac = aabb.center;
    var ar = aabb.halfExtents;
    var mx0 = m[0];
    var mx1 = m[4];
    var mx2 = m[8];
    var my0 = m[1];
    var my1 = m[5];
    var my2 = m[9];
    var mz0 = m[2];
    var mz1 = m[6];
    var mz2 = m[10];
    var mx0a = Math.abs(mx0);
    var mx1a = Math.abs(mx1);
    var mx2a = Math.abs(mx2);
    var my0a = Math.abs(my0);
    var my1a = Math.abs(my1);
    var my2a = Math.abs(my2);
    var mz0a = Math.abs(mz0);
    var mz1a = Math.abs(mz1);
    var mz2a = Math.abs(mz2);
    bc[0] = m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
    bc[1] = m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
    bc[2] = m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
    // vec3.set(
    //   bc,
    //   m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2],
    //   m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2],
    //   m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2],
    // );
    br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
    br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
    br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
    // vec3.set(
    //   br,
    //   mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2],
    //   my0a * ar[0] + my1a * ar[1] + my2a * ar[2],
    //   mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2],
    // );
    // this.min = vec3.sub(this.min, bc, br);
    // this.max = vec3.add(this.max, bc, br);
    subVec3(this.min, bc, br);
    addVec3(this.max, bc, br);
  };
  _proto.intersects = function intersects(aabb) {
    var aMax = this.getMax();
    var aMin = this.getMin();
    var bMax = aabb.getMax();
    var bMin = aabb.getMin();
    return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
  };
  _proto.intersection = function intersection(aabb) {
    if (!this.intersects(aabb)) {
      return null;
    }
    var intersection = new AABB();
    // const min = vec3.max(vec3.create(), this.getMin(), aabb.getMin());
    // const max = vec3.min(vec3.create(), this.getMax(), aabb.getMax());
    var min = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
    var max = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
    intersection.setMinMax(min, max);
    return intersection;
  }
  // containsPoint(point: vec3) {
  //   const min = this.getMin();
  //   const max = this.getMax();
  //   return !(
  //     point[0] < min[0] ||
  //     point[0] > max[0] ||
  //     point[1] < min[1] ||
  //     point[1] > max[1] ||
  //     point[2] < min[2] ||
  //     point[2] > max[2]
  //   );
  // }
  /**
   * get n-vertex
   * @param plane plane of CullingVolume
   */;
  _proto.getNegativeFarPoint = function getNegativeFarPoint(plane) {
    if (plane.pnVertexFlag === 0x111) {
      return copyVec3([0, 0, 0], this.min);
      // return vec3.copy(vec3.create(), this.min);
    } else if (plane.pnVertexFlag === 0x110) {
      return [this.min[0], this.min[1], this.max[2]];
      // return vec3.fromValues(this.min[0], this.min[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x101) {
      return [this.min[0], this.max[1], this.min[2]];
      // return vec3.fromValues(this.min[0], this.max[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x100) {
      return [this.min[0], this.max[1], this.max[2]];
      // return vec3.fromValues(this.min[0], this.max[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x011) {
      return [this.max[0], this.min[1], this.min[2]];
      // return vec3.fromValues(this.max[0], this.min[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x010) {
      return [this.max[0], this.min[1], this.max[2]];
      // return vec3.fromValues(this.max[0], this.min[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x001) {
      return [this.max[0], this.max[1], this.min[2]];
      // return vec3.fromValues(this.max[0], this.max[1], this.min[2]);
    } else {
      return [this.max[0], this.max[1], this.max[2]];
      // return vec3.fromValues(this.max[0], this.max[1], this.max[2]);
    }
  }
  /**
   * get p-vertex
   * @param plane plane of CullingVolume
   */;
  _proto.getPositiveFarPoint = function getPositiveFarPoint(plane) {
    if (plane.pnVertexFlag === 0x111) {
      return copyVec3([0, 0, 0], this.max);
      // return vec3.copy(vec3.create(), this.max);
    } else if (plane.pnVertexFlag === 0x110) {
      return [this.max[0], this.max[1], this.min[2]];
      // return vec3.fromValues(this.max[0], this.max[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x101) {
      return [this.max[0], this.min[1], this.max[2]];
      // return vec3.fromValues(this.max[0], this.min[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x100) {
      return [this.max[0], this.min[1], this.min[2]];
      // return vec3.fromValues(this.max[0], this.min[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x011) {
      return [this.min[0], this.max[1], this.max[2]];
      // return vec3.fromValues(this.min[0], this.max[1], this.max[2]);
    } else if (plane.pnVertexFlag === 0x010) {
      return [this.min[0], this.max[1], this.min[2]];
      // return vec3.fromValues(this.min[0], this.max[1], this.min[2]);
    } else if (plane.pnVertexFlag === 0x001) {
      return [this.min[0], this.min[1], this.max[2]];
      // return vec3.fromValues(this.min[0], this.min[1], this.max[2]);
    } else {
      return [this.min[0], this.min[1], this.min[2]];
      // return vec3.fromValues(this.min[0], this.min[1], this.min[2]);
    }
  };
  return AABB;
}();

var Plane = /*#__PURE__*/function () {
  /**
   * lookup table for p-vertex & n-vertex when doing frustum culling
   */

  function Plane(distance, normal) {
    this.distance = void 0;
    this.normal = void 0;
    this.pnVertexFlag = void 0;
    this.distance = distance || 0;
    this.normal = normal || glMatrix.vec3.fromValues(0, 1, 0);
    this.updatePNVertexFlag();
  }
  var _proto = Plane.prototype;
  _proto.updatePNVertexFlag = function updatePNVertexFlag() {
    this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
  };
  _proto.distanceToPoint = function distanceToPoint(point) {
    return glMatrix.vec3.dot(point, this.normal) - this.distance;
  };
  _proto.normalize = function normalize() {
    var invLen = 1 / glMatrix.vec3.len(this.normal);
    glMatrix.vec3.scale(this.normal, this.normal, invLen);
    this.distance *= invLen;
  };
  _proto.intersectsLine = function intersectsLine(start, end, point) {
    var d0 = this.distanceToPoint(start);
    var d1 = this.distanceToPoint(end);
    var t = d0 / (d0 - d1);
    var intersects = t >= 0 && t <= 1;
    if (intersects && point) {
      glMatrix.vec3.lerp(point, start, end, t);
    }
    return intersects;
  };
  return Plane;
}();

(function (Mask) {
  Mask[Mask["OUTSIDE"] = 4294967295] = "OUTSIDE";
  Mask[Mask["INSIDE"] = 0] = "INSIDE";
  Mask[Mask["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
})(exports.Mask || (exports.Mask = {}));
var Frustum = /*#__PURE__*/function () {
  function Frustum(planes) {
    this.planes = [];
    if (planes) {
      this.planes = planes;
    } else {
      for (var i = 0; i < 6; i++) {
        this.planes.push(new Plane());
      }
    }
  }
  /**
   * extract 6 planes from projectionMatrix
   * @see http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf
   */
  var _proto = Frustum.prototype;
  _proto.extractFromVPMatrix = function extractFromVPMatrix(projectionMatrix) {
    // @ts-ignore
    var m0 = projectionMatrix[0],
      m1 = projectionMatrix[1],
      m2 = projectionMatrix[2],
      m3 = projectionMatrix[3],
      m4 = projectionMatrix[4],
      m5 = projectionMatrix[5],
      m6 = projectionMatrix[6],
      m7 = projectionMatrix[7],
      m8 = projectionMatrix[8],
      m9 = projectionMatrix[9],
      m10 = projectionMatrix[10],
      m11 = projectionMatrix[11],
      m12 = projectionMatrix[12],
      m13 = projectionMatrix[13],
      m14 = projectionMatrix[14],
      m15 = projectionMatrix[15];
    // right
    glMatrix.vec3.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
    this.planes[0].distance = m15 - m12;
    // left
    glMatrix.vec3.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
    this.planes[1].distance = m15 + m12;
    // bottom
    glMatrix.vec3.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
    this.planes[2].distance = m15 + m13;
    // top
    glMatrix.vec3.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
    this.planes[3].distance = m15 - m13;
    // far
    glMatrix.vec3.set(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
    this.planes[4].distance = m15 - m14;
    // near
    glMatrix.vec3.set(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
    this.planes[5].distance = m15 + m14;
    this.planes.forEach(function (plane) {
      plane.normalize();
      plane.updatePNVertexFlag();
    });
  };
  return Frustum;
}();

var Point = /*#__PURE__*/function () {
  function Point(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = 0;
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  var _proto = Point.prototype;
  _proto.clone = function clone() {
    return new Point(this.x, this.y);
  };
  _proto.copyFrom = function copyFrom(p) {
    this.x = p.x;
    this.y = p.y;
  };
  return Point;
}();

var Rectangle = /*#__PURE__*/function () {
  function Rectangle(x, y, width, height) {
    this.x = void 0;
    this.y = void 0;
    this.width = void 0;
    this.height = void 0;
    this.left = void 0;
    this.right = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.left = x;
    this.right = x + width;
    this.top = y;
    this.bottom = y + height;
  }
  var _proto = Rectangle.prototype;
  _proto.toJSON = function toJSON() {};
  return Rectangle;
}();

function parseDimension(unitRegExp, string) {
  if (util.isNil(string)) {
    return getOrCreateUnitValue(0, 'px');
  }
  string = ("" + string).trim().toLowerCase();
  if (isFinite(Number(string))) {
    if ('px'.search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), 'px');
    } else if ('deg'.search(unitRegExp) >= 0) {
      return getOrCreateUnitValue(Number(string), 'deg');
    }
  }
  var matchedUnits = [];
  string = string.replace(unitRegExp, function (match) {
    matchedUnits.push(match);
    return 'U' + match;
  });
  var taggedUnitRegExp = 'U(' + unitRegExp.source + ')';
  return matchedUnits.map(function (unit) {
    return getOrCreateUnitValue(Number(string.replace(new RegExp('U' + unit, 'g'), '').replace(new RegExp(taggedUnitRegExp, 'g'), '*0')), unit);
  })[0];
}
/**
 * <length>
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length
 * length with only absolute unit, eg. 1px
 */
var parseLength = memoize(function (css) {
  return parseDimension(new RegExp('px', 'g'), css);
});
/**
 * <percentage>
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage
 */
var parserPercentage = memoize(function (css) {
  return parseDimension(new RegExp('%', 'g'), css);
});
/**
 * length with absolute or relative unit,
 * eg. 1px, 0.7em, 50%, calc(100% - 200px);
 *
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length-percentage
 */
// export const parseLengthOrPercentage = memoize((css: string): CSSUnitValue => {
//   if (isNumber(css) || isFinite(Number(css))) {
//     return getOrCreateUnitValue(Number(css), 'px');
//   }
//   return parseDimension(new RegExp('px|%|em|rem', 'g'), css) as CSSUnitValue;
// });
var parseLengthOrPercentage = function parseLengthOrPercentage(css) {
  if (util.isNumber(css) || isFinite(Number(css))) {
    return getOrCreateUnitValue(Number(css), 'px');
    // return Number(css);
  }

  return parseDimension(new RegExp('px|%|em|rem', 'g'), css);
};
var parseAngle = memoize(function (css) {
  return parseDimension(new RegExp('deg|rad|grad|turn', 'g'), css);
});
/**
 * merge CSSUnitValue
 *
 * @example
 * 10px + 20px = 30px
 * 10deg + 10rad
 * 10% + 20% = 30%
 */
function mergeDimensions(left, right, target, nonNegative, index) {
  if (index === void 0) {
    index = 0;
  }
  var unit = '';
  var leftValue = left.value || 0;
  var rightValue = right.value || 0;
  var canonicalUnit = toCanonicalUnit(left.unit);
  var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
  var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
  if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
    leftValue = leftCanonicalUnitValue.value;
    rightValue = rightCanonicalUnitValue.value;
    unit = unitTypeToString(left.unit);
  } else {
    // format '%' to 'px'
    if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
      leftValue = convertPercentUnit(left, index, target);
      rightValue = convertPercentUnit(right, index, target);
      unit = 'px';
    }
  }
  // // format 'rad' 'turn' to 'deg'
  // if (CSSUnitValue.isAngle(left.unit) || CSSUnitValue.isAngle(right.unit)) {
  //   leftValue = convertAngleUnit(left);
  //   rightValue = convertAngleUnit(right);
  //   unit = 'deg';
  // }
  return [leftValue, rightValue, function (value) {
    if (nonNegative) {
      value = Math.max(value, 0);
    }
    return value + unit;
  }];
}
function convertAngleUnit(value) {
  var deg = 0;
  if (value.unit === exports.UnitType.kDegrees) {
    deg = value.value;
  } else if (value.unit === exports.UnitType.kRadians) {
    deg = rad2deg(Number(value.value));
  } else if (value.unit === exports.UnitType.kTurns) {
    deg = turn2deg(Number(value.value));
  }
  return deg;
}
function parseDimensionArrayFormat(string, size) {
  var parsed;
  if (Array.isArray(string)) {
    // [1, '2px', 3]
    parsed = string.map(function (segment) {
      return Number(segment);
    });
  } else if (util.isString(string)) {
    parsed = string.split(' ').map(function (segment) {
      return Number(segment);
    });
  } else if (util.isNumber(string)) {
    parsed = [string];
  }
  if (size === 2) {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0]];
    } else {
      return [parsed[0], parsed[1]];
    }
  } else {
    if (parsed.length === 1) {
      return [parsed[0], parsed[0], parsed[0], parsed[0]];
    } else if (parsed.length === 2) {
      return [parsed[0], parsed[1], parsed[0], parsed[1]];
    } else if (parsed.length === 3) {
      return [parsed[0], parsed[1], parsed[2], parsed[1]];
    } else {
      return [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
  }
}
function parseDimensionArray(string) {
  if (util.isString(string)) {
    // "1px 2px 3px"
    return string.split(' ').map(function (segment) {
      return parseLengthOrPercentage(segment);
    });
  } else {
    // [1, '2px', 3]
    return string.map(function (segment) {
      return parseLengthOrPercentage(segment.toString());
    });
  }
}
// export function mergeDimensionList(
//   left: CSSUnitValue[],
//   right: CSSUnitValue[],
//   target: IElement | null,
// ): [number[], number[], (list: number[]) => string] | undefined {
//   if (left.length !== right.length) {
//     return;
//   }
//   const unit = left[0].unit;
//   return [
//     left.map((l) => l.value),
//     right.map((l) => l.value),
//     (values: number[]) => {
//       return values.map((n) => new CSSUnitValue(n, unit)).join(' ');
//     },
//   ];
// }
function convertPercentUnit(valueWithUnit, vec3Index, target) {
  if (valueWithUnit.unit === exports.UnitType.kPixels) {
    return Number(valueWithUnit.value);
  } else if (valueWithUnit.unit === exports.UnitType.kPercentage && target) {
    var bounds = target.nodeName === exports.Shape.GROUP ? target.getLocalBounds() :
    // : target.getGeometryBounds();
    target.geometry.contentBounds;
    var size = 0;
    if (!AABB.isEmpty(bounds)) {
      size = bounds.halfExtents[vec3Index] * 2;
    }
    return Number(valueWithUnit.value) / 100 * size;
  }
  return 0;
}

var parseParam = function parseParam(css) {
  return parseDimension(/deg|rad|grad|turn|px|%/g, css);
};
var supportedFilters = ['blur', 'brightness', 'drop-shadow', 'contrast', 'grayscale', 'sepia', 'saturate', 'hue-rotate', 'invert'];
function parseFilter(filterStr) {
  if (filterStr === void 0) {
    filterStr = '';
  }
  filterStr = filterStr.toLowerCase().trim();
  if (filterStr === 'none') {
    return [];
  }
  var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = filterRegExp.exec(filterStr)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    if (supportedFilters.indexOf(match[1]) > -1) {
      result.push({
        name: match[1],
        params: match[2].split(' ').map(function (p) {
          return parseParam(p) || parseColor(p);
        })
      });
    }
    if (filterRegExp.lastIndex === filterStr.length) {
      return result;
    }
  }
  return [];
}

function numberToString(x) {
  // scale(0.00000001) -> scale(0)
  // return x.toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
  return x.toString();
}
/**
 * parse string or number to CSSUnitValue(numeric)
 *
 * eg.
 * * 0 -> CSSUnitValue(0)
 * * '2' -> CSSUnitValue(2)
 */
var parseNumber = memoize(function (string) {
  if (typeof string === 'number') {
    return getOrCreateUnitValue(string);
  }
  if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
    return getOrCreateUnitValue(Number(string));
  } else {
    return getOrCreateUnitValue(0);
  }
});
/**
 * separate string to array
 * eg.
 * * [0.5, 0.5] -> [CSSUnitValue, CSSUnitValue]
 */
var parseNumberList = memoize(function (string) {
  if (util.isString(string)) {
    return string.split(' ').map(parseNumber);
  } else {
    return string.map(parseNumber);
  }
});
function mergeNumbers(left, right) {
  return [left, right, numberToString];
}
function clampedMergeNumbers(min, max) {
  return function (left, right) {
    return [left, right, function (x) {
      return numberToString(util.clamp(x, min, max));
    }];
  };
}
function mergeNumberLists(left, right) {
  if (left.length !== right.length) {
    return;
  }
  return [left, right, function (numberList) {
    return numberList;
  }];
}

var internalParsePath = function internalParsePath(path) {
  // empty path
  if (path === '' || Array.isArray(path) && path.length === 0) {
    return {
      absolutePath: [],
      hasArc: false,
      segments: [],
      polygons: [],
      polylines: [],
      curve: null,
      totalLength: 0,
      rect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }
    };
  }
  var absolutePath;
  try {
    absolutePath = util.normalizePath(path);
  } catch (e) {
    absolutePath = util.normalizePath('');
    console.error("[g]: Invalid SVG Path definition: " + path);
  }
  var hasArc = hasArcOrBezier(absolutePath);
  var _extractPolygons = extractPolygons(absolutePath),
    polygons = _extractPolygons.polygons,
    polylines = _extractPolygons.polylines;
  // for later use
  var segments = path2Segments(absolutePath);
  // Only calculate bbox here since we don't need length now.
  var _getPathBBox = getPathBBox(segments, 0),
    x = _getPathBBox.x,
    y = _getPathBBox.y,
    width = _getPathBBox.width,
    height = _getPathBBox.height;
  return {
    absolutePath: absolutePath,
    hasArc: hasArc,
    segments: segments,
    polygons: polygons,
    polylines: polylines,
    // curve,
    // Delay the calculation of length.
    totalLength: 0,
    rect: {
      x: Number.isFinite(x) ? x : 0,
      y: Number.isFinite(y) ? y : 0,
      width: Number.isFinite(width) ? width : 0,
      height: Number.isFinite(height) ? height : 0
    }
  };
};
var memoizedParsePath = memoize(internalParsePath);
function parsePath(path, object) {
  var result = util.isString(path) ? memoizedParsePath(path) : internalParsePath(path);
  if (object) {
    object.parsedStyle.defX = result.rect.x;
    object.parsedStyle.defY = result.rect.y;
  }
  return result;
}
function mergePaths(left, right, object) {
  var curve1 = left.curve;
  var curve2 = right.curve;
  if (!curve1 || curve1.length === 0) {
    // convert to curves to do morphing & picking later
    // @see http://thednp.github.io/kute.js/svgCubicMorph.html
    curve1 = util.path2Curve(left.absolutePath, false);
    left.curve = curve1;
  }
  if (!curve2 || curve2.length === 0) {
    curve2 = util.path2Curve(right.absolutePath, false);
    right.curve = curve2;
  }
  var curves = [curve1, curve2];
  if (curve1.length !== curve2.length) {
    curves = util.equalizeSegments(curve1, curve2);
  }
  var curve0 = util.getDrawDirection(curves[0]) !== util.getDrawDirection(curves[1]) ? util.reverseCurve(curves[0]) : util.clonePath(curves[0]);
  return [curve0, util.getRotatedCurve(curves[1], curve0), function (pathArray) {
    // need converting to path string?
    return pathArray;
  }];
}

/**
 * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/points
 *
 * @example
 * points="100,10 250,150 200,110"
 */
function parsePoints(pointsOrStr, object) {
  var points;
  if (util.isString(pointsOrStr)) {
    points = pointsOrStr.split(' ').map(function (pointStr) {
      var _pointStr$split = pointStr.split(','),
        x = _pointStr$split[0],
        y = _pointStr$split[1];
      return [Number(x), Number(y)];
    });
  } else {
    points = pointsOrStr;
  }
  var segments = [];
  var tempLength = 0;
  var segmentT;
  var segmentL;
  var totalLength = gMath.Polyline.length(points);
  points.forEach(function (p, i) {
    if (points[i + 1]) {
      segmentT = [0, 0];
      segmentT[0] = tempLength / totalLength;
      segmentL = gMath.Line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
      tempLength += segmentL;
      segmentT[1] = tempLength / totalLength;
      segments.push(segmentT);
    }
  });
  var minX = Math.min.apply(Math, points.map(function (point) {
    return point[0];
  }));
  var minY = Math.min.apply(Math, points.map(function (point) {
    return point[1];
  }));
  if (object) {
    object.parsedStyle.defX = minX;
    object.parsedStyle.defY = minY;
  }
  return {
    points: points,
    totalLength: totalLength,
    segments: segments
  };
}

var _ = null;
function cast(pattern) {
  return function (contents) {
    var i = 0;
    return pattern.map(function (x) {
      return x === _ ? contents[i++] : x;
    });
  };
}
function id(x) {
  return x;
}
// type: [argTypes, convertTo3D, convertTo2D]
// In the argument types string, lowercase characters represent optional arguments
var transformFunctions = {
  // @ts-ignore
  matrix: ['NNNNNN', [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
  matrix3d: ['NNNNNNNNNNNNNNNN', id],
  rotate: ['A'],
  rotatex: ['A'],
  rotatey: ['A'],
  rotatez: ['A'],
  rotate3d: ['NNNA'],
  perspective: ['L'],
  scale: ['Nn', cast([_, _, new CSSUnitValue(1)]), id],
  scalex: ['N', cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
  scaley: ['N', cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
  scalez: ['N', cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
  scale3d: ['NNN', id],
  skew: ['Aa', null, id],
  skewx: ['A', null, cast([_, Odeg])],
  skewy: ['A', null, cast([Odeg, _])],
  translate: ['Tt', cast([_, _, Opx]), id],
  translatex: ['T', cast([_, Opx, Opx]), cast([_, Opx])],
  translatey: ['T', cast([Opx, _, Opx]), cast([Opx, _])],
  translatez: ['L', cast([Opx, Opx, _])],
  translate3d: ['TTL', id]
};
/**
 * none
 * scale(1) scale(1, 2)
 * scaleX(1)
 */
function parseTransform(string) {
  string = (string || 'none').toLowerCase().trim();
  if (string === 'none') {
    return [];
  }
  var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
  var result = [];
  var match;
  var prevLastIndex = 0;
  while (match = transformRegExp.exec(string)) {
    if (match.index !== prevLastIndex) {
      return [];
    }
    prevLastIndex = match.index + match[0].length;
    var functionName = match[1]; // scale
    var functionData = transformFunctions[functionName]; // scale(1, 2)
    if (!functionData) {
      // invalid, eg. scale()
      return [];
    }
    var args = match[2].split(','); // 1,2
    var argTypes = functionData[0]; // Nn
    if (argTypes.length < args.length) {
      // scale(N, n)
      return [];
    }
    var parsedArgs = [];
    for (var i = 0; i < argTypes.length; i++) {
      var arg = args[i];
      var type = argTypes[i];
      var parsedArg = void 0;
      if (!arg) {
        // @ts-ignore
        parsedArg = {
          a: Odeg,
          n: parsedArgs[0],
          t: Opx
        }[type];
      } else {
        // @ts-ignore
        parsedArg = {
          A: function A(s) {
            return s.trim() === '0' ? Odeg : parseAngle(s);
          },
          N: parseNumber,
          T: parseLengthOrPercentage,
          L: parseLength
        }[type.toUpperCase()](arg);
      }
      if (parsedArg === undefined) {
        return [];
      }
      parsedArgs.push(parsedArg);
    }
    result.push({
      t: functionName,
      d: parsedArgs
    }); // { t: scale, d: [1, 2] }
    if (transformRegExp.lastIndex === string.length) {
      return result;
    }
  }
  return [];
}
function convertItemToMatrix(item) {
  var x;
  var y;
  var z;
  var angle;
  switch (item.t) {
    case 'rotatex':
      angle = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, 0, Math.cos(angle), Math.sin(angle), 0, 0, -Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1];
    case 'rotatey':
      angle = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle), 0, -Math.sin(angle), 0, 0, 1, 0, 0, Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 1];
    case 'rotate':
    case 'rotatez':
      angle = deg2rad(convertAngleUnit(item.d[0]));
      return [Math.cos(angle), Math.sin(angle), 0, 0, -Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case 'rotate3d':
      x = item.d[0].value;
      y = item.d[1].value;
      z = item.d[2].value;
      angle = deg2rad(convertAngleUnit(item.d[3]));
      var sqrLength = x * x + y * y + z * z;
      if (sqrLength === 0) {
        x = 1;
        y = 0;
        z = 0;
      } else if (sqrLength !== 1) {
        var length = Math.sqrt(sqrLength);
        x /= length;
        y /= length;
        z /= length;
      }
      var s = Math.sin(angle / 2);
      var sc = s * Math.cos(angle / 2);
      var sq = s * s;
      return [1 - 2 * (y * y + z * z) * sq, 2 * (x * y * sq + z * sc), 2 * (x * z * sq - y * sc), 0, 2 * (x * y * sq - z * sc), 1 - 2 * (x * x + z * z) * sq, 2 * (y * z * sq + x * sc), 0, 2 * (x * z * sq + y * sc), 2 * (y * z * sq - x * sc), 1 - 2 * (x * x + y * y) * sq, 0, 0, 0, 0, 1];
    case 'scale':
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case 'scalex':
      return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case 'scaley':
      return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case 'scalez':
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
    case 'scale3d':
      return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
    case 'skew':
      var xAngle = deg2rad(convertAngleUnit(item.d[0]));
      var yAngle = deg2rad(convertAngleUnit(item.d[1]));
      return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case 'skewx':
      angle = deg2rad(convertAngleUnit(item.d[0]));
      return [1, 0, 0, 0, Math.tan(angle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case 'skewy':
      angle = deg2rad(convertAngleUnit(item.d[0]));
      return [1, Math.tan(angle), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    case 'translate':
      // TODO: pass target
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      y = convertPercentUnit(item.d[1], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, 0, 1];
    case 'translatex':
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, 0, 0, 1];
    case 'translatey':
      y = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y, 0, 1];
    case 'translatez':
      z = convertPercentUnit(item.d[0], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
    case 'translate3d':
      x = convertPercentUnit(item.d[0], 0, null) || 0;
      y = convertPercentUnit(item.d[1], 0, null) || 0;
      z = convertPercentUnit(item.d[2], 0, null) || 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];
    case 'perspective':
      var t = convertPercentUnit(item.d[0], 0, null) || 0;
      var p = t ? -1 / t : 0;
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p, 0, 0, 0, 1];
    case 'matrix':
      return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
    case 'matrix3d':
      return item.d.map(function (d) {
        return d.value;
      });
  }
}
function multiplyMatrices(a, b) {
  return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
}
function convertToMatrix(transformList) {
  if (transformList.length === 0) {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
}
function makeMatrixDecomposition(transformList) {
  var translate = [0, 0, 0];
  var scale = [1, 1, 1];
  var skew = [0, 0, 0];
  var perspective = [0, 0, 0, 1];
  var quaternion = [0, 0, 0, 1];
  // @ts-ignore
  decomposeMat4(convertToMatrix(transformList), translate, scale, skew, perspective, quaternion);
  return [[translate, scale, skew, quaternion, perspective]];
}
var composeMatrix = function () {
  function multiply(a, b) {
    var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
    for (var i = 0; i < 4; i++) {
      for (var j = 0; j < 4; j++) {
        for (var k = 0; k < 4; k++) {
          result[i][j] += b[i][k] * a[k][j];
        }
      }
    }
    return result;
  }
  function is2D(m) {
    return m[0][2] == 0 && m[0][3] == 0 && m[1][2] == 0 && m[1][3] == 0 && m[2][0] == 0 && m[2][1] == 0 && m[2][2] == 1 && m[2][3] == 0 && m[3][2] == 0 && m[3][3] == 1;
  }
  function composeMatrix(translate, scale, skew, quat, perspective) {
    var matrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    for (var i = 0; i < 4; i++) {
      matrix[i][3] = perspective[i];
    }
    for (var _i = 0; _i < 3; _i++) {
      for (var j = 0; j < 3; j++) {
        matrix[3][_i] += translate[j] * matrix[j][_i];
      }
    }
    var x = quat[0],
      y = quat[1],
      z = quat[2],
      w = quat[3];
    var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    rotMatrix[0][0] = 1 - 2 * (y * y + z * z);
    rotMatrix[0][1] = 2 * (x * y - z * w);
    rotMatrix[0][2] = 2 * (x * z + y * w);
    rotMatrix[1][0] = 2 * (x * y + z * w);
    rotMatrix[1][1] = 1 - 2 * (x * x + z * z);
    rotMatrix[1][2] = 2 * (y * z - x * w);
    rotMatrix[2][0] = 2 * (x * z - y * w);
    rotMatrix[2][1] = 2 * (y * z + x * w);
    rotMatrix[2][2] = 1 - 2 * (x * x + y * y);
    matrix = multiply(matrix, rotMatrix);
    var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
    if (skew[2]) {
      temp[2][1] = skew[2];
      matrix = multiply(matrix, temp);
    }
    if (skew[1]) {
      temp[2][1] = 0;
      temp[2][0] = skew[0];
      matrix = multiply(matrix, temp);
    }
    if (skew[0]) {
      temp[2][0] = 0;
      temp[1][0] = skew[0];
      matrix = multiply(matrix, temp);
    }
    for (var _i2 = 0; _i2 < 3; _i2++) {
      for (var _j = 0; _j < 3; _j++) {
        matrix[_i2][_j] *= scale[_i2];
      }
    }
    if (is2D(matrix)) {
      return [matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1], matrix[3][0], matrix[3][1]];
    }
    return matrix[0].concat(matrix[1], matrix[2], matrix[3]);
  }
  return composeMatrix;
}();
function numberToLongString(x) {
  return x.toFixed(6).replace('.000000', '');
}
function mergeMatrices(left, right) {
  var leftArgs;
  var rightArgs;
  // @ts-ignore
  if (left.decompositionPair !== right) {
    // @ts-ignore
    left.decompositionPair = right;
    // @ts-ignore
    leftArgs = makeMatrixDecomposition(left);
  }
  // @ts-ignore
  if (right.decompositionPair !== left) {
    // @ts-ignore
    right.decompositionPair = left;
    // @ts-ignore
    rightArgs = makeMatrixDecomposition(right);
  }
  if (leftArgs[0] === null || rightArgs[0] === null) return [
  // @ts-ignore
  [false],
  // @ts-ignore
  [true],
  // @ts-ignore
  function (x) {
    return x ? right[0].d : left[0].d;
  }];
  leftArgs[0].push(0);
  rightArgs[0].push(1);
  return [leftArgs, rightArgs,
  // @ts-ignore
  function (list) {
    // @ts-ignore
    var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
    var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
    var stringifiedArgs = mat.map(numberToLongString).join(',');
    return stringifiedArgs;
  }];
}
function dot(v1, v2) {
  var result = 0;
  for (var i = 0; i < v1.length; i++) {
    result += v1[i] * v2[i];
  }
  return result;
}
function quat(fromQ, toQ, f) {
  var product = dot(fromQ, toQ);
  product = util.clamp(product, -1.0, 1.0);
  var quat = [];
  if (product === 1.0) {
    quat = fromQ;
  } else {
    var theta = Math.acos(product);
    var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
    for (var i = 0; i < 4; i++) {
      quat.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
    }
  }
  return quat;
}
// scalex/y/z -> scale
function typeTo2D(type) {
  return type.replace(/[xy]/, '');
}
// scalex/y/z -> scale3d
function typeTo3D(type) {
  return type.replace(/(x|y|z|3d)?$/, '3d');
}
var isMatrixOrPerspective = function isMatrixOrPerspective(lt, rt) {
  return lt === 'perspective' && rt === 'perspective' || (lt === 'matrix' || lt === 'matrix3d') && (rt === 'matrix' || rt === 'matrix3d');
};
function mergeTransforms(left, right, target) {
  var flipResults = false;
  // padding empty transform, eg. merge 'scale(10)' with 'none' -> scale(1)
  if (!left.length || !right.length) {
    if (!left.length) {
      flipResults = true;
      left = right;
      right = [];
    }
    var _loop = function _loop(i) {
      var _left$i = left[i],
        type = _left$i.t,
        args = _left$i.d;
      // none -> scale(1)/translateX(0)
      var defaultValue = type.substring(0, 5) === 'scale' ? 1 : 0;
      right.push({
        t: type,
        d: args.map(function (arg) {
          if (typeof arg === 'number') {
            return getOrCreateUnitValue(defaultValue);
          }
          return getOrCreateUnitValue(defaultValue, arg.unit);
          //   {
          //     unit: arg.unit,
          //     value: defaultValue,
          //   };
        })
      });
    };
    for (var i = 0; i < left.length; i++) {
      _loop(i);
    }
  }
  var leftResult = [];
  var rightResult = [];
  var types = [];
  // merge matrix() with matrix3d()
  if (left.length !== right.length) {
    var merged = mergeMatrices(left, right);
    // @ts-ignore
    leftResult = [merged[0]];
    // @ts-ignore
    rightResult = [merged[1]];
    types = [['matrix', [merged[2]]]];
  } else {
    for (var _i3 = 0; _i3 < left.length; _i3++) {
      var leftType = left[_i3].t;
      var rightType = right[_i3].t;
      var leftArgs = left[_i3].d;
      var rightArgs = right[_i3].d;
      var leftFunctionData = transformFunctions[leftType];
      var rightFunctionData = transformFunctions[rightType];
      var type = void 0;
      if (isMatrixOrPerspective(leftType, rightType)) {
        var _merged = mergeMatrices([left[_i3]], [right[_i3]]);
        // @ts-ignore
        leftResult.push(_merged[0]);
        // @ts-ignore
        rightResult.push(_merged[1]);
        types.push(['matrix', [_merged[2]]]);
        continue;
      } else if (leftType === rightType) {
        type = leftType;
      } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
        type = typeTo2D(leftType);
        // @ts-ignore
        leftArgs = leftFunctionData[2](leftArgs);
        // @ts-ignore
        rightArgs = rightFunctionData[2](rightArgs);
      } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
        type = typeTo3D(leftType);
        // @ts-ignore
        leftArgs = leftFunctionData[1](leftArgs);
        // @ts-ignore
        rightArgs = rightFunctionData[1](rightArgs);
      } else {
        var _merged2 = mergeMatrices(left, right);
        // @ts-ignore
        leftResult = [_merged2[0]];
        // @ts-ignore
        rightResult = [_merged2[1]];
        types = [['matrix', [_merged2[2]]]];
        break;
      }
      var leftArgsCopy = [];
      var rightArgsCopy = [];
      var stringConversions = [];
      for (var j = 0; j < leftArgs.length; j++) {
        // const merge = leftArgs[j].unit === UnitType.kNumber ? mergeDimensions : mergeDimensions;
        var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
        leftArgsCopy[j] = _merged3[0];
        rightArgsCopy[j] = _merged3[1];
        stringConversions.push(_merged3[2]);
      }
      leftResult.push(leftArgsCopy);
      rightResult.push(rightArgsCopy);
      types.push([type, stringConversions]);
    }
  }
  if (flipResults) {
    var tmp = leftResult;
    leftResult = rightResult;
    rightResult = tmp;
  }
  return [leftResult, rightResult, function (list) {
    return list.map(function (args, i) {
      var stringifiedArgs = args.map(function (arg, j) {
        return types[i][1][j](arg);
      }).join(',');
      if (types[i][0] === 'matrix' && stringifiedArgs.split(',').length === 16) {
        types[i][0] = 'matrix3d';
      }
      if (types[i][0] === 'matrix3d' && stringifiedArgs.split(',').length === 6) {
        types[i][0] = 'matrix';
      }
      return types[i][0] + '(' + stringifiedArgs + ')';
    }).join(' ');
  }];
}

/**
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin
 * eg. 'center' 'top left' '50px 50px'
 */
var parseTransformOrigin = memoize(function (value) {
  if (util.isString(value)) {
    if (value === 'text-anchor') {
      return [getOrCreateUnitValue(0, 'px'), getOrCreateUnitValue(0, 'px')];
    }
    var values = value.split(' ');
    if (values.length === 1) {
      if (values[0] === 'top' || values[0] === 'bottom') {
        // 'top' -> 'center top'
        values[1] = values[0];
        values[0] = 'center';
      } else {
        // '50px' -> '50px center'
        values[1] = 'center';
      }
    }
    if (values.length !== 2) {
      return null;
    }
    // eg. center bottom
    return [parseLengthOrPercentage(convertKeyword2Percent(values[0])), parseLengthOrPercentage(convertKeyword2Percent(values[1]))];
  } else {
    return [getOrCreateUnitValue(value[0] || 0, 'px'), getOrCreateUnitValue(value[1] || 0, 'px')];
  }
});
function convertKeyword2Percent(keyword) {
  if (keyword === 'center') {
    return '50%';
  } else if (keyword === 'left' || keyword === 'top') {
    return '0';
  } else if (keyword === 'right' || keyword === 'bottom') {
    return '100%';
  }
  return keyword;
}

var CSSPropertyAngle = /*#__PURE__*/function () {
  function CSSPropertyAngle() {
    this.parser = parseAngle;
    this.parserWithCSSDisabled = null;
    this.mixer = mergeNumbers;
  }
  var _proto = CSSPropertyAngle.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    return convertAngleUnit(parsed);
  };
  return CSSPropertyAngle;
}();

/**
 * clipPath / textPath / offsetPath
 */
var CSSPropertyClipPath = /*#__PURE__*/function () {
  function CSSPropertyClipPath() {}
  var _proto = CSSPropertyClipPath.prototype;
  _proto.calculator = function calculator(name, oldPath, newPath, object) {
    // unset
    if (newPath instanceof CSSKeywordValue) {
      newPath = null;
    }
    runtime.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
    if (name === 'clipPath') {
      // should affect children
      object.forEach(function (leaf) {
        if (leaf.childNodes.length === 0) {
          runtime.sceneGraphService.dirtifyToRoot(leaf);
        }
      });
    }
    return newPath;
  };
  return CSSPropertyClipPath;
}();

var CSSPropertyColor = /*#__PURE__*/function () {
  function CSSPropertyColor() {
    this.parser = parseColor;
    this.parserWithCSSDisabled = parseColor;
    this.mixer = mergeColors;
  }
  var _proto = CSSPropertyColor.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    if (parsed instanceof CSSKeywordValue) {
      // 'unset' 'none'
      return parsed.value === 'none' ? noneColor : transparentColor;
    }
    return parsed;
  };
  return CSSPropertyColor;
}();

var CSSPropertyFilter = /*#__PURE__*/function () {
  function CSSPropertyFilter() {
    this.parser = parseFilter;
  }
  var _proto = CSSPropertyFilter.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed) {
    // unset or none
    if (parsed instanceof CSSKeywordValue) {
      return [];
    }
    return parsed;
  };
  return CSSPropertyFilter;
}();

function getFontSize(object) {
  var fontSize = object.parsedStyle.fontSize;
  return util.isNil(fontSize) ? null : fontSize;
}
/**
 * <length> & <percentage>
 */
var CSSPropertyLengthOrPercentage = /*#__PURE__*/function () {
  function CSSPropertyLengthOrPercentage() {
    this.parser = parseLengthOrPercentage;
    this.parserWithCSSDisabled = null;
    this.mixer = mergeNumbers;
  }
  var _proto = CSSPropertyLengthOrPercentage.prototype;
  /**
   * according to parent's bounds
   *
   * @example
   * CSS.percent(50) -> CSS.px(0.5 * parent.width)
   */
  _proto.calculator = function calculator(name, oldParsed, computed, object, registry) {
    if (util.isNumber(computed)) {
      return computed;
    }
    if (CSSUnitValue.isRelativeUnit(computed.unit)) {
      if (computed.unit === exports.UnitType.kPercentage) {
        // TODO: merge dimensions
        return 0;
      } else if (computed.unit === exports.UnitType.kEms) {
        if (object.parentNode) {
          var fontSize = getFontSize(object.parentNode);
          if (fontSize) {
            fontSize *= computed.value;
            return fontSize;
          } else {
            registry.addUnresolveProperty(object, name);
          }
        } else {
          registry.addUnresolveProperty(object, name);
        }
        return 0;
      } else if (computed.unit === exports.UnitType.kRems) {
        var _object$ownerDocument;
        if (object === null || object === void 0 ? void 0 : (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.documentElement) {
          var _fontSize = getFontSize(object.ownerDocument.documentElement);
          if (_fontSize) {
            _fontSize *= computed.value;
            return _fontSize;
          } else {
            registry.addUnresolveProperty(object, name);
          }
        } else {
          registry.addUnresolveProperty(object, name);
        }
        return 0;
      }
    } else {
      // remove listener if exists
      // registry.unregisterParentGeometryBoundsChangedHandler(object, name);
      // return absolute value
      return computed.value;
    }
  };
  return CSSPropertyLengthOrPercentage;
}();

/**
 * format to Tuple2<CSSUnitValue>
 *
 * @example
 * rect.style.lineDash = 10;
 * rect.style.lineDash = [10, 10];
 * rect.style.lineDash = '10 10';
 */
var CSSPropertyLengthOrPercentage12 = /*#__PURE__*/function () {
  function CSSPropertyLengthOrPercentage12() {
    this.mixer = mergeNumberLists;
  }
  var _proto = CSSPropertyLengthOrPercentage12.prototype;
  _proto.parser = function parser(radius) {
    var parsed = parseDimensionArray(util.isNumber(radius) ? [radius] : radius);
    var formatted;
    if (parsed.length === 1) {
      formatted = [parsed[0], parsed[0]];
    } else {
      formatted = [parsed[0], parsed[1]];
    }
    return formatted;
  };
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.map(function (c) {
      return c.value;
    });
  };
  return CSSPropertyLengthOrPercentage12;
}();

/**
 * used in rounded rect
 *
 * @example
 * rect.style.radius = 10;
 * rect.style.radius = '10 10';
 * rect.style.radius = '10 10 10 10';
 */
var CSSPropertyLengthOrPercentage14 = /*#__PURE__*/function () {
  function CSSPropertyLengthOrPercentage14() {
    this.mixer = mergeNumberLists;
  }
  var _proto = CSSPropertyLengthOrPercentage14.prototype;
  _proto.parser = function parser(radius) {
    var parsed = parseDimensionArray(util.isNumber(radius) ? [radius] : radius);
    var formatted;
    // format to Tuple<CSSUnitValue>
    if (parsed.length === 1) {
      formatted = [parsed[0], parsed[0], parsed[0], parsed[0]];
    } else if (parsed.length === 2) {
      formatted = [parsed[0], parsed[1], parsed[0], parsed[1]];
    } else if (parsed.length === 3) {
      formatted = [parsed[0], parsed[1], parsed[2], parsed[1]];
    } else {
      formatted = [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
    return formatted;
  };
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.map(function (c) {
      return c.value;
    });
  };
  return CSSPropertyLengthOrPercentage14;
}();

/**
 * local position
 */
var CSSPropertyLocalPosition = /*#__PURE__*/function (_CSSPropertyLengthOrP) {
  _inheritsLoose(CSSPropertyLocalPosition, _CSSPropertyLengthOrP);
  function CSSPropertyLocalPosition() {
    return _CSSPropertyLengthOrP.apply(this, arguments) || this;
  }
  var _proto = CSSPropertyLocalPosition.prototype;
  /**
   * update local position
   */
  _proto.postProcessor = function postProcessor(object, attributes) {
    var x;
    var y;
    var z;
    switch (object.nodeName) {
      case exports.Shape.CIRCLE:
      case exports.Shape.ELLIPSE:
        var _object$parsedStyle = object.parsedStyle,
          cx = _object$parsedStyle.cx,
          cy = _object$parsedStyle.cy;
        if (!util.isNil(cx)) {
          x = cx;
        }
        if (!util.isNil(cy)) {
          y = cy;
        }
        break;
      case exports.Shape.LINE:
        var _object$parsedStyle2 = object.parsedStyle,
          x1 = _object$parsedStyle2.x1,
          x2 = _object$parsedStyle2.x2,
          y1 = _object$parsedStyle2.y1,
          y2 = _object$parsedStyle2.y2;
        var minX = Math.min(x1, x2);
        var minY = Math.min(y1, y2);
        x = minX;
        y = minY;
        z = 0;
        break;
      case exports.Shape.RECT:
      case exports.Shape.IMAGE:
      case exports.Shape.GROUP:
      case exports.Shape.HTML:
      case exports.Shape.TEXT:
      case exports.Shape.MESH:
        if (!util.isNil(object.parsedStyle.x)) {
          x = object.parsedStyle.x;
        }
        if (!util.isNil(object.parsedStyle.y)) {
          y = object.parsedStyle.y;
        }
        break;
    }
    if (object.nodeName !== exports.Shape.PATH && object.nodeName !== exports.Shape.POLYLINE && object.nodeName !== exports.Shape.POLYGON) {
      object.parsedStyle.defX = x || 0;
      object.parsedStyle.defY = y || 0;
    }
    var needResetLocalPosition = !util.isNil(x) || !util.isNil(y) || !util.isNil(z);
    // only if `transform` won't be processed later
    if (needResetLocalPosition && attributes.indexOf('transform') === -1) {
      // account for current transform if needed
      var transform = object.parsedStyle.transform;
      if (transform && transform.length) {
        parsedTransformToMat4(transform, object);
      } else {
        var _object$getLocalPosit = object.getLocalPosition(),
          ox = _object$getLocalPosit[0],
          oy = _object$getLocalPosit[1],
          oz = _object$getLocalPosit[2];
        object.setLocalPosition(util.isNil(x) ? ox : x, util.isNil(y) ? oy : y, util.isNil(z) ? oz : z);
      }
    }
  };
  return CSSPropertyLocalPosition;
}(CSSPropertyLengthOrPercentage);

var CSSPropertyMarker = /*#__PURE__*/function () {
  function CSSPropertyMarker() {}
  var _proto = CSSPropertyMarker.prototype;
  _proto.calculator = function calculator(name, oldMarker, newMarker, object) {
    var _newMarker;
    // unset
    if (newMarker instanceof CSSKeywordValue) {
      newMarker = null;
    }
    var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
    if (cloned) {
      // FIXME: SVG should not inherit parent's style, add a flag here
      cloned.style.isMarker = true;
    }
    return cloned;
  };
  return CSSPropertyMarker;
}();

var CSSPropertyNumber = /*#__PURE__*/function () {
  function CSSPropertyNumber() {
    this.mixer = mergeNumbers;
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
  }
  var _proto = CSSPropertyNumber.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  return CSSPropertyNumber;
}();

var CSSPropertyOffsetDistance = /*#__PURE__*/function () {
  function CSSPropertyOffsetDistance() {
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
    this.mixer = clampedMergeNumbers(0, 1);
  }
  var _proto = CSSPropertyOffsetDistance.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  _proto.postProcessor = function postProcessor(object) {
    var _object$parsedStyle = object.parsedStyle,
      offsetPath = _object$parsedStyle.offsetPath,
      offsetDistance = _object$parsedStyle.offsetDistance;
    if (!offsetPath) {
      return;
    }
    var nodeName = offsetPath.nodeName;
    if (nodeName === exports.Shape.LINE || nodeName === exports.Shape.PATH || nodeName === exports.Shape.POLYLINE) {
      // set position in world space
      var point = offsetPath.getPoint(offsetDistance);
      if (point) {
        object.parsedStyle.defX = point.x;
        object.parsedStyle.defY = point.y;
        object.setLocalPosition(point.x, point.y);
      }
    }
  };
  return CSSPropertyOffsetDistance;
}();

/**
 * opacity
 */
var CSSPropertyOpacity = /*#__PURE__*/function () {
  function CSSPropertyOpacity() {
    this.parser = parseNumber;
    this.parserWithCSSDisabled = null;
    this.mixer = clampedMergeNumbers(0, 1);
  }
  var _proto = CSSPropertyOpacity.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed) {
    return computed.value;
  };
  return CSSPropertyOpacity;
}();

var CSSPropertyPath = /*#__PURE__*/function () {
  function CSSPropertyPath() {
    this.parser = parsePath;
    this.parserWithCSSDisabled = parsePath;
    this.mixer = mergePaths;
  }
  var _proto = CSSPropertyPath.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed) {
    // unset
    if (parsed instanceof CSSKeywordValue && parsed.value === 'unset') {
      return {
        absolutePath: [],
        hasArc: false,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: new Rectangle(0, 0, 0, 0)
      };
    }
    return parsed;
  };
  /**
   * update local position
   */
  _proto.postProcessor = function postProcessor(object, attributes) {
    if (object.nodeName === exports.Shape.PATH && attributes.indexOf('transform') === -1) {
      var _object$parsedStyle = object.parsedStyle,
        _object$parsedStyle$d = _object$parsedStyle.defX,
        defX = _object$parsedStyle$d === void 0 ? 0 : _object$parsedStyle$d,
        _object$parsedStyle$d2 = _object$parsedStyle.defY,
        defY = _object$parsedStyle$d2 === void 0 ? 0 : _object$parsedStyle$d2;
      object.setLocalPosition(defX, defY);
    }
  };
  return CSSPropertyPath;
}();

var CSSPropertyPoints = /*#__PURE__*/function () {
  function CSSPropertyPoints() {
    this.parser = parsePoints;
  }
  var _proto = CSSPropertyPoints.prototype;
  /**
   * update local position
   */
  _proto.postProcessor = function postProcessor(object, attributes) {
    if ((object.nodeName === exports.Shape.POLYGON || object.nodeName === exports.Shape.POLYLINE) && attributes.indexOf('transform') === -1) {
      var _object$parsedStyle = object.parsedStyle,
        defX = _object$parsedStyle.defX,
        defY = _object$parsedStyle.defY;
      object.setLocalPosition(defX, defY);
    }
  };
  return CSSPropertyPoints;
}();

var CSSPropertyShadowBlur = /*#__PURE__*/function (_CSSPropertyLengthOrP) {
  _inheritsLoose(CSSPropertyShadowBlur, _CSSPropertyLengthOrP);
  function CSSPropertyShadowBlur() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _CSSPropertyLengthOrP.call.apply(_CSSPropertyLengthOrP, [this].concat(args)) || this;
    _this.mixer = clampedMergeNumbers(0, Infinity);
    return _this;
  }
  return CSSPropertyShadowBlur;
}(CSSPropertyLengthOrPercentage);

var CSSPropertyText = /*#__PURE__*/function () {
  function CSSPropertyText() {}
  var _proto = CSSPropertyText.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    if (parsed instanceof CSSKeywordValue) {
      if (parsed.value === 'unset') {
        return '';
      } else {
        return parsed.value;
      }
    }
    // allow number as valid text content
    return "" + parsed;
  };
  _proto.postProcessor = function postProcessor(object) {
    object.nodeValue = "" + object.parsedStyle.text || '';
  };
  return CSSPropertyText;
}();

/**
 * it must transform after text get parsed
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-transform
 */
var CSSPropertyTextTransform = /*#__PURE__*/function () {
  function CSSPropertyTextTransform() {}
  var _proto = CSSPropertyTextTransform.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    var rawText = object.getAttribute('text');
    if (rawText) {
      var transformedText = rawText;
      if (parsed.value === 'capitalize') {
        transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
      } else if (parsed.value === 'lowercase') {
        transformedText = rawText.toLowerCase();
      } else if (parsed.value === 'uppercase') {
        transformedText = rawText.toUpperCase();
      }
      object.parsedStyle.text = transformedText;
    }
    return parsed.value;
  };
  return CSSPropertyTextTransform;
}();

/**
 * @see /zh/docs/api/animation#支持变换的属性
 *
 * support the following formats like CSS Transform:
 *
 * scale
 * * scale(x, y)
 * * scaleX(x)
 * * scaleY(x)
 * * scaleZ(z)
 * * scale3d(x, y, z)
 *
 * translate (unit: none, px, %(relative to its bounds))
 * * translate(x, y) eg. translate(0, 0) translate(0, 30px) translate(100%, 100%)
 * * translateX(0)
 * * translateY(0)
 * * translateZ(0)
 * * translate3d(0, 0, 0)
 *
 * rotate (unit: deg rad turn)
 * * rotate(0.5turn) rotate(30deg) rotate(1rad)
 *
 * none
 *
 * unsupported for now:
 * * calc() eg. translate(calc(100% + 10px))
 * * matrix/matrix3d()
 * * skew/skewX/skewY
 * * perspective
 */
var CSSPropertyTransform = /*#__PURE__*/function () {
  function CSSPropertyTransform() {
    this.parser = parseTransform;
    this.parserWithCSSDisabled = parseTransform;
    this.mixer = mergeTransforms;
  }
  var _proto = CSSPropertyTransform.prototype;
  _proto.calculator = function calculator(name, oldParsed, parsed, object) {
    // 'none'
    if (parsed instanceof CSSKeywordValue) {
      return [];
    }
    return parsed;
  };
  _proto.postProcessor = function postProcessor(object) {
    var transform = object.parsedStyle.transform;
    parsedTransformToMat4(transform, object);
  };
  return CSSPropertyTransform;
}();

/**
 * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin
 * @example
 * [10px, 10px] [10%, 10%]
 */
var CSSPropertyTransformOrigin = function CSSPropertyTransformOrigin() {
  this.parser = parseTransformOrigin;
};

var CSSPropertyZIndex = /*#__PURE__*/function () {
  function CSSPropertyZIndex() {
    this.parser = parseNumber;
  }
  var _proto = CSSPropertyZIndex.prototype;
  _proto.calculator = function calculator(name, oldParsed, computed, object) {
    return computed.value;
  };
  _proto.postProcessor = function postProcessor(object) {
    if (object.parentNode) {
      var parentEntity = object.parentNode;
      var parentRenderable = parentEntity.renderable;
      var parentSortable = parentEntity.sortable;
      if (parentRenderable) {
        parentRenderable.dirty = true;
      }
      // need re-sort on parent
      if (parentSortable) {
        parentSortable.dirty = true;
      }
    }
  };
  return CSSPropertyZIndex;
}();

/**
 * canvas.customElements
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry
 */
var CustomElementRegistry = /*#__PURE__*/function () {
  function CustomElementRegistry() {
    this.registry = {};
    this.define(exports.Shape.CIRCLE, Circle);
    this.define(exports.Shape.ELLIPSE, Ellipse);
    this.define(exports.Shape.RECT, Rect);
    this.define(exports.Shape.IMAGE, Image);
    this.define(exports.Shape.LINE, Line);
    this.define(exports.Shape.GROUP, Group);
    this.define(exports.Shape.PATH, Path);
    this.define(exports.Shape.POLYGON, Polygon);
    this.define(exports.Shape.POLYLINE, Polyline);
    this.define(exports.Shape.TEXT, Text);
    this.define(exports.Shape.HTML, HTML);
  }
  var _proto = CustomElementRegistry.prototype;
  _proto.define = function define(name, constructor) {
    this.registry[name] = constructor;
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
   */;
  _proto.get = function get(name) {
    return this.registry[name];
  };
  return CustomElementRegistry;
}();

function isFederatedEvent(value) {
  return !!value.type;
}
/**
 * An DOM-compatible synthetic event implementation that is "forwarded" on behalf of an original
 * FederatedEvent or native {@link https://dom.spec.whatwg.org/#event Event}.
 */
var FederatedEvent = /*#__PURE__*/function () {
  /**
   * The event boundary which manages this event. Propagation can only occur
   *  within the boundary's jurisdiction.
   */
  function FederatedEvent(manager) {
    this.type = void 0;
    this.eventPhase = FederatedEvent.prototype.NONE;
    this.target = void 0;
    this.bubbles = true;
    this.cancelBubble = true;
    this.cancelable = false;
    this.currentTarget = void 0;
    this.defaultPrevented = false;
    this.timeStamp = void 0;
    this.nativeEvent = void 0;
    this.originalEvent = void 0;
    this.propagationStopped = false;
    this.propagationImmediatelyStopped = false;
    this.manager = void 0;
    this.detail = void 0;
    this.layer = new Point();
    this.page = new Point();
    this.canvas = new Point();
    this.viewport = new Point();
    this.path = void 0;
    this.view = void 0;
    this.which = void 0;
    this.returnValue = void 0;
    this.srcElement = void 0;
    this.composed = false;
    this.isTrusted = void 0;
    this.NONE = 0;
    this.CAPTURING_PHASE = 1;
    this.AT_TARGET = 2;
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  var _proto = FederatedEvent.prototype;
  /**
   * The propagation path for this event
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
   *
   * So composedPath()[0] represents the original target.
   * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
   */
  _proto.composedPath = function composedPath() {
    if (this.manager && (!this.path || this.path[0] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  /**
   * @deprecated
   */;
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
   */
  _proto.preventDefault = function preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
   */;
  _proto.stopImmediatePropagation = function stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
   */;
  _proto.stopPropagation = function stopPropagation() {
    this.propagationStopped = true;
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
   */;
  /**
   * added for compatibility with DOM Event,
   * deprecated props and methods
   */
  _proto.initEvent = function initEvent() {};
  _proto.initUIEvent = function initUIEvent() {};
  _proto.clone = function clone() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(FederatedEvent, [{
    key: "name",
    get:
    /**
     * The type of event, supports the following:
     * * pointerdown
     * * touchstart
     * * mousedown
     * * rightdown
     * * ...
     */

    /**
     * @deprecated
     */
    function get() {
      return this.type;
    }
    /**
     * The propagation phase.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase
     */
  }, {
    key: "layerX",
    get: function get() {
      return this.layer.x;
    }
  }, {
    key: "layerY",
    get: function get() {
      return this.layer.y;
    }
    /**
     * The coordinates of the event relative to the DOM document.
     * This is a non-standard property.
     * relative to the DOM document.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX
     */
  }, {
    key: "pageX",
    get: function get() {
      return this.page.x;
    }
  }, {
    key: "pageY",
    get: function get() {
      return this.page.y;
    }
    /**
     * relative to Canvas, origin is left-top
     */
  }, {
    key: "x",
    get: function get() {
      return this.canvas.x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.canvas.y;
    }
  }, {
    key: "canvasX",
    get: function get() {
      return this.canvas.x;
    }
  }, {
    key: "canvasY",
    get: function get() {
      return this.canvas.y;
    }
    /**
     * relative to Viewport, account for Camera
     */
  }, {
    key: "viewportX",
    get: function get() {
      return this.viewport.x;
    }
  }, {
    key: "viewportY",
    get: function get() {
      return this.viewport.y;
    }
  }, {
    key: "propagationPath",
    get: function get() {
      return this.composedPath();
    }
  }]);
  return FederatedEvent;
}();

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events
 *
 * @example
  const event = new CustomEvent('build', { detail: { prop1: 'xx' } });
  circle.addEventListener('build', (e) => {
    e.target; // circle
    e.detail; // { prop1: 'xx' }
  });

  circle.dispatchEvent(event);
 */
var CustomEvent = /*#__PURE__*/function (_FederatedEvent) {
  _inheritsLoose(CustomEvent, _FederatedEvent);
  // eslint-disable-next-line @typescript-eslint/ban-types
  function CustomEvent(eventName, object) {
    var _this;
    _this = _FederatedEvent.call(this, null) || this;
    _this.type = eventName;
    _this.detail = object;
    // compatible with G 3.0
    Object.assign(_assertThisInitialized(_this), object);
    return _this;
  }
  return CustomEvent;
}(FederatedEvent);

var DELEGATION_SPLITTER = ':';
/**
 * Objects that can receive events and may have listeners for them.
 * eg. Element, Canvas, DisplayObject
 * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
 */
var EventTarget = /*#__PURE__*/function () {
  function EventTarget() {
    this.emitter = new EventEmitter__default['default']();
  }
  var _proto = EventTarget.prototype;
  /**
   * @deprecated
   * @alias addEventListener
   */
  _proto.on = function on(type, listener, options) {
    this.addEventListener(type, listener, options);
    return this;
  }
  /**
   * support `capture` & `once` in options
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
   */;
  _proto.addEventListener = function addEventListener(type, listener, options) {
    var capture = util.isBoolean(options) && options || util.isObject(options) && options.capture;
    var once = util.isObject(options) && options.once;
    var context = isFunction(listener) ? undefined : listener;
    // compatible with G 3.0
    // support using delegate name in event type, eg. 'node:click'
    var useDelegatedName = false;
    var delegatedName = '';
    if (type.indexOf(DELEGATION_SPLITTER) > -1) {
      var _type$split = type.split(DELEGATION_SPLITTER),
        name = _type$split[0],
        eventType = _type$split[1];
      type = eventType;
      delegatedName = name;
      useDelegatedName = true;
    }
    type = capture ? type + "capture" : type;
    listener = isFunction(listener) ? listener : listener.handleEvent;
    // compatible with G 3.0
    if (useDelegatedName) {
      var originListener = listener;
      listener = function listener() {
        var _args$0$target;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (((_args$0$target = args[0].target) === null || _args$0$target === void 0 ? void 0 : _args$0$target.name) !== delegatedName) {
          return;
        }
        // @ts-ignore
        originListener.apply(void 0, args);
      };
    }
    if (once) {
      this.emitter.once(type, listener, context);
    } else {
      this.emitter.on(type, listener, context);
    }
    return this;
  }
  /**
   * @deprecated
   * @alias removeEventListener
   */;
  _proto.off = function off(type, listener, options) {
    if (type) {
      this.removeEventListener(type, listener, options);
    } else {
      // remove all listeners
      this.removeAllEventListeners();
    }
    return this;
  };
  _proto.removeAllEventListeners = function removeAllEventListeners() {
    this.emitter.removeAllListeners();
  };
  _proto.removeEventListener = function removeEventListener(type, listener, options) {
    var _listener;
    var capture = util.isBoolean(options) && options || util.isObject(options) && options.capture;
    var context = isFunction(listener) ? undefined : listener;
    type = capture ? type + "capture" : type;
    listener = isFunction(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
    this.emitter.off(type, listener, context);
    return this;
  }
  /**
   * @deprecated
   * @alias dispatchEvent
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  ;
  _proto.emit = function emit(eventName, object) {
    this.dispatchEvent(new CustomEvent(eventName, object));
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
   */;
  _proto.dispatchEvent = function dispatchEvent(e, skipPropagate) {
    if (skipPropagate === void 0) {
      skipPropagate = false;
    }
    if (!isFederatedEvent(e)) {
      throw new Error('DisplayObject cannot propagate events outside of the Federated Events API');
    }
    // should account for Element / Document / Canvas
    var canvas;
    // @ts-ignore
    if (this.document) {
      canvas = this;
      // @ts-ignore
    } else if (this.defaultView) {
      canvas = this.defaultView;
    } else {
      var _this$ownerDocument;
      canvas = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.defaultView;
    }
    // assign event manager
    if (canvas) {
      var _e$manager;
      e.manager = canvas.getEventService() || null;
      if (!e.manager) {
        return false;
      }
      e.defaultPrevented = false;
      e.path = [];
      if (!skipPropagate) {
        e.target = this;
      }
      (_e$manager = e.manager) === null || _e$manager === void 0 ? void 0 : _e$manager.dispatchEvent(e, e.type, skipPropagate);
    }
    return !e.defaultPrevented;
  };
  return EventTarget;
}();

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Node
 */
var Node = /*#__PURE__*/function (_EventTarget) {
  _inheritsLoose(Node, _EventTarget);
  function Node() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _EventTarget.call.apply(_EventTarget, [this].concat(args)) || this;
    _this.shadow = false;
    _this.ownerDocument = null;
    _this.isConnected = false;
    _this.baseURI = '';
    _this.childNodes = [];
    _this.nodeType = 0;
    _this.nodeName = '';
    _this.nodeValue = null;
    _this.parentNode = null;
    return _this;
  }
  Node.isNode = function isNode(target) {
    return !!target.childNodes;
  };
  var _proto = Node.prototype;
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
   */
  _proto.getRootNode = function getRootNode(opts) {
    if (opts === void 0) {
      opts = {};
    }
    if (this.parentNode) {
      return this.parentNode.getRootNode(opts);
    }
    if (opts.composed && this.host) {
      return this.host.getRootNode(opts);
    }
    return this;
  };
  _proto.hasChildNodes = function hasChildNodes() {
    return this.childNodes.length > 0;
  };
  _proto.isDefaultNamespace = function isDefaultNamespace(namespace) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.lookupNamespaceURI = function lookupNamespaceURI(prefix) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.lookupPrefix = function lookupPrefix(namespace) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.normalize = function normalize() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
   */;
  _proto.isEqualNode = function isEqualNode(otherNode) {
    // TODO: compare 2 nodes, not sameness
    return this === otherNode;
  };
  _proto.isSameNode = function isSameNode(otherNode) {
    return this.isEqualNode(otherNode);
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ParentNode
   */;
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
   * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
   */
  _proto.compareDocumentPosition = function compareDocumentPosition(other) {
    if (other === this) {
      // same node
      return 0;
    }
    if (!(other instanceof Node)) {
      throw new TypeError('Node.compareDocumentPosition: Argument 1 does not implement interface Node.');
    }
    var node1Root = other;
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    var node2Root = this;
    var node1Hierarchy = [node1Root];
    var node2Hierarchy = [node2Root];
    while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
      var _node1Root$parentNode;
      node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
      node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
    }
    // Check if they don't share the same root node
    if (node1Root !== node2Root) {
      return Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING;
    }
    var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
    var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
    // Check if either is a container of the other
    if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
      return longerHierarchy === node1Hierarchy ?
      // other is a child of this
      Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING :
      // this is a child of other
      Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;
    }
    // Find their first common ancestor and see whether they
    // are preceding or following
    var longerStart = longerHierarchy.length - shorterHierarchy.length;
    for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
      var shorterHierarchyNode = shorterHierarchy[i];
      var longerHierarchyNode = longerHierarchy[longerStart + i];
      // We found the first common ancestor
      if (longerHierarchyNode !== shorterHierarchyNode) {
        var siblings = shorterHierarchyNode.parentNode.childNodes;
        if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
          // Shorter is before longer
          if (shorterHierarchy === node1Hierarchy) {
            // Other is before this
            return Node.DOCUMENT_POSITION_PRECEDING;
          } else {
            // This is before other
            return Node.DOCUMENT_POSITION_FOLLOWING;
          }
        } else {
          // Longer is before shorter
          if (longerHierarchy === node1Hierarchy) {
            // Other is before this
            return Node.DOCUMENT_POSITION_PRECEDING;
          } else {
            // Other is after this
            return Node.DOCUMENT_POSITION_FOLLOWING;
          }
        }
      }
    }
    return Node.DOCUMENT_POSITION_FOLLOWING;
  }
  /**
   * @deprecated
   * @alias contains
   */;
  _proto.contain = function contain(other) {
    return this.contains(other);
  };
  _proto.contains = function contains(other) {
    // the node itself, one of its direct children
    var tmp = other;
    // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/contains
    while (tmp && this !== tmp) {
      tmp = tmp.parentNode;
    }
    return !!tmp;
  };
  _proto.getAncestor = function getAncestor(n) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    var temp = this;
    while (n > 0 && temp) {
      temp = temp.parentNode;
      n--;
    }
    return temp;
  };
  _proto.forEach = function forEach(callback, assigned) {
    if (assigned === void 0) {
      assigned = false;
    }
    if (!callback(this)) {
      (assigned ? this.childNodes.slice() : this.childNodes).forEach(function (child) {
        child.forEach(callback);
      });
    }
  };
  _createClass(Node, [{
    key: "textContent",
    get:
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
     */
    function get() {
      var out = '';
      if (this.nodeName === exports.Shape.TEXT) {
        // @ts-ignore
        out += this.style.text;
      }
      for (var _iterator = _createForOfIteratorHelperLoose(this.childNodes), _step; !(_step = _iterator()).done;) {
        var child = _step.value;
        if (child.nodeName === exports.Shape.TEXT) {
          out += child.nodeValue;
        } else {
          out += child.textContent;
        }
      }
      return out;
    },
    set: function set(content) {
      var _this2 = this;
      // remove all children
      this.childNodes.slice().forEach(function (child) {
        _this2.removeChild(child);
      });
      if (this.nodeName === exports.Shape.TEXT) {
        // @ts-ignore
        this.style.text = "" + content;
      }
    }
  }, {
    key: "parent",
    get:
    /**
     * @deprecated
     * @alias parentNode
     */
    function get() {
      return this.parentNode;
    }
  }, {
    key: "parentElement",
    get: function get() {
      return null;
    }
  }, {
    key: "nextSibling",
    get: function get() {
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      return null;
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
    }
  }]);
  return Node;
}(EventTarget);
Node.DOCUMENT_POSITION_DISCONNECTED = 1;
Node.DOCUMENT_POSITION_PRECEDING = 2;
Node.DOCUMENT_POSITION_FOLLOWING = 4;
Node.DOCUMENT_POSITION_CONTAINS = 8;
Node.DOCUMENT_POSITION_CONTAINED_BY = 16;
Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;

/**
 * the entry of DOM tree
 * Document -> Node -> EventTarget
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document
 */
var Document = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Document, _Node);
  function Document() {
    var _this;
    _this = _Node.call(this) || this;
    _this.defaultView = null;
    _this.documentElement = void 0;
    _this.timeline = void 0;
    _this.ownerDocument = null;
    _this.nodeName = 'document';
    // create timeline
    try {
      _this.timeline = new runtime.AnimationTimeline(_assertThisInitialized(_this));
    } catch (e) {}
    /**
     * for inherited properties, the initial value is used on the root element only,
     * as long as no specified value is supplied.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/initial_value
     */
    var initialStyle = {};
    BUILT_IN_PROPERTIES.forEach(function (_ref) {
      var n = _ref.n,
        inh = _ref.inh,
        d = _ref.d;
      if (inh && d) {
        initialStyle[n] = isFunction(d) ? d(exports.Shape.GROUP) : d;
      }
    });
    // like <html> in DOM tree
    _this.documentElement = new Group({
      id: 'g-root',
      style: initialStyle
    });
    _this.documentElement.ownerDocument = _assertThisInitialized(_this);
    _this.documentElement.parentNode = _assertThisInitialized(_this);
    _this.childNodes = [_this.documentElement];
    return _this;
  }
  var _proto = Document.prototype;
  /**
   * @example const circle = document.createElement('circle', { style: { r: 10 } });
   */
  _proto.createElement = function createElement(tagName, options) {
    // @observablehq/plot will create <svg>
    if (tagName === 'svg') {
      return this.documentElement;
    }
    // d3 will use <tspan>
    var clazz = this.defaultView.customElements.get(tagName);
    if (!clazz) {
      console.warn('Unsupported tagName: ', tagName);
      clazz = tagName === 'tspan' ? Text : Group;
    }
    var shape = new clazz(options);
    shape.ownerDocument = this;
    return shape;
  };
  _proto.createElementNS = function createElementNS(namespaceURI, tagName, options) {
    return this.createElement(tagName, options);
  };
  _proto.cloneNode = function cloneNode(deep) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.destroy = function destroy() {
    try {
      this.documentElement.destroyChildren();
      this.timeline.destroy();
    } catch (e) {}
  }
  /**
   * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
   */;
  _proto.elementsFromBBox = function elementsFromBBox(minX, minY, maxX, maxY) {
    var rBush = this.defaultView.context.rBushRoot;
    var rBushNodes = rBush.search({
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY
    });
    var hitTestList = [];
    rBushNodes.forEach(function (_ref2) {
      var id = _ref2.id;
      var displayObject = runtime.displayObjectPool.getByEntity(id);
      var pointerEvents = displayObject.parsedStyle.pointerEvents;
      // account for `visibility`
      // @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
      var isVisibilityAffected = ['auto', 'visiblepainted', 'visiblefill', 'visiblestroke', 'visible'].includes(pointerEvents);
      if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
        hitTestList.push(displayObject);
      }
    });
    // find group with max z-index
    hitTestList.sort(function (a, b) {
      return b.sortable.renderOrder - a.sortable.renderOrder;
    });
    return hitTestList;
  };
  _proto.elementFromPointSync = function elementFromPointSync(x, y) {
    var _this$defaultView$can = this.defaultView.canvas2Viewport({
        x: x,
        y: y
      }),
      viewportX = _this$defaultView$can.x,
      viewportY = _this$defaultView$can.y;
    var _this$defaultView$get = this.defaultView.getConfig(),
      width = _this$defaultView$get.width,
      height = _this$defaultView$get.height;
    // outside canvas' viewport
    if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
      return null;
    }
    var _this$defaultView$vie = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }),
      clientX = _this$defaultView$vie.x,
      clientY = _this$defaultView$vie.y;
    var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: true,
        position: {
          x: x,
          y: y,
          viewportX: viewportX,
          viewportY: viewportY,
          clientX: clientX,
          clientY: clientY
        },
        picked: []
      }),
      picked = _this$defaultView$get2.picked;
    return picked && picked[0] || this.documentElement;
  }
  /**
   * Do picking with API instead of triggering interactive events.
   *
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
   */;
  _proto.elementFromPoint =
  /*#__PURE__*/
  function () {
    var _elementFromPoint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(x, y) {
      var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                x: x,
                y: y
              }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
              _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height; // outside canvas' viewport
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", null);
            case 4:
              _this$defaultView$vie2 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
              _context.next = 7;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: true,
                position: {
                  x: x,
                  y: y,
                  viewportX: viewportX,
                  viewportY: viewportY,
                  clientX: clientX,
                  clientY: clientY
                },
                picked: []
              });
            case 7:
              _yield$this$defaultVi = _context.sent;
              picked = _yield$this$defaultVi.picked;
              return _context.abrupt("return", picked && picked[0] || this.documentElement);
            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function elementFromPoint(_x, _x2) {
      return _elementFromPoint.apply(this, arguments);
    }
    return elementFromPoint;
  }();
  _proto.elementsFromPointSync = function elementsFromPointSync(x, y) {
    var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
        x: x,
        y: y
      }),
      viewportX = _this$defaultView$can3.x,
      viewportY = _this$defaultView$can3.y;
    var _this$defaultView$get4 = this.defaultView.getConfig(),
      width = _this$defaultView$get4.width,
      height = _this$defaultView$get4.height;
    // outside canvas' viewport
    if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
      return [];
    }
    var _this$defaultView$vie3 = this.defaultView.viewport2Client({
        x: viewportX,
        y: viewportY
      }),
      clientX = _this$defaultView$vie3.x,
      clientY = _this$defaultView$vie3.y;
    var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
        topmost: false,
        position: {
          x: x,
          y: y,
          viewportX: viewportX,
          viewportY: viewportY,
          clientX: clientX,
          clientY: clientY
        },
        picked: []
      }),
      picked = _this$defaultView$get5.picked;
    if (picked[picked.length - 1] !== this.documentElement) {
      picked.push(this.documentElement);
    }
    return picked;
  }
  /**
   * Do picking with API instead of triggering interactive events.
   *
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
   */;
  _proto.elementsFromPoint =
  /*#__PURE__*/
  function () {
    var _elementsFromPoint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(x, y) {
      var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                x: x,
                y: y
              }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
              _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height; // outside canvas' viewport
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("return", []);
            case 4:
              _this$defaultView$vie4 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
              _context2.next = 7;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: false,
                position: {
                  x: x,
                  y: y,
                  viewportX: viewportX,
                  viewportY: viewportY,
                  clientX: clientX,
                  clientY: clientY
                },
                picked: []
              });
            case 7:
              _yield$this$defaultVi2 = _context2.sent;
              picked = _yield$this$defaultVi2.picked;
              if (picked[picked.length - 1] !== this.documentElement) {
                picked.push(this.documentElement);
              }
              return _context2.abrupt("return", picked);
            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function elementsFromPoint(_x3, _x4) {
      return _elementsFromPoint.apply(this, arguments);
    }
    return elementsFromPoint;
  }()
  /**
   * eg. Uncaught DOMException: Failed to execute 'appendChild' on 'Node': Only one element on document allowed.
   */
  ;
  _proto.appendChild = function appendChild(newChild, index) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.removeChild = function removeChild(oldChild, destroy) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.replaceChild = function replaceChild(newChild, oldChild, destroy) {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.append = function append() {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  };
  _proto.prepend = function prepend() {
    throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
  }
  /**
   * Execute query on documentElement.
   */;
  _proto.getElementById = function getElementById(id) {
    return this.documentElement.getElementById(id);
  };
  _proto.getElementsByName = function getElementsByName(name) {
    return this.documentElement.getElementsByName(name);
  };
  _proto.getElementsByTagName = function getElementsByTagName(tagName) {
    return this.documentElement.getElementsByTagName(tagName);
  };
  _proto.getElementsByClassName = function getElementsByClassName(className) {
    return this.documentElement.getElementsByClassName(className);
  };
  _proto.querySelector = function querySelector(selectors) {
    return this.documentElement.querySelector(selectors);
  };
  _proto.querySelectorAll = function querySelectorAll(selectors) {
    return this.documentElement.querySelectorAll(selectors);
  };
  _proto.find = function find(filter) {
    return this.documentElement.find(filter);
  };
  _proto.findAll = function findAll(filter) {
    return this.documentElement.findAll(filter);
  };
  _createClass(Document, [{
    key: "children",
    get: function get() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get() {
      return this.lastChild;
    }
    /**
     * only document has defaultView, points to canvas,
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView
     */
  }]);
  return Document;
}(Node);

/**
 * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
 */
(function (Strategy) {
  Strategy[Strategy["Standard"] = 0] = "Standard";
})(exports.Strategy || (exports.Strategy = {}));

/**
 * built-in events for element
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationEvent
 *
 * TODO: use MutationObserver instead
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
 */
(function (ElementEvent) {
  ElementEvent["REPARENT"] = "reparent";
  ElementEvent["DESTROY"] = "destroy";
  /**
   * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMAttrModified
   */
  ElementEvent["ATTR_MODIFIED"] = "DOMAttrModified";
  /**
   * it has been inserted
   * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeInserted
   */
  ElementEvent["INSERTED"] = "DOMNodeInserted";
  /**
   * it is being removed
   * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeRemoved
   */
  ElementEvent["REMOVED"] = "removed";
  /**
   * @see https://www.w3.org/TR/DOM-Level-3-Events/#domnodeinsertedintodocument
   */
  ElementEvent["MOUNTED"] = "DOMNodeInsertedIntoDocument";
  /**
   * @see https://www.w3.org/TR/DOM-Level-3-Events/#domnoderemovedfromdocument
   */
  ElementEvent["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
  ElementEvent["BOUNDS_CHANGED"] = "bounds-changed";
  // GEOMETRY_BOUNDS_CHANGED = 'geometry-bounds-changed',
  /**
   * trigger when z-index changed
   */
  ElementEvent["RENDER_ORDER_CHANGED"] = "render-order-changed";
  ElementEvent["CULLED"] = "culled";
})(exports.ElementEvent || (exports.ElementEvent = {}));

var MutationEvent = /*#__PURE__*/function (_FederatedEvent) {
  _inheritsLoose(MutationEvent, _FederatedEvent);
  function MutationEvent(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
    var _this;
    _this = _FederatedEvent.call(this, null) || this;
    _this.relatedNode = void 0;
    _this.prevValue = void 0;
    _this.newValue = void 0;
    _this.attrName = void 0;
    _this.attrChange = void 0;
    _this.prevParsedValue = void 0;
    _this.newParsedValue = void 0;
    _this.relatedNode = relatedNode;
    _this.prevValue = prevValue;
    _this.newValue = newValue;
    _this.attrName = attrName;
    _this.attrChange = attrChange;
    _this.prevParsedValue = prevParsedValue;
    _this.newParsedValue = newParsedValue;
    _this.type = typeArg;
    return _this;
  }
  return MutationEvent;
}(FederatedEvent);
MutationEvent.ADDITION = 2;
MutationEvent.MODIFICATION = 1;
MutationEvent.REMOVAL = 3;

var entityCounter = 0;
function resetEntityCounter() {
  entityCounter = 0;
}
var insertedEvent = new MutationEvent(exports.ElementEvent.INSERTED, null, '', '', '', 0, '', '');
var removedEvent = new MutationEvent(exports.ElementEvent.REMOVED, null, '', '', '', 0, '', '');
var destroyEvent = new CustomEvent(exports.ElementEvent.DESTROY);
/**
 * Has following capabilities:
 * * Node insert/remove, eg. appendChild, removeChild, remove...
 * * Query eg. querySelector getElementById...
 * * Animation
 */
var Element = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Element, _Node);
  function Element() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _Node.call.apply(_Node, [this].concat(args)) || this;
    _this.entity = entityCounter++;
    _this.renderable = {
      bounds: undefined,
      boundsDirty: true,
      renderBounds: undefined,
      renderBoundsDirty: true,
      dirtyRenderBounds: undefined,
      dirty: false,
      proxyNodeName: undefined
    };
    _this.cullable = {
      strategy: exports.Strategy.Standard,
      visibilityPlaneMask: -1,
      visible: true,
      enable: true
    };
    _this.transformable = {
      dirtyFlag: false,
      localDirtyFlag: false,
      frozen: false,
      // localPosition: vec3.fromValues(0, 0, 0),
      // localRotation: quat.fromValues(0, 0, 0, 1),
      // localScale: vec3.fromValues(1, 1, 1),
      // localTransform: mat4.create(),
      // localSkew: vec2.fromValues(0, 0),
      // position: vec3.fromValues(0, 0, 0),
      // rotation: quat.fromValues(0, 0, 0, 1),
      // scaling: vec3.fromValues(1, 1, 1),
      // worldTransform: mat4.create(),
      // origin: vec3.fromValues(0, 0, 0),
      localPosition: [0, 0, 0],
      localRotation: [0, 0, 0, 1],
      localScale: [1, 1, 1],
      localTransform: glMatrix.mat4.create(),
      localSkew: [0, 0],
      position: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      scaling: [1, 1, 1],
      worldTransform: glMatrix.mat4.create(),
      origin: [0, 0, 0]
    };
    _this.sortable = {
      dirty: false,
      sorted: undefined,
      lastSortedIndex: undefined,
      renderOrder: 0
    };
    _this.geometry = {
      dirty: false,
      contentBounds: undefined,
      renderBounds: undefined
    };
    _this.rBushNode = {
      aabb: undefined
    };
    _this.id = void 0;
    _this.name = void 0;
    _this.namespaceURI = 'g';
    _this.scrollLeft = 0;
    _this.scrollTop = 0;
    _this.clientTop = 0;
    _this.clientLeft = 0;
    _this.destroyed = false;
    _this.style = {};
    _this.computedStyle = runtime.enableCSSParsing ? {
      anchor: unsetKeywordValue,
      opacity: unsetKeywordValue,
      fillOpacity: unsetKeywordValue,
      strokeOpacity: unsetKeywordValue,
      fill: unsetKeywordValue,
      stroke: unsetKeywordValue,
      transform: unsetKeywordValue,
      transformOrigin: unsetKeywordValue,
      visibility: unsetKeywordValue,
      pointerEvents: unsetKeywordValue,
      lineWidth: unsetKeywordValue,
      lineCap: unsetKeywordValue,
      lineJoin: unsetKeywordValue,
      increasedLineWidthForHitTesting: unsetKeywordValue,
      fontSize: unsetKeywordValue,
      fontFamily: unsetKeywordValue,
      fontStyle: unsetKeywordValue,
      fontWeight: unsetKeywordValue,
      fontVariant: unsetKeywordValue,
      textAlign: unsetKeywordValue,
      textBaseline: unsetKeywordValue,
      textTransform: unsetKeywordValue,
      zIndex: unsetKeywordValue,
      filter: unsetKeywordValue,
      shadowType: unsetKeywordValue
    } : null;
    _this.parsedStyle = {
      // opacity: '',
      // fillOpacity: '',
      // strokeOpacity: '',
      // transformOrigin: '',
      // visibility: '',
      // pointerEvents: '',
      // lineWidth: '',
      // lineCap: '',
      // lineJoin: '',
      // increasedLineWidthForHitTesting: '',
      // fontSize: '',
      // fontFamily: '',
      // fontStyle: '',
      // fontWeight: '',
      // fontVariant: '',
      // textAlign: '',
      // textBaseline: '',
      // textTransform: '',
    };
    _this.attributes = {};
    return _this;
  }
  Element.isElement = function isElement(target) {
    return !!target.getAttribute;
  }
  /**
   * Unique id.
   */;
  var _proto = Element.prototype;
  _proto.cloneNode = function cloneNode(deep) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.appendChild = function appendChild(child, index) {
    var _this$ownerDocument;
    if (child.destroyed) {
      throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
    }
    runtime.sceneGraphService.attach(child, this, index);
    if ((_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.defaultView) {
      this.ownerDocument.defaultView.mountChildren(child);
    }
    insertedEvent.relatedNode = this;
    child.dispatchEvent(insertedEvent);
    return child;
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    if (!refChild) {
      this.appendChild(newChild);
    } else {
      var index = this.childNodes.indexOf(refChild);
      this.appendChild(newChild, index - 1);
    }
    return newChild;
  };
  _proto.replaceChild = function replaceChild(newChild, oldChild) {
    var index = this.childNodes.indexOf(oldChild);
    this.removeChild(oldChild);
    this.appendChild(newChild, index);
    return oldChild;
  };
  _proto.removeChild = function removeChild(child) {
    var _child$ownerDocument;
    // should emit on itself before detach
    removedEvent.relatedNode = this;
    child.dispatchEvent(removedEvent);
    if ((_child$ownerDocument = child.ownerDocument) === null || _child$ownerDocument === void 0 ? void 0 : _child$ownerDocument.defaultView) {
      child.ownerDocument.defaultView.unmountChildren(child);
    }
    // remove from scene graph
    runtime.sceneGraphService.detach(child);
    return child;
  }
  /**
   * Remove all children which can be appended to its original parent later again.
   */;
  _proto.removeChildren = function removeChildren() {
    for (var i = this.childNodes.length - 1; i >= 0; i--) {
      var child = this.childNodes[i];
      this.removeChild(child);
    }
  }
  /**
   * Recursively destroy all children which can not be appended to its original parent later again.
   */;
  _proto.destroyChildren = function destroyChildren() {
    for (var i = this.childNodes.length - 1; i >= 0; i--) {
      var child = this.childNodes[i];
      if (child.childNodes.length) {
        child.destroyChildren();
      }
      child.destroy();
    }
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
   */;
  _proto.matches = function matches(selector) {
    return runtime.sceneGraphService.matches(selector, this);
  };
  _proto.getElementById = function getElementById(id) {
    return runtime.sceneGraphService.querySelector("#" + id, this);
  };
  _proto.getElementsByName = function getElementsByName(name) {
    return runtime.sceneGraphService.querySelectorAll("[name=\"" + name + "\"]", this);
  };
  _proto.getElementsByClassName = function getElementsByClassName(className) {
    return runtime.sceneGraphService.querySelectorAll("." + className, this);
  };
  _proto.getElementsByTagName = function getElementsByTagName(tagName) {
    return runtime.sceneGraphService.querySelectorAll(tagName, this);
  };
  _proto.querySelector = function querySelector(selectors) {
    return runtime.sceneGraphService.querySelector(selectors, this);
  };
  _proto.querySelectorAll = function querySelectorAll(selectors) {
    return runtime.sceneGraphService.querySelectorAll(selectors, this);
  }
  /**
   * should traverses the element and its parents (heading toward the document root)
   * until it finds a node that matches the specified CSS selector.
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
   */;
  _proto.closest = function closest(selectors) {
    var el = this;
    do {
      if (runtime.sceneGraphService.matches(selectors, el)) return el;
      el = el.parentElement;
    } while (el !== null);
    return null;
  }
  /**
   * search in scene group, but should not include itself
   */;
  _proto.find = function find(filter) {
    var _this2 = this;
    var target = null;
    this.forEach(function (object) {
      if (object !== _this2 && filter(object)) {
        target = object;
        return true;
      }
      return false;
    });
    return target;
  };
  _proto.findAll = function findAll(filter) {
    var _this3 = this;
    var objects = [];
    this.forEach(function (object) {
      if (object !== _this3 && filter(object)) {
        objects.push(object);
      }
    });
    return objects;
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
   */;
  _proto.after = function after() {
    var _this4 = this;
    if (this.parentNode) {
      var index = this.parentNode.childNodes.indexOf(this);
      for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        nodes[_key2] = arguments[_key2];
      }
      nodes.forEach(function (node, i) {
        var _this4$parentNode;
        return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index + i + 1);
      });
    }
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
   */;
  _proto.before = function before() {
    if (this.parentNode) {
      var index = this.parentNode.childNodes.indexOf(this);
      for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        nodes[_key3] = arguments[_key3];
      }
      var first = nodes[0],
        rest = nodes.slice(1);
      this.parentNode.appendChild(first, index);
      first.after.apply(first, rest);
    }
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
   */;
  _proto.replaceWith = function replaceWith() {
    this.after.apply(this, arguments);
    this.remove();
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
   */;
  _proto.append = function append() {
    var _this5 = this;
    for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      nodes[_key4] = arguments[_key4];
    }
    nodes.forEach(function (node) {
      return _this5.appendChild(node);
    });
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
   */;
  _proto.prepend = function prepend() {
    var _this6 = this;
    for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      nodes[_key5] = arguments[_key5];
    }
    nodes.forEach(function (node, i) {
      return _this6.appendChild(node, i);
    });
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
   */;
  _proto.replaceChildren = function replaceChildren() {
    while (this.childNodes.length && this.firstChild) {
      this.removeChild(this.firstChild);
    }
    this.append.apply(this, arguments);
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
   */;
  _proto.remove = function remove() {
    if (this.parentNode) {
      return this.parentNode.removeChild(this);
    }
    return this;
  }
  /**
   * is destroyed or not
   */;
  _proto.destroy = function destroy() {
    // destroy itself before remove
    this.dispatchEvent(destroyEvent);
    // remove from scenegraph first
    this.remove();
    // remove event listeners
    this.emitter.removeAllListeners();
    this.destroyed = true;
  };
  _proto.getGeometryBounds = function getGeometryBounds() {
    return runtime.sceneGraphService.getGeometryBounds(this);
  };
  _proto.getRenderBounds = function getRenderBounds() {
    return runtime.sceneGraphService.getBounds(this, true);
  }
  /**
   * get bounds in world space, account for children
   */;
  _proto.getBounds = function getBounds() {
    return runtime.sceneGraphService.getBounds(this);
  }
  /**
   * get bounds in local space, account for children
   */;
  _proto.getLocalBounds = function getLocalBounds() {
    return runtime.sceneGraphService.getLocalBounds(this);
  }
  /**
   * account for context's bounds in client space,
   * but not accounting for children
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
   */;
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    return runtime.sceneGraphService.getBoundingClientRect(this);
  }
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
   */;
  _proto.getClientRects = function getClientRects() {
    return [this.getBoundingClientRect()];
  }
  /**
   * compatible with `style`
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
   */;
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
   * eg. circle.computedStyleMap().get('fill');
   */
  _proto.computedStyleMap = function computedStyleMap() {
    return new Map(Object.entries(this.computedStyle));
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes
   */;
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
   */
  _proto.getAttributeNames = function getAttributeNames() {
    return Object.keys(this.attributes);
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
   */;
  _proto.getAttribute = function getAttribute(name) {
    // @see https://github.com/antvis/G/issues/1267
    if (isSymbol(name)) {
      return runtime.enableCSSParsing ? null : undefined;
    }
    var value = this.attributes[name];
    if (value === undefined) {
      var attributeName = formatAttributeName(name);
      value = this.attributes[attributeName];
      // if the given attribute does not exist, the value returned will either be null or ""
      return runtime.enableCSSParsing ? util.isNil(value) ? null : value : value;
    } else {
      return value;
    }
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
   */;
  _proto.hasAttribute = function hasAttribute(qualifiedName) {
    return this.getAttributeNames().includes(qualifiedName);
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
   */;
  _proto.hasAttributes = function hasAttributes() {
    return !!this.getAttributeNames().length;
  }
  /**
   * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
   */;
  _proto.removeAttribute = function removeAttribute(attributeName) {
    this.setAttribute(attributeName, null);
    delete this.attributes[attributeName];
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
   */;
  _proto.setAttribute = function setAttribute(attributeName, value, force) {
    this.attributes[attributeName] = value;
  };
  _proto.getAttributeNS = function getAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.getAttributeNode = function getAttributeNode(qualifiedName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.getAttributeNodeNS = function getAttributeNodeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.hasAttributeNS = function hasAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.removeAttributeNS = function removeAttributeNS(namespace, localName) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.removeAttributeNode = function removeAttributeNode(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNS = function setAttributeNS(namespace, qualifiedName, value) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNode = function setAttributeNode(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.setAttributeNodeNS = function setAttributeNodeNS(attr) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.toggleAttribute = function toggleAttribute(qualifiedName, force) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(Element, [{
    key: "className",
    get:
    /**
     * used in `getElementsByClassName`
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     */
    function get() {
      // @ts-ignore
      return this.getAttribute('class') || '';
    },
    set: function set(className) {
      this.setAttribute('class', className);
    }
    /**
     * used in `getElementsByName`
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
     */
  }, {
    key: "classList",
    get:
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
     */
    function get() {
      return this.className.split(' ').filter(function (c) {
        return c !== '';
      });
    }
  }, {
    key: "tagName",
    get: function get() {
      return this.nodeName;
    }
  }, {
    key: "children",
    get: function get() {
      return this.childNodes;
    }
  }, {
    key: "childElementCount",
    get: function get() {
      return this.childNodes.length;
    }
  }, {
    key: "firstElementChild",
    get: function get() {
      return this.firstChild;
    }
  }, {
    key: "lastElementChild",
    get: function get() {
      return this.lastChild;
    }
  }, {
    key: "parentElement",
    get: function get() {
      return this.parentNode;
    }
  }, {
    key: "nextSibling",
    get: function get() {
      if (this.parentNode) {
        var index = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index + 1] || null;
      }
      return null;
    }
  }, {
    key: "previousSibling",
    get: function get() {
      if (this.parentNode) {
        var index = this.parentNode.childNodes.indexOf(this);
        return this.parentNode.childNodes[index - 1] || null;
      }
      return null;
    }
  }]);
  return Element;
}(Node);

var FederatedMouseEvent = /*#__PURE__*/function (_FederatedEvent) {
  _inheritsLoose(FederatedMouseEvent, _FederatedEvent);
  function FederatedMouseEvent() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _FederatedEvent.call.apply(_FederatedEvent, [this].concat(args)) || this;
    _this.altKey = void 0;
    _this.button = void 0;
    _this.buttons = void 0;
    _this.ctrlKey = void 0;
    _this.metaKey = void 0;
    _this.relatedTarget = void 0;
    _this.shiftKey = void 0;
    _this.client = new Point();
    _this.movement = new Point();
    _this.offset = new Point();
    _this.global = new Point();
    _this.screen = new Point();
    return _this;
  }
  var _proto = FederatedMouseEvent.prototype;
  _proto.getModifierState = function getModifierState(key) {
    return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);
  };
  _proto.initMouseEvent = function initMouseEvent() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _createClass(FederatedMouseEvent, [{
    key: "clientX",
    get: function get() {
      return this.client.x;
    }
  }, {
    key: "clientY",
    get: function get() {
      return this.client.y;
    }
    /**
     * The movement in this pointer relative to the last `mousemove` event.
     */
  }, {
    key: "movementX",
    get: function get() {
      return this.movement.x;
    }
  }, {
    key: "movementY",
    get: function get() {
      return this.movement.y;
    }
    /**
     * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is
     * not supported at the moment.
     */
  }, {
    key: "offsetX",
    get: function get() {
      return this.offset.x;
    }
  }, {
    key: "offsetY",
    get: function get() {
      return this.offset.y;
    }
    /**
     * The pointer coordinates in world space.
     */
  }, {
    key: "globalX",
    get: function get() {
      return this.global.x;
    }
  }, {
    key: "globalY",
    get: function get() {
      return this.global.y;
    }
    /**
     * The pointer coordinates in sceen space.
     */
  }, {
    key: "screenX",
    get: function get() {
      return this.screen.x;
    }
  }, {
    key: "screenY",
    get: function get() {
      return this.screen.y;
    }
  }]);
  return FederatedMouseEvent;
}(FederatedEvent);

var FederatedPointerEvent = /*#__PURE__*/function (_FederatedMouseEvent) {
  _inheritsLoose(FederatedPointerEvent, _FederatedMouseEvent);
  function FederatedPointerEvent() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _FederatedMouseEvent.call.apply(_FederatedMouseEvent, [this].concat(args)) || this;
    _this.pointerId = void 0;
    _this.width = 0;
    _this.height = 0;
    _this.isPrimary = false;
    _this.pointerType = void 0;
    _this.pressure = void 0;
    _this.tangentialPressure = void 0;
    _this.tiltX = void 0;
    _this.tiltY = void 0;
    _this.twist = void 0;
    return _this;
  }
  var _proto = FederatedPointerEvent.prototype;
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
   */
  _proto.getCoalescedEvents = function getCoalescedEvents() {
    if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove') {
      return [this];
    }
    return [];
  }
  /**
   * @see https://chromestatus.com/feature/5765569655603200
   */;
  _proto.getPredictedEvents = function getPredictedEvents() {
    throw new Error('getPredictedEvents is not supported!');
  }
  /**
   * @see https://github.com/antvis/G/issues/1115
   * We currently reuses event objects in the event system,
   * avoiding the creation of a large number of event objects.
   * Reused objects are only used to carry different data,
   * such as coordinate information, native event objects,
   * and therefore the lifecycle is limited to the event handler,
   * which can lead to unintended consequences if an attempt is made to cache the entire event object.
   *
   * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
   */;
  _proto.clone = function clone() {
    return this.manager.clonePointerEvent(this);
  };
  return FederatedPointerEvent;
}(FederatedMouseEvent);

var FederatedWheelEvent = /*#__PURE__*/function (_FederatedMouseEvent) {
  _inheritsLoose(FederatedWheelEvent, _FederatedMouseEvent);
  function FederatedWheelEvent() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _FederatedMouseEvent.call.apply(_FederatedMouseEvent, [this].concat(args)) || this;
    _this.deltaMode = void 0;
    _this.deltaX = void 0;
    _this.deltaY = void 0;
    _this.deltaZ = void 0;
    _this.DOM_DELTA_LINE = 0;
    _this.DOM_DELTA_PAGE = 1;
    _this.DOM_DELTA_PIXEL = 2;
    return _this;
  }
  var _proto = FederatedWheelEvent.prototype;
  _proto.clone = function clone() {
    return this.manager.cloneWheelEvent(this);
  };
  return FederatedWheelEvent;
}(FederatedMouseEvent);

function isDisplayObject(value) {
  return !!(value === null || value === void 0 ? void 0 : value.nodeName);
}
var mutationEvent = new MutationEvent(exports.ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
var DEFAULT_STYLE_PROPS = {
  anchor: '',
  opacity: '',
  fillOpacity: '',
  strokeOpacity: '',
  fill: '',
  stroke: '',
  transform: '',
  transformOrigin: '',
  visibility: '',
  pointerEvents: '',
  lineWidth: '',
  lineCap: '',
  lineJoin: '',
  increasedLineWidthForHitTesting: '',
  fontSize: '',
  fontFamily: '',
  fontStyle: '',
  fontWeight: '',
  fontVariant: '',
  textAlign: '',
  textBaseline: '',
  textTransform: '',
  zIndex: '',
  filter: '',
  shadowType: ''
};
var DEFAULT_PARSED_STYLE_PROPS = {
  anchor: [0, 0],
  fill: noneColor,
  stroke: noneColor,
  transform: [],
  zIndex: 0,
  filter: [],
  shadowType: 'outer',
  miterLimit: 10
};
var DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED = _extends({}, DEFAULT_PARSED_STYLE_PROPS, {
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  visibility: 'visible',
  pointerEvents: 'auto',
  lineWidth: 1,
  lineCap: 'butt',
  lineJoin: 'miter',
  increasedLineWidthForHitTesting: 0,
  fillRule: 'nonzero'
  // TODO: transformOrigin
});

var INHERITABLE_BASE_STYLE_PROPS = ['opacity', 'fillOpacity', 'strokeOpacity', 'transformOrigin', 'visibility', 'pointerEvents', 'lineWidth', 'lineCap', 'lineJoin', 'increasedLineWidthForHitTesting'];
var INHERITABLE_STYLE_PROPS = [].concat(INHERITABLE_BASE_STYLE_PROPS, ['fontSize', 'fontFamily', 'fontStyle', 'fontWeight', 'fontVariant', 'textAlign', 'textBaseline', 'textTransform']);
var DATASET_PREFIX = 'data-';
/**
 * prototype chains: DisplayObject -> Element -> Node -> EventTarget
 *
 * mixins: Animatable, Transformable, Visible
 * @see https://github.com/tannerntannern/ts-mixer/blob/master/README.md#mixing-generic-classes
 *
 * Provide abilities in scene graph, such as:
 * * transform `translate/rotate/scale`
 * * add/remove child
 * * visibility and z-index
 *
 * Those abilities are implemented with those components: `Transform/Sortable/Visible`.
 *
 * Emit following events:
 * * init
 * * destroy
 * * attributeChanged
 */
var DisplayObject = /*#__PURE__*/function (_Element) {
  _inheritsLoose(DisplayObject, _Element);
  /**
   * contains style props in constructor's params, eg. fill, stroke...
   */

  /**
   * push to active animations after calling `animate()`
   */

  /**
   * Use data-* attribute.
   * @see https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes
   * @example
   * group.dataset.prop1 = 1;
   * group.getAttribute('data-prop1'); // 1
   */

  function DisplayObject(config) {
    var _this$config$capture;
    var _this;
    _this = _Element.call(this) || this;
    // assign name, id to config
    // eg. group.get('name')
    _this.config = void 0;
    _this.isCustomElement = false;
    _this.isMutationObserved = false;
    _this.activeAnimations = [];
    _this.dataset = void 0;
    _this.getClip = function () {
      return this.style.clipPath || null;
    };
    _this.config = config;
    // compatible with G 3.0
    _this.config.interactive = (_this$config$capture = _this.config.capture) !== null && _this$config$capture !== void 0 ? _this$config$capture : _this.config.interactive;
    // init scene graph node
    _this.id = _this.config.id || '';
    _this.name = _this.config.name || '';
    if (_this.config.className || _this.config.class) {
      _this.className = _this.config.className || _this.config.class;
    }
    _this.nodeName = _this.config.type || exports.Shape.GROUP;
    // compatible with G 3.0
    _this.config.style = _this.config.style || _this.config.attrs || {};
    Object.assign(_this.config.style, _this.config.attrs);
    // this.config.style = {
    //   // ...DEFAULT_STYLE_PROPS,
    //   ...this.config.style,
    //   ...this.config.attrs,
    // };
    if (_this.config.visible != null) {
      _this.config.style.visibility = _this.config.visible === false ? 'hidden' : 'visible';
    }
    if (_this.config.interactive != null) {
      _this.config.style.pointerEvents = _this.config.interactive === false ? 'none' : 'auto';
    }
    // merge parsed value
    Object.assign(_this.parsedStyle, runtime.enableCSSParsing ? DEFAULT_PARSED_STYLE_PROPS : DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED, _this.config.initialParsedStyle);
    if (runtime.enableCSSParsing) {
      Object.assign(_this.attributes, DEFAULT_STYLE_PROPS);
    }
    // start to process attributes
    _this.initAttributes(_this.config.style);
    _this.dataset = new Proxy({}, {
      get: function get(target, name) {
        var formattedName = "" + DATASET_PREFIX + kebabize(name);
        if (target[formattedName] !== undefined) {
          return target[formattedName];
        }
        return _this.getAttribute(formattedName);
      },
      set: function set(_, prop, value) {
        _this.setAttribute("" + DATASET_PREFIX + kebabize(prop), value);
        return true;
      }
    });
    _this.style = new Proxy(
    // @ts-ignore
    {
      // ...this.attributes,
      setProperty: function setProperty(propertyName, value) {
        _this.setAttribute(propertyName, value);
      },
      getPropertyValue: function getPropertyValue(propertyName) {
        return _this.getAttribute(propertyName);
      },
      removeProperty: function removeProperty(propertyName) {
        _this.removeAttribute(propertyName);
      },
      item: function item() {
        return '';
      }
    }, {
      get: function get(target, name) {
        if (target[name] !== undefined) {
          // if (name in target) {
          return target[name];
        }
        return _this.getAttribute(name);
      },
      set: function set(_, prop, value) {
        _this.setAttribute(prop, value);
        return true;
      }
    });
    // insert this group into pool
    runtime.displayObjectPool.add(_this.entity, _assertThisInitialized(_this));
    return _this;
  }
  var _proto = DisplayObject.prototype;
  _proto.destroy = function destroy() {
    _Element.prototype.destroy.call(this);
    // remove from pool
    runtime.displayObjectPool.remove(this.entity);
    // stop all active animations
    this.getAnimations().forEach(function (animation) {
      animation.cancel();
    });
    // FIXME
    // this.renderable = null;
    // this.cullable = null;
    // this.transformable = null;
    // this.rBushNode = null;
    // this.geometry = null;
    // this.sortable = null;
  };
  _proto.cloneNode = function cloneNode(deep, customCloneFunc) {
    var clonedStyle = _extends({}, this.attributes);
    for (var attributeName in clonedStyle) {
      var attribute = clonedStyle[attributeName];
      // @see https://github.com/antvis/G/issues/1095
      if (isDisplayObject(attribute) &&
      // share the same clipPath if possible
      attributeName !== 'clipPath' && attributeName !== 'offsetPath' && attributeName !== 'textPath') {
        clonedStyle[attributeName] = attribute.cloneNode(deep);
      }
      // TODO: clone other type
      if (customCloneFunc) {
        clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
      }
    }
    var cloned = new this.constructor({
      // copy id & name
      // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode#notes
      id: this.id,
      name: this.name,
      className: this.name,
      interactive: this.interactive,
      style: clonedStyle
    });
    // apply transform
    cloned.setLocalTransform(this.getLocalTransform());
    if (deep) {
      this.children.forEach(function (child) {
        // skip marker
        if (!child.style.isMarker) {
          var clonedChild = child.cloneNode(deep);
          cloned.appendChild(clonedChild);
        }
      });
    }
    return cloned;
  };
  _proto.initAttributes = function initAttributes(attributes) {
    if (attributes === void 0) {
      attributes = {};
    }
    var renderable = this.renderable;
    var options = {
      forceUpdateGeometry: true
      // usedAttributes:
      //   // only Group / Text should account for text relative props
      //   this.tagName === Shape.GROUP || this.tagName === Shape.TEXT
      //     ? INHERITABLE_STYLE_PROPS
      //     : INHERITABLE_BASE_STYLE_PROPS,
    };

    if (runtime.enableCSSParsing) {
      // @ts-ignore
      options.usedAttributes = INHERITABLE_STYLE_PROPS;
    }
    // account for FCP, process properties as less as possible
    runtime.styleValueRegistry.processProperties(this, attributes, options);
    // redraw at next frame
    renderable.dirty = true;
  };
  _proto.setAttribute = function setAttribute(name, value, force) {
    if (force === void 0) {
      force = false;
    }
    var attributeName = formatAttributeName(name);
    // ignore undefined value
    if (util.isUndefined(value)) {
      return;
    }
    if (force || value !== this.attributes[attributeName]) {
      this.internalSetAttribute(attributeName, value);
      _Element.prototype.setAttribute.call(this, attributeName, value);
    }
  }
  /**
   * called when attributes get changed or initialized
   */;
  _proto.internalSetAttribute = function internalSetAttribute(name, value, parseOptions) {
    var _runtime$styleValueRe;
    if (parseOptions === void 0) {
      parseOptions = {};
    }
    var renderable = this.renderable;
    var oldValue = this.attributes[name];
    var oldParsedValue = this.parsedStyle[name];
    runtime.styleValueRegistry.processProperties(this, (_runtime$styleValueRe = {}, _runtime$styleValueRe[name] = value, _runtime$styleValueRe), parseOptions);
    // redraw at next frame
    renderable.dirty = true;
    var newParsedValue = this.parsedStyle[name];
    if (this.isConnected) {
      mutationEvent.relatedNode = this;
      mutationEvent.prevValue = oldValue;
      mutationEvent.newValue = value;
      mutationEvent.attrName = name;
      mutationEvent.prevParsedValue = oldParsedValue;
      mutationEvent.newParsedValue = newParsedValue;
      if (this.isMutationObserved) {
        this.dispatchEvent(mutationEvent);
      } else {
        mutationEvent.target = this;
        this.ownerDocument.defaultView.dispatchEvent(mutationEvent, true);
      }
    }
    if ((this.isCustomElement && this.isConnected || !this.isCustomElement) && this.attributeChangedCallback) {
      this.attributeChangedCallback(name, oldValue, value, oldParsedValue, newParsedValue);
    }
  }
  // #region transformable
  /**
   * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
   * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
   *
   * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
   * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
   */;
  _proto.getBBox = function getBBox() {
    var aabb = this.getBounds();
    var _aabb$getMin = aabb.getMin(),
      left = _aabb$getMin[0],
      top = _aabb$getMin[1];
    var _aabb$getMax = aabb.getMax(),
      right = _aabb$getMax[0],
      bottom = _aabb$getMax[1];
    return new Rectangle(left, top, right - left, bottom - top);
  };
  _proto.setOrigin = function setOrigin(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setOrigin(this, createVec3(position, y, z));
    return this;
  };
  _proto.getOrigin = function getOrigin() {
    return runtime.sceneGraphService.getOrigin(this);
  }
  /**
   * set position in world space
   */;
  _proto.setPosition = function setPosition(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setPosition(this, createVec3(position, y, z));
    return this;
  }
  /**
   * set position in local space
   */;
  _proto.setLocalPosition = function setLocalPosition(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y, z));
    return this;
  }
  /**
   * translate in world space
   */;
  _proto.translate = function translate(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.translate(this, createVec3(position, y, z));
    return this;
  }
  /**
   * translate in local space
   */;
  _proto.translateLocal = function translateLocal(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    runtime.sceneGraphService.translateLocal(this, createVec3(position, y, z));
    return this;
  };
  _proto.getPosition = function getPosition() {
    return runtime.sceneGraphService.getPosition(this);
  };
  _proto.getLocalPosition = function getLocalPosition() {
    return runtime.sceneGraphService.getLocalPosition(this);
  }
  /**
   * compatible with G 3.0
   *
   * scaling in local space
   * scale(10) = scale(10, 10, 10)
   *
   * we can't set scale in world space
   */;
  _proto.scale = function scale(scaling, y, z) {
    return this.scaleLocal(scaling, y, z);
  };
  _proto.scaleLocal = function scaleLocal(scaling, y, z) {
    if (typeof scaling === 'number') {
      y = y || scaling;
      z = z || scaling;
      scaling = createVec3(scaling, y, z);
    }
    runtime.sceneGraphService.scaleLocal(this, scaling);
    return this;
  }
  /**
   * set scaling in local space
   */;
  _proto.setLocalScale = function setLocalScale(scaling, y, z) {
    if (typeof scaling === 'number') {
      y = y || scaling;
      z = z || scaling;
      scaling = createVec3(scaling, y, z);
    }
    runtime.sceneGraphService.setLocalScale(this, scaling);
    return this;
  }
  /**
   * get scaling in local space
   */;
  _proto.getLocalScale = function getLocalScale() {
    return runtime.sceneGraphService.getLocalScale(this);
  }
  /**
   * get scaling in world space
   */;
  _proto.getScale = function getScale() {
    return runtime.sceneGraphService.getScale(this);
  }
  /**
   * only return degrees of Z axis in world space
   */;
  _proto.getEulerAngles = function getEulerAngles() {
    var _getEuler = getEuler(glMatrix.vec3.create(), runtime.sceneGraphService.getWorldTransform(this)),
      ez = _getEuler[2];
    return rad2deg(ez);
  }
  /**
   * only return degrees of Z axis in local space
   */;
  _proto.getLocalEulerAngles = function getLocalEulerAngles() {
    var _getEuler2 = getEuler(glMatrix.vec3.create(), runtime.sceneGraphService.getLocalRotation(this)),
      ez = _getEuler2[2];
    return rad2deg(ez);
  }
  /**
   * set euler angles(degrees) in world space
   */;
  _proto.setEulerAngles = function setEulerAngles(z) {
    runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
    return this;
  }
  /**
   * set euler angles(degrees) in local space
   */;
  _proto.setLocalEulerAngles = function setLocalEulerAngles(z) {
    runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
    return this;
  };
  _proto.rotateLocal = function rotateLocal(x, y, z) {
    if (util.isNil(y) && util.isNil(z)) {
      runtime.sceneGraphService.rotateLocal(this, 0, 0, x);
    } else {
      runtime.sceneGraphService.rotateLocal(this, x, y, z);
    }
    return this;
  };
  _proto.rotate = function rotate(x, y, z) {
    if (util.isNil(y) && util.isNil(z)) {
      runtime.sceneGraphService.rotate(this, 0, 0, x);
    } else {
      runtime.sceneGraphService.rotate(this, x, y, z);
    }
    return this;
  };
  _proto.setRotation = function setRotation(rotation, y, z, w) {
    runtime.sceneGraphService.setRotation(this, rotation, y, z, w);
    return this;
  };
  _proto.setLocalRotation = function setLocalRotation(rotation, y, z, w) {
    runtime.sceneGraphService.setLocalRotation(this, rotation, y, z, w);
    return this;
  };
  _proto.setLocalSkew = function setLocalSkew(skew, y) {
    runtime.sceneGraphService.setLocalSkew(this, skew, y);
    return this;
  };
  _proto.getRotation = function getRotation() {
    return runtime.sceneGraphService.getRotation(this);
  };
  _proto.getLocalRotation = function getLocalRotation() {
    return runtime.sceneGraphService.getLocalRotation(this);
  };
  _proto.getLocalSkew = function getLocalSkew() {
    return runtime.sceneGraphService.getLocalSkew(this);
  };
  _proto.getLocalTransform = function getLocalTransform() {
    return runtime.sceneGraphService.getLocalTransform(this);
  };
  _proto.getWorldTransform = function getWorldTransform() {
    return runtime.sceneGraphService.getWorldTransform(this);
  };
  _proto.setLocalTransform = function setLocalTransform(transform) {
    runtime.sceneGraphService.setLocalTransform(this, transform);
    return this;
  };
  _proto.resetLocalTransform = function resetLocalTransform() {
    runtime.sceneGraphService.resetLocalTransform(this);
  }
  // #endregion transformable
  // #region animatable
  /**
   * returns an array of all Animation objects affecting this element
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
   */;
  _proto.getAnimations = function getAnimations() {
    return this.activeAnimations;
  }
  /**
   * create an animation with WAAPI
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
   */;
  _proto.animate = function animate(keyframes, options) {
    var _this$ownerDocument;
    var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
    if (timeline) {
      return timeline.play(this, keyframes, options);
    }
    return null;
  }
  // #endregion animatable
  // #region visible
  /**
   * shortcut for Used value of `visibility`
   */;
  _proto.isVisible = function isVisible() {
    var _this$parsedStyle;
    return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) === 'visible';
  };
  _proto.isInteractive = function isInteractive() {
    var _this$parsedStyle2;
    return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== 'none';
  };
  _proto.isCulled = function isCulled() {
    return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
  }
  /**
   * bring to front in current group
   */;
  _proto.toFront = function toFront() {
    if (this.parentNode) {
      this.style.zIndex = Math.max.apply(Math, this.parentNode.children.map(function (child) {
        return Number(child.style.zIndex);
      })) + 1;
    }
    return this;
  }
  /**
   * send to back in current group
   */;
  _proto.toBack = function toBack() {
    if (this.parentNode) {
      this.style.zIndex = Math.min.apply(Math, this.parentNode.children.map(function (child) {
        return Number(child.style.zIndex);
      })) - 1;
    }
    return this;
  }
  // #endregion visible
  // #region deprecated
  /**
   * compatible with G 3.0
   * @alias object.config
   * @deprecated
   */;
  _proto.getConfig = function getConfig() {
    return this.config;
  };
  _proto.attr = function attr() {
    var _this2 = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var name = args[0],
      value = args[1];
    if (!name) {
      return this.attributes;
    }
    if (util.isObject(name)) {
      Object.keys(name).forEach(function (key) {
        _this2.setAttribute(key, name[key]);
      });
      return this;
    }
    if (args.length === 2) {
      this.setAttribute(name, value);
      return this;
    }
    return this.attributes[name];
  }
  /**
   * return 3x3 matrix in world space
   * @deprecated
   */;
  _proto.getMatrix = function getMatrix(transformMat4) {
    var transform = transformMat4 || this.getWorldTransform();
    var _mat4$getTranslation = glMatrix.mat4.getTranslation(glMatrix.vec3.create(), transform),
      tx = _mat4$getTranslation[0],
      ty = _mat4$getTranslation[1];
    var _mat4$getScaling = glMatrix.mat4.getScaling(glMatrix.vec3.create(), transform),
      sx = _mat4$getScaling[0],
      sy = _mat4$getScaling[1];
    var rotation = glMatrix.mat4.getRotation(glMatrix.quat.create(), transform);
    var _getEuler3 = getEuler(glMatrix.vec3.create(), rotation),
      eux = _getEuler3[0],
      euz = _getEuler3[2];
    // gimbal lock at 90 degrees
    return fromRotationTranslationScale(eux || euz, tx, ty, sx, sy);
  }
  /**
   * return 3x3 matrix in local space
   * @deprecated
   */;
  _proto.getLocalMatrix = function getLocalMatrix() {
    return this.getMatrix(this.getLocalTransform());
  }
  /**
   * set 3x3 matrix in world space
   * @deprecated
   */;
  _proto.setMatrix = function setMatrix(mat) {
    var _decompose = decompose(mat),
      tx = _decompose[0],
      ty = _decompose[1],
      scalingX = _decompose[2],
      scalingY = _decompose[3],
      angle = _decompose[4];
    this.setEulerAngles(angle).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
  }
  /**
   * set 3x3 matrix in local space
   * @deprecated
   */;
  _proto.setLocalMatrix = function setLocalMatrix(mat) {
    var _decompose2 = decompose(mat),
      tx = _decompose2[0],
      ty = _decompose2[1],
      scalingX = _decompose2[2],
      scalingY = _decompose2[3],
      angle = _decompose2[4];
    this.setLocalEulerAngles(angle).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
  }
  /**
   * Use `visibility: visible` instead.
   * @deprecated
   */;
  _proto.show = function show() {
    if (runtime.enableCSSParsing) {
      this.style.visibility = 'visible';
    } else {
      this.forEach(function (object) {
        object.style.visibility = 'visible';
      });
    }
  }
  /**
   * Use `visibility: hidden` instead.
   * @deprecated
   */;
  _proto.hide = function hide() {
    if (runtime.enableCSSParsing) {
      this.style.visibility = 'hidden';
    } else {
      this.forEach(function (object) {
        object.style.visibility = 'hidden';
      });
    }
  }
  /**
   * Use `childElementCount` instead.
   * @deprecated
   */;
  _proto.getCount = function getCount() {
    return this.childElementCount;
  }
  /**
   * Use `parentElement` instead.
   * @deprecated
   */;
  _proto.getParent = function getParent() {
    return this.parentElement;
  }
  /**
   * Use `children` instead.
   * @deprecated
   */;
  _proto.getChildren = function getChildren() {
    return this.children;
  }
  /**
   * Use `firstElementChild` instead.
   * @deprecated
   */;
  _proto.getFirst = function getFirst() {
    return this.firstElementChild;
  }
  /**
   * Use `lastElementChild` instead.
   * @deprecated
   */;
  _proto.getLast = function getLast() {
    return this.lastElementChild;
  }
  /**
   * Use `this.children[index]` instead.
   * @deprecated
   */;
  _proto.getChildByIndex = function getChildByIndex(index) {
    return this.children[index] || null;
  }
  /**
   * Use `appendChild` instead.
   * @deprecated
   */;
  _proto.add = function add(child, index) {
    return this.appendChild(child, index);
  }
  /**
   * Use `this.style.clipPath` instead.
   * @deprecated
   */;
  _proto.setClip = function setClip(clipPath) {
    this.style.clipPath = clipPath;
  }
  /**
   * Use `this.style.clipPath` instead.
   * @deprecated
   */;
  /**
   * @deprecated
   */
  _proto.set = function set(name, value) {
    // @ts-ignore
    this.config[name] = value;
  }
  /**
   * @deprecated
   */;
  _proto.get = function get(name) {
    return this.config[name];
  }
  /**
   * Use `setPosition` instead.
   * @deprecated
   */;
  _proto.moveTo = function moveTo(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.setPosition(position, y, z);
    return this;
  }
  /**
   * Use `setPosition` instead.
   * @deprecated
   */;
  _proto.move = function move(position, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this.setPosition(position, y, z);
    return this;
  }
  /**
   * Use `this.style.zIndex` instead.
   * @deprecated
   */;
  _proto.setZIndex = function setZIndex(zIndex) {
    this.style.zIndex = zIndex;
    return this;
  };
  _createClass(DisplayObject, [{
    key: "interactive",
    get: function get() {
      return this.isInteractive();
    },
    set: function set(b) {
      this.style.pointerEvents = b ? 'auto' : 'none';
    }
  }]);
  return DisplayObject;
}(Element);

var _excluded = ["style"];
var Circle = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Circle, _DisplayObject);
  function Circle(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded);
    return _DisplayObject.call(this, _extends({
      type: exports.Shape.CIRCLE,
      style: runtime.enableCSSParsing ? _extends({
        cx: '',
        cy: '',
        r: ''
      }, style) : _extends({}, style),
      initialParsedStyle: {
        anchor: [0.5, 0.5],
        transformOrigin: runtime.enableCSSParsing ? null : [getOrCreateUnitValue(50, '%'), getOrCreateUnitValue(50, '%')]
      }
    }, rest)) || this;
  }
  return Circle;
}(DisplayObject);

var _excluded$1 = ["style"];
/**
 * shadow root
 * @see https://yuque.antfin-inc.com/antv/czqvg5/pgqipg
 */
var CustomElement = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(CustomElement, _DisplayObject);
  // static get observedAttributes(): string[] {
  //   return [];
  // }

  // private shadowNodes: DisplayObject[] = [];
  function CustomElement(_temp) {
    var _this;
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    _this = _DisplayObject.call(this, _extends({
      style: runtime.enableCSSParsing ? _extends({
        x: '',
        y: ''
      }, style) : _extends({}, style)
    }, rest)) || this;
    _this.isCustomElement = true;
    return _this;
  }
  return CustomElement;
}(DisplayObject);

var pool = {};
var htmlPool = [];
var DisplayObjectPool = /*#__PURE__*/function () {
  function DisplayObjectPool() {}
  var _proto = DisplayObjectPool.prototype;
  _proto.getByEntity = function getByEntity(entity) {
    return pool[entity];
  };
  _proto.getAll = function getAll() {
    return Object.keys(pool).map(function (entity) {
      return pool[entity];
    });
  };
  _proto.add = function add(entity, groupOrShape) {
    pool[entity] = groupOrShape;
    if (groupOrShape.nodeName === exports.Shape.HTML) {
      htmlPool.push(groupOrShape);
    }
  };
  _proto.remove = function remove(entity) {
    var existed = pool[entity];
    if (existed) {
      delete pool[entity];
      if (existed.nodeName === exports.Shape.HTML) {
        var index = htmlPool.indexOf(existed);
        htmlPool.splice(index, 1);
      }
    }
  };
  _proto.getHTMLs = function getHTMLs() {
    return htmlPool;
  };
  return DisplayObjectPool;
}();

var _excluded$2 = ["style"];
var Ellipse = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Ellipse, _DisplayObject);
  function Ellipse(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    return _DisplayObject.call(this, _extends({
      type: exports.Shape.ELLIPSE,
      style: runtime.enableCSSParsing ? _extends({
        cx: '',
        cy: '',
        rx: '',
        ry: ''
      }, style) : _extends({}, style),
      initialParsedStyle: {
        anchor: [0.5, 0.5],
        transformOrigin: runtime.enableCSSParsing ? null : [getOrCreateUnitValue(50, '%'), getOrCreateUnitValue(50, '%')]
      }
    }, rest)) || this;
  }
  return Ellipse;
}(DisplayObject);

var _excluded$3 = ["style"];
/**
 * its attributes are inherited by its children.
 * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/g
 *
 * @example
 * <g fill="white" stroke="green" stroke-width="5">
    <circle cx="40" cy="40" r="25" />
    <circle cx="60" cy="60" r="25" />
  </g>
 */
var Group = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Group, _DisplayObject);
  function Group(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);
    return _DisplayObject.call(this, _extends({
      type: exports.Shape.GROUP,
      style: runtime.enableCSSParsing ? _extends({
        x: '',
        y: '',
        width: '',
        height: ''
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Group;
}(DisplayObject);

var _excluded$4 = ["style"];
/**
 * HTML container
 * @see https://github.com/pmndrs/drei#html
 */
var HTML = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(HTML, _DisplayObject);
  function HTML(_temp) {
    var _this;
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$4);
    _this = _DisplayObject.call(this, _extends({
      type: exports.Shape.HTML,
      style: runtime.enableCSSParsing ? _extends({
        x: '',
        y: '',
        width: 'auto',
        height: 'auto',
        innerHTML: ''
      }, style) : _extends({}, style)
    }, rest)) || this;
    _this.cullable.enable = false;
    return _this;
  }
  /**
   * return wrapper HTMLElement
   * * <div> in g-webgl/canvas
   * * <foreignObject> in g-svg
   */
  var _proto = HTML.prototype;
  _proto.getDomElement = function getDomElement() {
    return this.parsedStyle.$el;
  }
  /**
   * override with $el.getBoundingClientRect
   * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
   */;
  _proto.getBoundingClientRect = function getBoundingClientRect() {
    return this.parsedStyle.$el.getBoundingClientRect();
  };
  _proto.getClientRects = function getClientRects() {
    return [this.getBoundingClientRect()];
  };
  _proto.getBounds = function getBounds() {
    var _this$ownerDocument, _this$ownerDocument$d;
    var clientRect = this.getBoundingClientRect();
    // calc context's offset
    // @ts-ignore
    var canvasRect = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : (_this$ownerDocument$d = _this$ownerDocument.defaultView) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.getContextService().getBoundingClientRect();
    if (canvasRect) {
      var minX = clientRect.left - canvasRect.left;
      var minY = clientRect.top - canvasRect.top;
      var aabb = new AABB();
      // aabb.setMinMax(
      //   vec3.fromValues(minX, minY, 0),
      //   vec3.fromValues(minX + clientRect.width, minY + clientRect.height, 0),
      // );
      aabb.setMinMax([minX, minY, 0], [minX + clientRect.width, minY + clientRect.height, 0]);
      return aabb;
    }
    return null;
  };
  _proto.getLocalBounds = function getLocalBounds() {
    if (this.parentNode) {
      var parentInvert = glMatrix.mat4.invert(glMatrix.mat4.create(), this.parentNode.getWorldTransform());
      var bounds = this.getBounds();
      if (!AABB.isEmpty(bounds)) {
        var localBounds = new AABB();
        localBounds.setFromTransformedAABB(bounds, parentInvert);
        return localBounds;
      }
    }
    return this.getBounds();
  };
  return HTML;
}(DisplayObject);

var _excluded$5 = ["style"];
var Image = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Image, _DisplayObject);
  function Image(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$5);
    return _DisplayObject.call(this, _extends({
      type: exports.Shape.IMAGE,
      style: runtime.enableCSSParsing ? _extends({
        x: '',
        y: '',
        img: '',
        width: '',
        height: ''
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Image;
}(DisplayObject);

var _excluded$6 = ["style"];
/**
 * Create a line connecting two points.
 * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/line
 *
 * Also support for using marker.
 */
var Line = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Line, _DisplayObject);
  function Line(_temp) {
    var _this;
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$6);
    _this = _DisplayObject.call(this, _extends({
      type: exports.Shape.LINE,
      style: _extends({
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        z1: 0,
        z2: 0,
        isBillboard: false
      }, style)
    }, rest)) || this;
    _this.markerStartAngle = 0;
    _this.markerEndAngle = 0;
    var _this$parsedStyle = _this.parsedStyle,
      markerStart = _this$parsedStyle.markerStart,
      markerEnd = _this$parsedStyle.markerEnd;
    if (markerStart && isDisplayObject(markerStart)) {
      _this.markerStartAngle = markerStart.getLocalEulerAngles();
      _this.appendChild(markerStart);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this.appendChild(markerEnd);
    }
    _this.transformMarker(true);
    _this.transformMarker(false);
    return _this;
  }
  var _proto = Line.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === 'x1' || attrName === 'y1' || attrName === 'x2' || attrName === 'y2' || attrName === 'markerStartOffset' || attrName === 'markerEndOffset') {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === 'markerStart') {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      // CSSKeyword 'unset'
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === 'markerEnd') {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle,
      markerStart = _this$parsedStyle2.markerStart,
      markerEnd = _this$parsedStyle2.markerEnd,
      markerStartOffset = _this$parsedStyle2.markerStartOffset,
      markerEndOffset = _this$parsedStyle2.markerEndOffset,
      x1 = _this$parsedStyle2.x1,
      x2 = _this$parsedStyle2.x2,
      y1 = _this$parsedStyle2.y1,
      y2 = _this$parsedStyle2.y2,
      defX = _this$parsedStyle2.defX,
      defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    if (isStart) {
      ox = x1 - defX;
      oy = y1 - defY;
      x = x2 - x1;
      y = y2 - y1;
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      ox = x2 - defX;
      oy = y2 - defY;
      x = x1 - x2;
      y = y1 - y2;
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad = Math.atan2(y, x);
    // account for markerOffset
    marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
  };
  _proto.getPoint = function getPoint(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    // TODO: account for z1/z2 in 3D line
    var _this$parsedStyle3 = this.parsedStyle,
      x1 = _this$parsedStyle3.x1,
      y1 = _this$parsedStyle3.y1,
      x2 = _this$parsedStyle3.x2,
      y2 = _this$parsedStyle3.y2,
      defX = _this$parsedStyle3.defX,
      defY = _this$parsedStyle3.defY;
    var _LineUtil$pointAt = gMath.Line.pointAt(x1, y1, x2, y2, ratio),
      x = _LineUtil$pointAt.x,
      y = _LineUtil$pointAt.y;
    var transformed = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), glMatrix.vec3.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    // apply local transformation
    return new Point(transformed[0], transformed[1]);
  };
  _proto.getPointAtLength = function getPointAtLength(distance, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPoint(distance / this.getTotalLength(), inWorldSpace);
  };
  _proto.getTotalLength = function getTotalLength() {
    // TODO: account for z1/z2 in 3D line
    var _this$parsedStyle4 = this.parsedStyle,
      x1 = _this$parsedStyle4.x1,
      y1 = _this$parsedStyle4.y1,
      x2 = _this$parsedStyle4.x2,
      y2 = _this$parsedStyle4.y2;
    return gMath.Line.length(x1, y1, x2, y2);
  };
  return Line;
}(DisplayObject);

var _excluded$7 = ["style"];
var EMPTY_PARSED_PATH = {
  absolutePath: [],
  hasArc: false,
  segments: [],
  polygons: [],
  polylines: [],
  curve: null,
  totalLength: 0,
  rect: new Rectangle(0, 0, 0, 0)
};
var Path = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Path, _DisplayObject);
  /**
   * markers placed at the mid
   */

  function Path(_temp) {
    var _this;
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$7);
    _this = _DisplayObject.call(this, _extends({
      type: exports.Shape.PATH,
      style: runtime.enableCSSParsing ? _extends({
        path: '',
        miterLimit: ''
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        miterLimit: 4,
        path: _extends({}, EMPTY_PARSED_PATH)
      }
    }, rest)) || this;
    _this.markerStartAngle = 0;
    _this.markerEndAngle = 0;
    _this.markerMidList = [];
    var _this$parsedStyle = _this.parsedStyle,
      markerStart = _this$parsedStyle.markerStart,
      markerEnd = _this$parsedStyle.markerEnd,
      markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this.markerStartAngle = markerStart.getLocalEulerAngles();
      _this.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this.appendChild(markerEnd);
    }
    _this.transformMarker(true);
    _this.transformMarker(false);
    return _this;
  }
  var _proto = Path.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === 'path') {
      // recalc markers
      this.transformMarker(true);
      this.transformMarker(false);
      this.placeMarkerMid(this.parsedStyle.markerMid);
    } else if (attrName === 'markerStartOffset' || attrName === 'markerEndOffset') {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === 'markerStart') {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      // CSSKeyword 'unset'
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === 'markerEnd') {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    } else if (attrName === 'markerMid') {
      this.placeMarkerMid(newParsedValue);
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle,
      markerStart = _this$parsedStyle2.markerStart,
      markerEnd = _this$parsedStyle2.markerEnd,
      markerStartOffset = _this$parsedStyle2.markerStartOffset,
      markerEndOffset = _this$parsedStyle2.markerEndOffset,
      defX = _this$parsedStyle2.defX,
      defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    if (isStart) {
      var _this$getStartTangent = this.getStartTangent(),
        p1 = _this$getStartTangent[0],
        p2 = _this$getStartTangent[1];
      ox = p2[0] - defX;
      oy = p2[1] - defY;
      x = p1[0] - p2[0];
      y = p1[1] - p2[1];
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      var _this$getEndTangent = this.getEndTangent(),
        _p = _this$getEndTangent[0],
        _p2 = _this$getEndTangent[1];
      ox = _p2[0] - defX;
      oy = _p2[1] - defY;
      x = _p[0] - _p2[0];
      y = _p[1] - _p2[1];
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad = Math.atan2(y, x);
    // account for markerOffset
    marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
  };
  _proto.placeMarkerMid = function placeMarkerMid(marker) {
    var _this$parsedStyle3 = this.parsedStyle,
      segments = _this$parsedStyle3.path.segments,
      defX = _this$parsedStyle3.defX,
      defY = _this$parsedStyle3.defY;
    // clear all existed markers
    this.markerMidList.forEach(function (marker) {
      marker.remove();
    });
    if (marker && isDisplayObject(marker)) {
      for (var i = 1; i < segments.length - 1; i++) {
        var _segments$i$currentPo = segments[i].currentPoint,
          ox = _segments$i$currentPo[0],
          oy = _segments$i$currentPo[1];
        var cloned = i === 1 ? marker : marker.cloneNode(true);
        this.markerMidList.push(cloned);
        this.appendChild(cloned);
        cloned.setLocalPosition(ox - defX, oy - defY);
        // TODO: orient of marker
      }
    }
  }
  /**
   * Returns the total length of the path.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
   */;
  _proto.getTotalLength = function getTotalLength() {
    return getOrCalculatePathTotalLength(this);
  }
  /**
   * Returns the point at a given distance along the path.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
   */;
  _proto.getPointAtLength = function getPointAtLength(distance, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    var _this$parsedStyle4 = this.parsedStyle,
      defX = _this$parsedStyle4.defX,
      defY = _this$parsedStyle4.defY,
      absolutePath = _this$parsedStyle4.path.absolutePath;
    var _getPointAtLength2 = util.getPointAtLength(absolutePath, distance),
      x = _getPointAtLength2.x,
      y = _getPointAtLength2.y;
    var transformed = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), glMatrix.vec3.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    // apply local transformation
    return new Point(transformed[0], transformed[1]);
  }
  /**
   * Returns the point at a given ratio of the total length in path.
   */;
  _proto.getPoint = function getPoint(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
  }
  /**
   * Get start tangent vector
   */;
  _proto.getStartTangent = function getStartTangent() {
    var segments = this.parsedStyle.path.segments;
    var result = [];
    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];
      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }
    return result;
  }
  /**
   * Get end tangent vector
   */;
  _proto.getEndTangent = function getEndTangent() {
    var segments = this.parsedStyle.path.segments;
    var length = segments.length;
    var result = [];
    if (length > 1) {
      var startPoint = segments[length - 2].currentPoint;
      var endPoint = segments[length - 1].currentPoint;
      var tangent = segments[length - 1].endTangent;
      result = [];
      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }
    return result;
  };
  return Path;
}(DisplayObject);

var _excluded$8 = ["style"];
var Polygon = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Polygon, _DisplayObject);
  /**
   * markers placed at the mid
   */

  function Polygon(_temp) {
    var _this;
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$8);
    _this = _DisplayObject.call(this, _extends({
      type: exports.Shape.POLYGON,
      style: runtime.enableCSSParsing ? _extends({
        points: '',
        miterLimit: '',
        isClosed: true
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: true
      }
    }, rest)) || this;
    _this.markerStartAngle = 0;
    _this.markerEndAngle = 0;
    _this.markerMidList = [];
    var _this$parsedStyle = _this.parsedStyle,
      markerStart = _this$parsedStyle.markerStart,
      markerEnd = _this$parsedStyle.markerEnd,
      markerMid = _this$parsedStyle.markerMid;
    if (markerStart && isDisplayObject(markerStart)) {
      _this.markerStartAngle = markerStart.getLocalEulerAngles();
      _this.appendChild(markerStart);
    }
    if (markerMid && isDisplayObject(markerMid)) {
      _this.placeMarkerMid(markerMid);
    }
    if (markerEnd && isDisplayObject(markerEnd)) {
      _this.markerEndAngle = markerEnd.getLocalEulerAngles();
      _this.appendChild(markerEnd);
    }
    _this.transformMarker(true);
    _this.transformMarker(false);
    return _this;
  }
  var _proto = Polygon.prototype;
  _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
    if (attrName === 'points') {
      // recalc markers
      this.transformMarker(true);
      this.transformMarker(false);
      this.placeMarkerMid(this.parsedStyle.markerMid);
    } else if (attrName === 'markerStartOffset' || attrName === 'markerEndOffset') {
      this.transformMarker(true);
      this.transformMarker(false);
    } else if (attrName === 'markerStart') {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerStartAngle = 0;
        prevParsedValue.remove();
      }
      // CSSKeyword 'unset'
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerStartAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(true);
      }
    } else if (attrName === 'markerEnd') {
      if (prevParsedValue && isDisplayObject(prevParsedValue)) {
        this.markerEndAngle = 0;
        prevParsedValue.remove();
      }
      if (newParsedValue && isDisplayObject(newParsedValue)) {
        this.markerEndAngle = newParsedValue.getLocalEulerAngles();
        this.appendChild(newParsedValue);
        this.transformMarker(false);
      }
    } else if (attrName === 'markerMid') {
      this.placeMarkerMid(newParsedValue);
    }
  };
  _proto.transformMarker = function transformMarker(isStart) {
    var _this$parsedStyle2 = this.parsedStyle,
      markerStart = _this$parsedStyle2.markerStart,
      markerEnd = _this$parsedStyle2.markerEnd,
      markerStartOffset = _this$parsedStyle2.markerStartOffset,
      markerEndOffset = _this$parsedStyle2.markerEndOffset,
      points = _this$parsedStyle2.points.points,
      defX = _this$parsedStyle2.defX,
      defY = _this$parsedStyle2.defY;
    var marker = isStart ? markerStart : markerEnd;
    if (!marker || !isDisplayObject(marker)) {
      return;
    }
    var rad = 0;
    var x;
    var y;
    var ox;
    var oy;
    var offset;
    var originalAngle;
    ox = points[0][0] - defX;
    oy = points[0][1] - defY;
    if (isStart) {
      x = points[1][0] - points[0][0];
      y = points[1][1] - points[0][1];
      offset = markerStartOffset || 0;
      originalAngle = this.markerStartAngle;
    } else {
      var length = points.length;
      if (!this.parsedStyle.isClosed) {
        ox = points[length - 1][0] - defX;
        oy = points[length - 1][1] - defY;
        x = points[length - 2][0] - points[length - 1][0];
        y = points[length - 2][1] - points[length - 1][1];
      } else {
        x = points[length - 1][0] - points[0][0];
        y = points[length - 1][1] - points[0][1];
      }
      offset = markerEndOffset || 0;
      originalAngle = this.markerEndAngle;
    }
    rad = Math.atan2(y, x);
    // account for markerOffset
    marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
    marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
  };
  _proto.placeMarkerMid = function placeMarkerMid(marker) {
    var _this$parsedStyle3 = this.parsedStyle,
      points = _this$parsedStyle3.points.points,
      defX = _this$parsedStyle3.defX,
      defY = _this$parsedStyle3.defY;
    // clear all existed markers
    this.markerMidList.forEach(function (marker) {
      marker.remove();
    });
    this.markerMidList = [];
    if (marker && isDisplayObject(marker)) {
      for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
        var ox = points[i][0] - defX;
        var oy = points[i][1] - defY;
        var cloned = i === 1 ? marker : marker.cloneNode(true);
        this.markerMidList.push(cloned);
        this.appendChild(cloned);
        cloned.setLocalPosition(ox, oy);
        // TODO: orient of marker
      }
    }
  };
  return Polygon;
}(DisplayObject);

var _excluded$9 = ["style"];
/**
 * Polyline inherits the marker-related capabilities of Polygon.
 */
var Polyline = /*#__PURE__*/function (_Polygon) {
  _inheritsLoose(Polyline, _Polygon);
  function Polyline(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$9);
    return _Polygon.call(this, _extends({
      type: exports.Shape.POLYLINE,
      style: runtime.enableCSSParsing ? _extends({
        points: '',
        miterLimit: '',
        isClosed: false
      }, style) : _extends({}, style),
      initialParsedStyle: runtime.enableCSSParsing ? null : {
        points: {
          points: [],
          totalLength: 0,
          segments: []
        },
        miterLimit: 4,
        isClosed: false
      }
    }, rest)) || this;
  }
  var _proto = Polyline.prototype;
  _proto.getTotalLength = function getTotalLength() {
    return this.parsedStyle.points.totalLength;
  };
  _proto.getPointAtLength = function getPointAtLength(distance, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    return this.getPoint(distance / this.getTotalLength(), inWorldSpace);
  };
  _proto.getPoint = function getPoint(ratio, inWorldSpace) {
    if (inWorldSpace === void 0) {
      inWorldSpace = false;
    }
    var _this$parsedStyle = this.parsedStyle,
      defX = _this$parsedStyle.defX,
      defY = _this$parsedStyle.defY,
      _this$parsedStyle$poi = _this$parsedStyle.points,
      points = _this$parsedStyle$poi.points,
      segments = _this$parsedStyle$poi.segments;
    var subt = 0;
    var index = 0;
    segments.forEach(function (v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    var _LineUtil$pointAt = gMath.Line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt),
      x = _LineUtil$pointAt.x,
      y = _LineUtil$pointAt.y;
    var transformed = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), glMatrix.vec3.fromValues(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
    // apply local transformation
    return new Point(transformed[0], transformed[1]);
  };
  _proto.getStartTangent = function getStartTangent() {
    var points = this.parsedStyle.points.points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  _proto.getEndTangent = function getEndTangent() {
    var points = this.parsedStyle.points.points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };
  return Polyline;
}(Polygon);

var _excluded$a = ["style"];
var Rect = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Rect, _DisplayObject);
  function Rect(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$a);
    return _DisplayObject.call(this, _extends({
      type: exports.Shape.RECT,
      style: runtime.enableCSSParsing ? _extends({
        x: '',
        y: '',
        width: '',
        height: '',
        radius: ''
      }, style) : _extends({}, style)
    }, rest)) || this;
  }
  return Rect;
}(DisplayObject);

var _excluded$b = ["style"];
/**
 * <text> @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextElement
 */
var Text = /*#__PURE__*/function (_DisplayObject) {
  _inheritsLoose(Text, _DisplayObject);
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextContentElement#constants
   */
  // LENGTHADJUST_SPACING: number = 1;
  // LENGTHADJUST_SPACINGANDGLYPHS: number = 2;
  // LENGTHADJUST_UNKNOWN: number = 0;
  function Text(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, _excluded$b);
    return _DisplayObject.call(this, _extends({
      type: exports.Shape.TEXT,
      style: runtime.enableCSSParsing ? _extends({
        x: '',
        y: '',
        text: '',
        fontSize: '',
        fontFamily: '',
        fontStyle: '',
        fontWeight: '',
        fontVariant: '',
        textAlign: '',
        textBaseline: '',
        textTransform: '',
        fill: 'black',
        letterSpacing: '',
        lineHeight: '',
        miterLimit: '',
        // whiteSpace: 'pre',
        wordWrap: false,
        wordWrapWidth: 0,
        leading: 0,
        dx: '',
        dy: ''
      }, style) : _extends({
        fill: 'black'
      }, style),
      initialParsedStyle: runtime.enableCSSParsing ? {} : {
        x: 0,
        y: 0,
        fontSize: 16,
        fontFamily: 'sans-serif',
        fontStyle: 'normal',
        fontWeight: 'normal',
        fontVariant: 'normal',
        lineHeight: 0,
        letterSpacing: 0,
        textBaseline: 'alphabetic',
        textAlign: 'start',
        wordWrap: false,
        wordWrapWidth: 0,
        leading: 0,
        dx: 0,
        dy: 0
      }
    }, rest)) || this;
  }
  // lengthAdjust: SVGAnimatedEnumeration;
  // textLength: SVGAnimatedLength;
  // getCharNumAtPosition(point?: DOMPointInit): number {
  //   throw new Error('Method not implemented.');
  // }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextContentElement
   */
  var _proto = Text.prototype;
  _proto.getComputedTextLength = function getComputedTextLength() {
    var _this$parsedStyle$met;
    return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
  }
  // getEndPositionOfChar(charnum: number): DOMPoint {
  //   throw new Error('Method not implemented.');
  // }
  // getExtentOfChar(charnum: number): DOMRect {
  //   throw new Error('Method not implemented.');
  // }
  // getNumberOfChars(): number {
  //   throw new Error('Method not implemented.');
  // }
  // getRotationOfChar(charnum: number): number {
  //   throw new Error('Method not implemented.');
  // }
  // getStartPositionOfChar(charnum: number): DOMPoint {
  //   throw new Error('Method not implemented.');
  // }
  // getSubStringLength(charnum: number, nchars: number): number {
  //   throw new Error('Method not implemented.');
  // }
  // selectSubString(charnum: number, nchars: number): void {
  //   throw new Error('Method not implemented.');
  // }
  ;
  _proto.getLineBoundingRects = function getLineBoundingRects() {
    var _this$parsedStyle$met2;
    return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
  };
  _proto.isOverflowing = function isOverflowing() {
    return !!this.parsedStyle.isOverflowing;
  };
  return Text;
}(DisplayObject);

/**
 * Blink used them in code generation(css_properties.json5)
 */
var BUILT_IN_PROPERTIES = [{
  /**
   * used in CSS Layout API
   * eg. `display: 'flex'`
   */
  n: 'display',
  k: ['none']
}, {
  /**
   * range [0.0, 1.0]
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
   */
  n: 'opacity',
  int: true,
  inh: true,
  d: '1',
  syntax: exports.PropertySyntax.OPACITY_VALUE
}, {
  /**
   * inheritable, range [0.0, 1.0]
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
   * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
   */
  n: 'fillOpacity',
  int: true,
  inh: true,
  d: '1',
  syntax: exports.PropertySyntax.OPACITY_VALUE
}, {
  /**
   * inheritable, range [0.0, 1.0]
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
   * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
   */
  n: 'strokeOpacity',
  int: true,
  inh: true,
  d: '1',
  syntax: exports.PropertySyntax.OPACITY_VALUE
}, {
  /**
   * background-color is not inheritable
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
   */
  n: 'fill',
  int: true,
  k: ['none'],
  d: 'none',
  syntax: exports.PropertySyntax.PAINT
}, {
  n: 'fillRule',
  k: ['nonzero', 'evenodd'],
  d: 'nonzero'
},
/**
 * default to none
 * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
 */
{
  n: 'stroke',
  int: true,
  k: ['none'],
  d: 'none',
  syntax: exports.PropertySyntax.PAINT
}, {
  n: 'shadowType',
  k: ['inner', 'outer', 'both'],
  d: 'outer',
  l: true
}, {
  n: 'shadowColor',
  int: true,
  syntax: exports.PropertySyntax.COLOR
}, {
  n: 'shadowOffsetX',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'shadowOffsetY',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'shadowBlur',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.SHADOW_BLUR
}, {
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
   */
  n: 'lineWidth',
  int: true,
  inh: true,
  d: '1',
  l: true,
  a: ['strokeWidth'],
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'increasedLineWidthForHitTesting',
  inh: true,
  d: '0',
  l: true,
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'lineJoin',
  inh: true,
  l: true,
  a: ['strokeLinejoin'],
  k: ['miter', 'bevel', 'round'],
  d: 'miter'
}, {
  n: 'lineCap',
  inh: true,
  l: true,
  a: ['strokeLinecap'],
  k: ['butt', 'round', 'square'],
  d: 'butt'
}, {
  n: 'lineDash',
  int: true,
  inh: true,
  k: ['none'],
  a: ['strokeDasharray'],
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE_12
}, {
  n: 'lineDashOffset',
  int: true,
  inh: true,
  d: '0',
  a: ['strokeDashoffset'],
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'offsetPath',
  syntax: exports.PropertySyntax.DEFINED_PATH
}, {
  n: 'offsetDistance',
  int: true,
  syntax: exports.PropertySyntax.OFFSET_DISTANCE
}, {
  n: 'dx',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'dy',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'zIndex',
  ind: true,
  int: true,
  d: '0',
  k: ['auto'],
  syntax: exports.PropertySyntax.Z_INDEX
}, {
  n: 'visibility',
  k: ['visible', 'hidden'],
  ind: true,
  inh: true,
  /**
   * support interpolation
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
   */
  int: true,
  d: 'visible'
}, {
  n: 'pointerEvents',
  inh: true,
  k: ['none', 'auto', 'stroke', 'fill', 'painted', 'visible', 'visiblestroke', 'visiblefill', 'visiblepainted',
  // 'bounding-box',
  'all'],
  d: 'auto'
}, {
  n: 'filter',
  ind: true,
  l: true,
  k: ['none'],
  d: 'none',
  syntax: exports.PropertySyntax.FILTER
}, {
  n: 'clipPath',
  syntax: exports.PropertySyntax.DEFINED_PATH
}, {
  n: 'textPath',
  syntax: exports.PropertySyntax.DEFINED_PATH
}, {
  n: 'textPathSide',
  k: ['left', 'right'],
  d: 'left'
}, {
  n: 'textPathStartOffset',
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'transform',
  p: 100,
  int: true,
  k: ['none'],
  d: 'none',
  syntax: exports.PropertySyntax.TRANSFORM
}, {
  n: 'transformOrigin',
  p: 100,
  // int: true,
  d: function d(nodeName) {
    if (nodeName === exports.Shape.CIRCLE || nodeName === exports.Shape.ELLIPSE) {
      return 'center';
    }
    if (nodeName === exports.Shape.TEXT) {
      return 'text-anchor';
    }
    return 'left top';
  },
  l: true,
  syntax: exports.PropertySyntax.TRANSFORM_ORIGIN
}, {
  n: 'anchor',
  p: 99,
  d: function d(nodeName) {
    if (nodeName === exports.Shape.CIRCLE || nodeName === exports.Shape.ELLIPSE) {
      return '0.5 0.5';
    }
    return '0 0';
  },
  l: true,
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE_12
},
// <circle> & <ellipse>
{
  n: 'cx',
  int: true,
  d: '0',
  syntax: exports.PropertySyntax.COORDINATE
}, {
  n: 'cy',
  int: true,
  d: '0',
  syntax: exports.PropertySyntax.COORDINATE
}, {
  n: 'r',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'rx',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'ry',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
},
// Rect Image Group
{
  // x in local space
  n: 'x',
  int: true,
  d: '0',
  syntax: exports.PropertySyntax.COORDINATE
}, {
  // y in local space
  n: 'y',
  int: true,
  d: '0',
  syntax: exports.PropertySyntax.COORDINATE
}, {
  // z in local space
  n: 'z',
  int: true,
  d: '0',
  syntax: exports.PropertySyntax.COORDINATE
}, {
  n: 'width',
  int: true,
  l: true,
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
   */
  k: ['auto', 'fit-content', 'min-content', 'max-content'],
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'height',
  int: true,
  l: true,
  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
   */
  k: ['auto', 'fit-content', 'min-content', 'max-content'],
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'radius',
  int: true,
  l: true,
  d: '0',
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE_14
},
// Line
{
  n: 'x1',
  int: true,
  l: true,
  syntax: exports.PropertySyntax.COORDINATE
}, {
  n: 'y1',
  int: true,
  l: true,
  syntax: exports.PropertySyntax.COORDINATE
}, {
  n: 'z1',
  int: true,
  l: true,
  syntax: exports.PropertySyntax.COORDINATE
}, {
  n: 'x2',
  int: true,
  l: true,
  syntax: exports.PropertySyntax.COORDINATE
}, {
  n: 'y2',
  int: true,
  l: true,
  syntax: exports.PropertySyntax.COORDINATE
}, {
  n: 'z2',
  int: true,
  l: true,
  syntax: exports.PropertySyntax.COORDINATE
},
// Path
{
  n: 'path',
  int: true,
  l: true,
  d: '',
  a: ['d'],
  syntax: exports.PropertySyntax.PATH,
  p: 50
},
// Polyline & Polygon
{
  n: 'points',
  l: true,
  syntax: exports.PropertySyntax.LIST_OF_POINTS,
  p: 50
},
// Text
{
  n: 'text',
  l: true,
  d: '',
  syntax: exports.PropertySyntax.TEXT,
  p: 50
}, {
  n: 'textTransform',
  l: true,
  inh: true,
  k: ['capitalize', 'uppercase', 'lowercase', 'none'],
  d: 'none',
  syntax: exports.PropertySyntax.TEXT_TRANSFORM,
  p: 51 // it must get parsed after text
}, {
  n: 'font',
  l: true
}, {
  n: 'fontSize',
  int: true,
  inh: true,
  /**
   * @see https://www.w3schools.com/css/css_font_size.asp
   */
  d: '16px',
  l: true,
  syntax: exports.PropertySyntax.LENGTH_PERCENTAGE
}, {
  n: 'fontFamily',
  l: true,
  inh: true,
  d: 'sans-serif'
}, {
  n: 'fontStyle',
  l: true,
  inh: true,
  k: ['normal', 'italic', 'oblique'],
  d: 'normal'
}, {
  n: 'fontWeight',
  l: true,
  inh: true,
  k: ['normal', 'bold', 'bolder', 'lighter'],
  d: 'normal'
}, {
  n: 'fontVariant',
  l: true,
  inh: true,
  k: ['normal', 'small-caps'],
  d: 'normal'
}, {
  n: 'lineHeight',
  l: true,
  syntax: exports.PropertySyntax.LENGTH,
  int: true,
  d: '0'
}, {
  n: 'letterSpacing',
  l: true,
  syntax: exports.PropertySyntax.LENGTH,
  int: true,
  d: '0'
}, {
  n: 'miterLimit',
  l: true,
  syntax: exports.PropertySyntax.NUMBER,
  d: function d(nodeName) {
    if (nodeName === exports.Shape.PATH || nodeName === exports.Shape.POLYGON || nodeName === exports.Shape.POLYLINE) {
      return '4';
    }
    return '10';
  }
}, {
  n: 'wordWrap',
  l: true
}, {
  n: 'wordWrapWidth',
  l: true
}, {
  n: 'maxLines',
  l: true
}, {
  n: 'textOverflow',
  l: true,
  d: 'clip'
}, {
  n: 'leading',
  l: true
}, {
  n: 'textBaseline',
  l: true,
  inh: true,
  k: ['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'],
  d: 'alphabetic'
}, {
  n: 'textAlign',
  l: true,
  inh: true,
  k: ['start', 'center', 'middle', 'end', 'left', 'right'],
  d: 'start'
},
// {
//   n: 'whiteSpace',
//   l: true,
// },
{
  n: 'markerStart',
  syntax: exports.PropertySyntax.MARKER
}, {
  n: 'markerEnd',
  syntax: exports.PropertySyntax.MARKER
}, {
  n: 'markerMid',
  syntax: exports.PropertySyntax.MARKER
}, {
  n: 'markerStartOffset',
  syntax: exports.PropertySyntax.LENGTH,
  l: true,
  int: true,
  d: '0'
}, {
  n: 'markerEndOffset',
  syntax: exports.PropertySyntax.LENGTH,
  l: true,
  int: true,
  d: '0'
}];
var GEOMETRY_ATTRIBUTE_NAMES = BUILT_IN_PROPERTIES.filter(function (n) {
  return !!n.l;
}).map(function (n) {
  return n.n;
});
var propertyMetadataCache = {};
var unresolvedProperties = new WeakMap();
// const uniqueAttributeSet = new Set<string>();
// const tmpVec3a = vec3.create();
// const tmpVec3b = vec3.create();
// const tmpVec3c = vec3.create();
var isPropertyResolved = function isPropertyResolved(object, name) {
  var properties = unresolvedProperties.get(object);
  if (!properties || properties.length === 0) {
    return true;
  }
  return properties.includes(name);
};
var DefaultStyleValueRegistry = /*#__PURE__*/function () {
  /**
   * need recalc later
   */
  // dirty = false;
  function DefaultStyleValueRegistry() {
    var _this = this;
    BUILT_IN_PROPERTIES.forEach(function (property) {
      _this.registerMetadata(property);
    });
  }
  var _proto = DefaultStyleValueRegistry.prototype;
  _proto.registerMetadata = function registerMetadata(metadata) {
    [metadata.n].concat(metadata.a || []).forEach(function (name) {
      propertyMetadataCache[name] = metadata;
    });
  };
  _proto.unregisterMetadata = function unregisterMetadata(name) {
    delete propertyMetadataCache[name];
  };
  _proto.getPropertySyntax = function getPropertySyntax(syntax) {
    return runtime.CSSPropertySyntaxFactory[syntax];
  }
  /**
   * * parse value, eg.
   * fill: 'red' => CSSRGB
   * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
   * fontSize: '2em' => { unit: 'px', value: 32 }
   *
   * * calculate used value
   * * post process
   */;
  _proto.processProperties = function processProperties(object, attributes, options) {
    var _this2 = this;
    if (options === void 0) {
      options = {
        skipUpdateAttribute: false,
        skipParse: false,
        forceUpdateGeometry: false,
        usedAttributes: []
      };
    }
    if (!runtime.enableCSSParsing) {
      // alias
      // @ts-ignore
      if (attributes.src) {
        // @ts-ignore
        attributes.img = attributes.src;
      }
      // @ts-ignore
      if (attributes.d) {
        // @ts-ignore
        attributes.path = attributes.d;
      }
      if (attributes.strokeDasharray) {
        attributes.lineDash = attributes.strokeDasharray;
      }
      if (attributes.strokeWidth) {
        attributes.lineWidth = attributes.strokeWidth;
      }
      // @ts-ignore
      if (attributes.textAnchor) {
        // @ts-ignore
        attributes.textAlign = attributes.textAnchor;
      }
      Object.assign(object.attributes, attributes);
      var _attributeNames = Object.keys(attributes);
      // clipPath
      var oldClipPath = object.parsedStyle.clipPath;
      var oldOffsetPath = object.parsedStyle.offsetPath;
      object.parsedStyle = Object.assign(object.parsedStyle, attributes);
      var _needUpdateGeometry = !!options.forceUpdateGeometry;
      if (!_needUpdateGeometry) {
        for (var i = 0; i < GEOMETRY_ATTRIBUTE_NAMES.length; i++) {
          if (GEOMETRY_ATTRIBUTE_NAMES[i] in attributes) {
            _needUpdateGeometry = true;
            break;
          }
        }
      }
      if (attributes.fill) {
        object.parsedStyle.fill = parseColor(attributes.fill);
      }
      if (attributes.stroke) {
        object.parsedStyle.stroke = parseColor(attributes.stroke);
      }
      if (attributes.shadowColor) {
        object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
      }
      if (attributes.filter) {
        object.parsedStyle.filter = parseFilter(attributes.filter);
      }
      // Rect
      // @ts-ignore
      if (!util.isNil(attributes.radius)) {
        // @ts-ignore
        object.parsedStyle.radius = parseDimensionArrayFormat(
        // @ts-ignore
        attributes.radius, 4);
      }
      // Polyline
      if (!util.isNil(attributes.lineDash)) {
        object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, 2);
      }
      // @ts-ignore
      if (attributes.points) {
        // @ts-ignore
        object.parsedStyle.points = parsePoints(attributes.points, object);
      }
      // Path
      // @ts-ignore
      if (attributes.path === '') {
        object.parsedStyle.path = _extends({}, EMPTY_PARSED_PATH);
      }
      // @ts-ignore
      if (attributes.path) {
        object.parsedStyle.path = parsePath(
        // @ts-ignore
        attributes.path, object);
      }
      // Text
      if (attributes.textTransform) {
        runtime.CSSPropertySyntaxFactory['<text-transform>'].calculator(null, null, {
          value: attributes.textTransform
        }, object, null);
      }
      if (attributes.clipPath) {
        runtime.CSSPropertySyntaxFactory['<defined-path>'].calculator('clipPath', oldClipPath, attributes.clipPath, object, this);
      }
      if (attributes.offsetPath) {
        runtime.CSSPropertySyntaxFactory['<defined-path>'].calculator('offsetPath', oldOffsetPath, attributes.offsetPath, object, this);
      }
      if (attributes.anchor) {
        object.parsedStyle.anchor = parseDimensionArrayFormat(
        // @ts-ignorex
        attributes.anchor, 2);
      }
      if (attributes.transform) {
        object.parsedStyle.transform = parseTransform(attributes.transform);
      }
      if (attributes.transformOrigin) {
        object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
      }
      // Marker
      // @ts-ignore
      if (attributes.markerStart) {
        // @ts-ignore
        object.parsedStyle.markerStart = runtime.CSSPropertySyntaxFactory['<marker>'].calculator(null,
        // @ts-ignore
        attributes.markerStart,
        // @ts-ignore
        attributes.markerStart, null, null);
      }
      // @ts-ignore
      if (attributes.markerEnd) {
        // @ts-ignore
        object.parsedStyle.markerEnd = runtime.CSSPropertySyntaxFactory['<marker>'].calculator(null,
        // @ts-ignore
        attributes.markerEnd,
        // @ts-ignore
        attributes.markerEnd, null, null);
      }
      // @ts-ignore
      if (attributes.markerMid) {
        // @ts-ignore
        object.parsedStyle.markerMid = runtime.CSSPropertySyntaxFactory['<marker>'].calculator('',
        // @ts-ignore
        attributes.markerMid,
        // @ts-ignore
        attributes.markerMid, null, null);
      }
      if (
      // Circle & Ellipse
      (object.nodeName === exports.Shape.CIRCLE || object.nodeName === exports.Shape.ELLIPSE) && (
      // @ts-ignore
      !util.isNil(attributes.cx) ||
      // @ts-ignore
      !util.isNil(attributes.cy)) || (object.nodeName === exports.Shape.RECT || object.nodeName === exports.Shape.IMAGE || object.nodeName === exports.Shape.GROUP || object.nodeName === exports.Shape.HTML || object.nodeName === exports.Shape.TEXT || object.nodeName === exports.Shape.MESH) && (
      // @ts-ignore
      !util.isNil(attributes.x) ||
      // @ts-ignore
      !util.isNil(attributes.y) ||
      // @ts-ignore
      !util.isNil(attributes.z)) ||
      // Line
      object.nodeName === exports.Shape.LINE && (
      // @ts-ignore
      !util.isNil(attributes.x1) ||
      // @ts-ignore
      !util.isNil(attributes.y1) ||
      // @ts-ignore
      !util.isNil(attributes.z1) ||
      // @ts-ignore
      !util.isNil(attributes.x2) ||
      // @ts-ignore
      !util.isNil(attributes.y2) ||
      // @ts-ignore
      !util.isNil(attributes.z2))) {
        runtime.CSSPropertySyntaxFactory['<coordinate>'].postProcessor(object, _attributeNames);
      }
      if (!util.isNil(attributes.zIndex)) {
        runtime.CSSPropertySyntaxFactory['<z-index>'].postProcessor(object, _attributeNames);
      }
      // @ts-ignore
      if (attributes.path) {
        runtime.CSSPropertySyntaxFactory['<path>'].postProcessor(object, _attributeNames);
      }
      // @ts-ignore
      if (attributes.points) {
        runtime.CSSPropertySyntaxFactory['<list-of-points>'].postProcessor(object, _attributeNames);
      }
      if (!util.isNil(attributes.offsetDistance)) {
        runtime.CSSPropertySyntaxFactory['<offset-distance>'].postProcessor(object, _attributeNames);
      }
      if (attributes.transform) {
        runtime.CSSPropertySyntaxFactory['<transform>'].postProcessor(object, _attributeNames);
      }
      if (_needUpdateGeometry) {
        object.geometry.dirty = true;
        runtime.sceneGraphService.dirtifyToRoot(object);
      }
      return;
    }
    var _options = options,
      skipUpdateAttribute = _options.skipUpdateAttribute,
      skipParse = _options.skipParse,
      forceUpdateGeometry = _options.forceUpdateGeometry,
      usedAttributes = _options.usedAttributes;
    var needUpdateGeometry = forceUpdateGeometry;
    var attributeNames = Object.keys(attributes);
    attributeNames.forEach(function (attributeName) {
      var _propertyMetadataCach;
      var name = formatAttributeName(attributeName);
      if (!skipUpdateAttribute) {
        object.attributes[name] = attributes[attributeName];
      }
      if (!needUpdateGeometry && ((_propertyMetadataCach = propertyMetadataCache[name]) === null || _propertyMetadataCach === void 0 ? void 0 : _propertyMetadataCach.l)) {
        needUpdateGeometry = true;
      }
    });
    if (!skipParse) {
      attributeNames.forEach(function (name) {
        object.computedStyle[name] = _this2.parseProperty(name, object.attributes[name], object);
      });
    }
    // let hasUnresolvedProperties = false;
    // parse according to priority
    // path 50
    // points 50
    // text 50
    // textTransform 51
    // anchor 99
    // transform 100
    // transformOrigin 100
    if (usedAttributes === null || usedAttributes === void 0 ? void 0 : usedAttributes.length) {
      // uniqueAttributeSet.clear();
      attributeNames = Array.from(new Set(attributeNames.concat(usedAttributes)));
    }
    // [
    //   'path',
    //   'points',
    //   'text',
    //   'textTransform',
    //   'anchor',
    //   'transform',
    //   'transformOrigin',
    // ].forEach((name) => {
    //   const index = attributeNames.indexOf(name);
    //   if (index > -1) {
    //     attributeNames.splice(index, 1);
    //     attributeNames.push(name);
    //   }
    // });
    attributeNames.forEach(function (name) {
      // some style props maybe deleted after parsing such as `anchor` in Text
      if (name in object.computedStyle) {
        object.parsedStyle[name] = _this2.computeProperty(name, object.computedStyle[name], object);
      }
    });
    // if (hasUnresolvedProperties) {
    //   this.dirty = true;
    //   return;
    // }
    // update geometry
    if (needUpdateGeometry) {
      object.geometry.dirty = true;
      runtime.sceneGraphService.dirtifyToRoot(object);
    }
    attributeNames.forEach(function (name) {
      if (name in object.parsedStyle) {
        _this2.postProcessProperty(name, object, attributeNames);
      }
    });
    if (runtime.enableCSSParsing && object.children.length) {
      attributeNames.forEach(function (name) {
        if (name in object.parsedStyle && _this2.isPropertyInheritable(name)) {
          // update children's inheritable
          object.children.forEach(function (child) {
            child.internalSetAttribute(name, null, {
              skipUpdateAttribute: true,
              skipParse: true
            });
          });
        }
      });
    }
  }
  /**
   * string -> parsed value
   */;
  _proto.parseProperty = function parseProperty(name, value, object) {
    var metadata = propertyMetadataCache[name];
    var computed = value;
    if (value === '' || util.isNil(value)) {
      value = 'unset';
    }
    if (value === 'unset' || value === 'initial' || value === 'inherit') {
      // computed = new CSSKeywordValue(value);
      computed = getOrCreateKeyword(value);
    } else {
      if (metadata) {
        var keywords = metadata.k,
          syntax = metadata.syntax;
        var handler = syntax && this.getPropertySyntax(syntax);
        // use keywords
        if (keywords && keywords.indexOf(value) > -1) {
          // computed = new CSSKeywordValue(value);
          computed = getOrCreateKeyword(value);
        } else if (handler && handler.parser) {
          // try to parse it to CSSStyleValue, eg. '10px' -> CSS.px(10)
          computed = handler.parser(value, object);
        }
      }
    }
    return computed;
  }
  /**
   * computed value -> used value
   */;
  _proto.computeProperty = function computeProperty(name, computed, object) {
    var metadata = propertyMetadataCache[name];
    var isDocumentElement = object.id === 'g-root';
    // let used: CSSStyleValue = computed instanceof CSSStyleValue ? computed.clone() : computed;
    var used = computed;
    if (metadata) {
      var syntax = metadata.syntax,
        inherited = metadata.inh,
        defaultValue = metadata.d;
      if (computed instanceof CSSKeywordValue) {
        var value = computed.value;
        /**
         * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset
         */
        if (value === 'unset') {
          if (inherited && !isDocumentElement) {
            value = 'inherit';
          } else {
            value = 'initial';
          }
        }
        if (value === 'initial') {
          // @see https://developer.mozilla.org/en-US/docs/Web/CSS/initial
          if (!util.isNil(defaultValue)) {
            computed = this.parseProperty(name, isFunction(defaultValue) ? defaultValue(object.nodeName) : defaultValue, object);
          }
        } else if (value === 'inherit') {
          // @see https://developer.mozilla.org/en-US/docs/Web/CSS/inherit
          // behave like `inherit`
          var resolved = this.tryToResolveProperty(object, name, {
            inherited: true
          });
          if (!util.isNil(resolved)) {
            // object.parsedStyle[name] = resolved;
            // return false;
            return resolved;
          } else {
            this.addUnresolveProperty(object, name);
            return;
          }
        }
      }
      var handler = syntax && this.getPropertySyntax(syntax);
      if (handler && handler.calculator) {
        // convert computed value to used value
        var oldParsedValue = object.parsedStyle[name];
        used = handler.calculator(name, oldParsedValue, computed, object, this);
      } else if (computed instanceof CSSKeywordValue) {
        used = computed.value;
      } else {
        used = computed;
      }
    }
    // object.parsedStyle[name] = used;
    // return false;
    return used;
  };
  _proto.postProcessProperty = function postProcessProperty(name, object, attributes) {
    var metadata = propertyMetadataCache[name];
    if (metadata && metadata.syntax) {
      var handler = metadata.syntax && this.getPropertySyntax(metadata.syntax);
      var propertyHandler = handler;
      if (propertyHandler && propertyHandler.postProcessor) {
        propertyHandler.postProcessor(object, attributes);
      }
    }
  }
  /**
   * resolve later
   */;
  _proto.addUnresolveProperty = function addUnresolveProperty(object, name) {
    var properties = unresolvedProperties.get(object);
    if (!properties) {
      unresolvedProperties.set(object, []);
      properties = unresolvedProperties.get(object);
    }
    if (properties.indexOf(name) === -1) {
      properties.push(name);
    }
  };
  _proto.tryToResolveProperty = function tryToResolveProperty(object, name, options) {
    if (options === void 0) {
      options = {};
    }
    var _options2 = options,
      inherited = _options2.inherited;
    if (inherited) {
      if (object.parentElement && isPropertyResolved(object.parentElement, name)) {
        // const computedValue = object.parentElement.computedStyle[name];
        var usedValue = object.parentElement.parsedStyle[name];
        if (
        // usedValue instanceof CSSKeywordValue &&
        usedValue === 'unset' || usedValue === 'initial' || usedValue === 'inherit') {
          return;
        }
        // else if (
        //   usedValue instanceof CSSUnitValue &&
        //   CSSUnitValue.isRelativeUnit(usedValue.unit)
        // ) {
        //   return false;
        // }
        return usedValue;
      }
    }
    return;
  };
  _proto.recalc = function recalc(object) {
    var properties = unresolvedProperties.get(object);
    if (properties && properties.length) {
      var attributes = {};
      properties.forEach(function (property) {
        attributes[property] = object.attributes[property];
      });
      this.processProperties(object, attributes);
      unresolvedProperties.delete(object);
    }
  }
  /**
   * update geometry when relative props changed,
   * eg. r of Circle, width/height of Rect
   */;
  _proto.updateGeometry = function updateGeometry(object) {
    var geometryUpdater = runtime.geometryUpdaterFactory[object.nodeName];
    if (geometryUpdater) {
      var geometry = object.geometry;
      if (!geometry.contentBounds) {
        geometry.contentBounds = new AABB();
      }
      if (!geometry.renderBounds) {
        geometry.renderBounds = new AABB();
      }
      var parsedStyle = object.parsedStyle;
      var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object),
        width = _geometryUpdater$upda.width,
        height = _geometryUpdater$upda.height,
        _geometryUpdater$upda2 = _geometryUpdater$upda.depth,
        depth = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2,
        _geometryUpdater$upda3 = _geometryUpdater$upda.offsetX,
        offsetX = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3,
        _geometryUpdater$upda4 = _geometryUpdater$upda.offsetY,
        offsetY = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4,
        _geometryUpdater$upda5 = _geometryUpdater$upda.offsetZ,
        offsetZ = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5;
      // account for negative width / height of Rect
      // @see https://github.com/antvis/g/issues/957
      var flipY = width < 0;
      var flipX = height < 0;
      // init with content box
      var halfExtents = [Math.abs(width) / 2, Math.abs(height) / 2, depth / 2];
      // const halfExtents = vec3.set(
      //   tmpVec3a,
      //   Math.abs(width) / 2,
      //   Math.abs(height) / 2,
      //   depth / 2,
      // );
      // anchor is center by default, don't account for lineWidth here
      var stroke = parsedStyle.stroke,
        lineWidth = parsedStyle.lineWidth,
        increasedLineWidthForHitTesting = parsedStyle.increasedLineWidthForHitTesting,
        shadowType = parsedStyle.shadowType,
        shadowColor = parsedStyle.shadowColor,
        _parsedStyle$filter = parsedStyle.filter,
        filter = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter,
        transformOrigin = parsedStyle.transformOrigin;
      var anchor = parsedStyle.anchor;
      // <Text> use textAlign & textBaseline instead of anchor
      if (object.nodeName === exports.Shape.TEXT) {
        delete parsedStyle.anchor;
      }
      var center = [(1 - (anchor && anchor[0] || 0) * 2) * width / 2 + offsetX, (1 - (anchor && anchor[1] || 0) * 2) * height / 2 + offsetY, (1 - (anchor && anchor[2] || 0) * 2) * halfExtents[2] + offsetZ];
      // const center = vec3.set(
      //   tmpVec3b,
      //   ((1 - ((anchor && anchor[0]) || 0) * 2) * width) / 2 + offsetX,
      //   ((1 - ((anchor && anchor[1]) || 0) * 2) * height) / 2 + offsetY,
      //   (1 - ((anchor && anchor[2]) || 0) * 2) * halfExtents[2] + offsetZ,
      // );
      // update geometry's AABB
      geometry.contentBounds.update(center, halfExtents);
      // @see https://github.molgen.mpg.de/git-mirror/cairo/blob/master/src/cairo-stroke-style.c#L97..L128
      var expansion = object.nodeName === exports.Shape.POLYLINE || object.nodeName === exports.Shape.POLYGON || object.nodeName === exports.Shape.PATH ? Math.SQRT2 : 0.5;
      // if (lineCap?.value === 'square') {
      //   expansion = Math.SQRT1_2;
      // }
      // if (lineJoin?.value === 'miter' && expansion < Math.SQRT2 * miterLimit) {
      //   expansion = Math.SQRT1_2 * miterLimit;
      // }
      // append border only if stroke existed
      var hasStroke = stroke && !stroke.isNone;
      if (hasStroke) {
        var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
        // halfExtents[0] += halfLineWidth[0];
        // halfExtents[1] += halfLineWidth[1];
        halfExtents[0] += halfLineWidth;
        halfExtents[1] += halfLineWidth;
        // vec3.add(
        //   halfExtents,
        //   halfExtents,
        //   vec3.set(tmpVec3c, halfLineWidth, halfLineWidth, 0),
        // );
      }

      geometry.renderBounds.update(center, halfExtents);
      // account for shadow, only support constant value now
      if (shadowColor && shadowType && shadowType !== 'inner') {
        var _geometry$renderBound = geometry.renderBounds,
          min = _geometry$renderBound.min,
          max = _geometry$renderBound.max;
        var shadowBlur = parsedStyle.shadowBlur,
          shadowOffsetX = parsedStyle.shadowOffsetX,
          shadowOffsetY = parsedStyle.shadowOffsetY;
        var shadowBlurInPixels = shadowBlur || 0;
        var shadowOffsetXInPixels = shadowOffsetX || 0;
        var shadowOffsetYInPixels = shadowOffsetY || 0;
        var shadowLeft = min[0] - shadowBlurInPixels + shadowOffsetXInPixels;
        var shadowRight = max[0] + shadowBlurInPixels + shadowOffsetXInPixels;
        var shadowTop = min[1] - shadowBlurInPixels + shadowOffsetYInPixels;
        var shadowBottom = max[1] + shadowBlurInPixels + shadowOffsetYInPixels;
        min[0] = Math.min(min[0], shadowLeft);
        max[0] = Math.max(max[0], shadowRight);
        min[1] = Math.min(min[1], shadowTop);
        max[1] = Math.max(max[1], shadowBottom);
        geometry.renderBounds.setMinMax(min, max);
      }
      // account for filter, eg. blur(5px), drop-shadow()
      filter.forEach(function (_ref) {
        var name = _ref.name,
          params = _ref.params;
        if (name === 'blur') {
          var blurRadius = params[0].value;
          geometry.renderBounds.update(geometry.renderBounds.center, addVec3(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
        } else if (name === 'drop-shadow') {
          var _shadowOffsetX = params[0].value;
          var _shadowOffsetY = params[1].value;
          var _shadowBlur = params[2].value;
          var _geometry$renderBound2 = geometry.renderBounds,
            _min = _geometry$renderBound2.min,
            _max = _geometry$renderBound2.max;
          var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
          var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
          var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
          var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
          _min[0] = Math.min(_min[0], _shadowLeft);
          _max[0] = Math.max(_max[0], _shadowRight);
          _min[1] = Math.min(_min[1], _shadowTop);
          _max[1] = Math.max(_max[1], _shadowBottom);
          geometry.renderBounds.setMinMax(_min, _max);
        }
      });
      anchor = parsedStyle.anchor;
      geometry.dirty = false;
      // set transform origin
      var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object) : 0);
      var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object) : 0);
      usedOriginXValue = usedOriginXValue - (flipY ? -1 : 1) * (anchor && anchor[0] || 0) * geometry.contentBounds.halfExtents[0] * 2;
      usedOriginYValue = usedOriginYValue - (flipX ? -1 : 1) * (anchor && anchor[1] || 0) * geometry.contentBounds.halfExtents[1] * 2;
      object.setOrigin(usedOriginXValue, usedOriginYValue);
      // console.log('calc geometry', object);
      // FIXME setOrigin may have already dirtified to root.
      // runtime.sceneGraphService.dirtifyToRoot(object);
    }
  };
  _proto.isPropertyInheritable = function isPropertyInheritable(name) {
    var metadata = propertyMetadataCache[name];
    if (!metadata) {
      return false;
    }
    return metadata.inh;
  };
  return DefaultStyleValueRegistry;
}();

/**
 * Different type of cameras, eg. simple camera used in 2D scene or
 * advanced camera which can do actions & switch between landmarks.
 */
(function (CameraType) {
  /**
   * Performs all the rotational operations with the focal point instead of the camera position.
   * This type of camera is useful in applications(like CAD) where 3D objects are being designed or explored.
   * Camera cannot orbits over the north & south poles.
   * @see http://voxelent.com/tutorial-cameras/
   *
   * In Three.js it's used in OrbitControls.
   * @see https://threejs.org/docs/#examples/zh/controls/OrbitControls
   */
  CameraType[CameraType["ORBITING"] = 0] = "ORBITING";
  /**
   * It's similar to the ORBITING camera, but it allows the camera to orbit over the north or south poles.
   *
   * In Three.js it's used in OrbitControls.
   * @see https://threejs.org/docs/#examples/en/controls/TrackballControls
   */
  CameraType[CameraType["EXPLORING"] = 1] = "EXPLORING";
  /**
   * Performs all the rotational operations with the camera position.
   * It's useful in first person shooting games.
   * Camera cannot orbits over the north & south poles.
   *
   * In Three.js it's used in FirstPersonControls.
   * @see https://threejs.org/docs/#examples/en/controls/FirstPersonControls
   */
  CameraType[CameraType["TRACKING"] = 2] = "TRACKING";
})(exports.CameraType || (exports.CameraType = {}));
(function (CameraTrackingMode) {
  CameraTrackingMode[CameraTrackingMode["DEFAULT"] = 0] = "DEFAULT";
  CameraTrackingMode[CameraTrackingMode["ROTATIONAL"] = 1] = "ROTATIONAL";
  CameraTrackingMode[CameraTrackingMode["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
  CameraTrackingMode[CameraTrackingMode["CINEMATIC"] = 3] = "CINEMATIC";
})(exports.CameraTrackingMode || (exports.CameraTrackingMode = {}));
(function (CameraProjectionMode) {
  CameraProjectionMode[CameraProjectionMode["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
  CameraProjectionMode[CameraProjectionMode["PERSPECTIVE"] = 1] = "PERSPECTIVE";
})(exports.CameraProjectionMode || (exports.CameraProjectionMode = {}));
var CameraEvent = {
  UPDATED: 'updated'
};

var MIN_DISTANCE = 0.0002;
/**
 * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计
 * @see https://github.com/d13g0/nucleo.js/blob/master/source/camera/Camera.js
 *
 * 保存相机参数，定义相机动作：
 * 1. dolly 沿 n 轴移动
 * 2. pan 沿 u v 轴移动
 * 3. rotate 以方位角旋转
 * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互
 */
var Camera = /*#__PURE__*/function () {
  function Camera() {
    this.canvas = void 0;
    this.eventEmitter = new EventEmitter__default['default']();
    this.matrix = glMatrix.mat4.create();
    this.right = glMatrix.vec3.fromValues(1, 0, 0);
    this.up = glMatrix.vec3.fromValues(0, 1, 0);
    this.forward = glMatrix.vec3.fromValues(0, 0, 1);
    this.position = glMatrix.vec3.fromValues(0, 0, 1);
    this.focalPoint = glMatrix.vec3.fromValues(0, 0, 0);
    this.distanceVector = glMatrix.vec3.fromValues(0, 0, -1);
    this.distance = 1;
    this.azimuth = 0;
    this.elevation = 0;
    this.roll = 0;
    this.relAzimuth = 0;
    this.relElevation = 0;
    this.relRoll = 0;
    this.dollyingStep = 0;
    this.maxDistance = Infinity;
    this.minDistance = -Infinity;
    this.zoom = 1;
    this.rotateWorld = false;
    this.fov = 30;
    this.near = 0.1;
    this.far = 1000;
    this.aspect = 1;
    this.left = void 0;
    this.rright = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.projectionMatrix = glMatrix.mat4.create();
    this.projectionMatrixInverse = glMatrix.mat4.create();
    this.jitteredProjectionMatrix = undefined;
    this.view = void 0;
    this.enableUpdate = true;
    this.type = exports.CameraType.EXPLORING;
    this.trackingMode = exports.CameraTrackingMode.DEFAULT;
    this.projectionMode = exports.CameraProjectionMode.PERSPECTIVE;
    this.frustum = new Frustum();
    this.orthoMatrix = glMatrix.mat4.create();
  }
  var _proto = Camera.prototype;
  // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
  //   this.setType(type, trackingMode);
  // }
  _proto.isOrtho = function isOrtho() {
    return this.projectionMode === exports.CameraProjectionMode.ORTHOGRAPHIC;
  };
  _proto.getProjectionMode = function getProjectionMode() {
    return this.projectionMode;
  };
  _proto.getPerspective = function getPerspective() {
    // account for TAA
    return this.jitteredProjectionMatrix || this.projectionMatrix;
  };
  _proto.getPerspectiveInverse = function getPerspectiveInverse() {
    return this.projectionMatrixInverse;
  };
  _proto.getFrustum = function getFrustum() {
    return this.frustum;
  };
  _proto.getPosition = function getPosition() {
    return this.position;
  };
  _proto.getFocalPoint = function getFocalPoint() {
    return this.focalPoint;
  };
  _proto.getDollyingStep = function getDollyingStep() {
    return this.dollyingStep;
  };
  _proto.getNear = function getNear() {
    return this.near;
  };
  _proto.getFar = function getFar() {
    return this.far;
  };
  _proto.getZoom = function getZoom() {
    return this.zoom;
  };
  _proto.getOrthoMatrix = function getOrthoMatrix() {
    return this.orthoMatrix;
  };
  _proto.getView = function getView() {
    return this.view;
  };
  _proto.setEnableUpdate = function setEnableUpdate(enabled) {
    this.enableUpdate = enabled;
  };
  _proto.setType = function setType(type, trackingMode) {
    this.type = type;
    if (this.type === exports.CameraType.EXPLORING) {
      this.setWorldRotation(true);
    } else {
      this.setWorldRotation(false);
    }
    this._getAngles();
    if (this.type === exports.CameraType.TRACKING && trackingMode !== undefined) {
      this.setTrackingMode(trackingMode);
    }
    return this;
  };
  _proto.setProjectionMode = function setProjectionMode(projectionMode) {
    this.projectionMode = projectionMode;
    return this;
  };
  _proto.setTrackingMode = function setTrackingMode(trackingMode) {
    if (this.type !== exports.CameraType.TRACKING) {
      throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');
    }
    this.trackingMode = trackingMode;
    return this;
  }
  /**
   * If flag is true, it reverses the azimuth and elevation angles.
   * Subsequent calls to rotate, setAzimuth, setElevation,
   * changeAzimuth or changeElevation will cause the inverted effect.
   * setRoll or changeRoll is not affected by this method.
   *
   * This inversion is useful when one wants to simulate that the world
   * is moving, instead of the camera.
   *
   * By default the camera angles are not reversed.
   * @param {Boolean} flag the boolean flag to reverse the angles.
   */;
  _proto.setWorldRotation = function setWorldRotation(flag) {
    this.rotateWorld = flag;
    this._getAngles();
    return this;
  }
  /**
   * 计算 MV 矩阵，为相机矩阵的逆矩阵
   */;
  _proto.getViewTransform = function getViewTransform() {
    return glMatrix.mat4.invert(glMatrix.mat4.create(), this.matrix);
  };
  _proto.getWorldTransform = function getWorldTransform() {
    return this.matrix;
  };
  _proto.jitterProjectionMatrix = function jitterProjectionMatrix(x, y) {
    var translation = glMatrix.mat4.fromTranslation(glMatrix.mat4.create(), [x, y, 0]);
    this.jitteredProjectionMatrix = glMatrix.mat4.multiply(glMatrix.mat4.create(), translation, this.projectionMatrix);
  };
  _proto.clearJitterProjectionMatrix = function clearJitterProjectionMatrix() {
    this.jitteredProjectionMatrix = undefined;
  }
  /**
   * 设置相机矩阵
   */;
  _proto.setMatrix = function setMatrix(matrix) {
    this.matrix = matrix;
    this._update();
    return this;
  };
  _proto.setFov = function setFov(fov) {
    this.setPerspective(this.near, this.far, fov, this.aspect);
    return this;
  };
  _proto.setAspect = function setAspect(aspect) {
    this.setPerspective(this.near, this.far, this.fov, aspect);
    return this;
  };
  _proto.setNear = function setNear(near) {
    if (this.projectionMode === exports.CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
    }
    return this;
  };
  _proto.setFar = function setFar(far) {
    if (this.projectionMode === exports.CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
    }
    return this;
  }
  /**
   * Sets an offset in a larger frustum, used in PixelPicking
   */;
  _proto.setViewOffset = function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === undefined) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    if (this.projectionMode === exports.CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    }
    return this;
  };
  _proto.clearViewOffset = function clearViewOffset() {
    if (this.view !== undefined) {
      this.view.enabled = false;
    }
    if (this.projectionMode === exports.CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    } else {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    }
    return this;
  };
  _proto.setZoom = function setZoom(zoom) {
    this.zoom = zoom;
    if (this.projectionMode === exports.CameraProjectionMode.ORTHOGRAPHIC) {
      this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
    } else if (this.projectionMode === exports.CameraProjectionMode.PERSPECTIVE) {
      this.setPerspective(this.near, this.far, this.fov, this.aspect);
    }
    return this;
  }
  /**
   * Zoom by specified point in viewport coordinates.
   */;
  _proto.setZoomByViewportPoint = function setZoomByViewportPoint(zoom, viewportPoint) {
    var _this$canvas$viewport = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }),
      ox = _this$canvas$viewport.x,
      oy = _this$canvas$viewport.y;
    var roll = this.roll;
    this.rotate(0, 0, -roll);
    this.setPosition(ox, oy);
    this.setFocalPoint(ox, oy);
    this.setZoom(zoom);
    this.rotate(0, 0, roll);
    var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
        x: viewportPoint[0],
        y: viewportPoint[1]
      }),
      cx = _this$canvas$viewport2.x,
      cy = _this$canvas$viewport2.y;
    // project to rotated axis
    var dvec = glMatrix.vec3.fromValues(cx - ox, cy - oy, 0);
    var dx = glMatrix.vec3.dot(dvec, this.right) / glMatrix.vec3.length(this.right);
    var dy = glMatrix.vec3.dot(dvec, this.up) / glMatrix.vec3.length(this.up);
    this.pan(-dx, -dy);
    return this;
  };
  _proto.setPerspective = function setPerspective(near, far, fov, aspect) {
    var _this$view;
    this.projectionMode = exports.CameraProjectionMode.PERSPECTIVE;
    this.fov = fov;
    this.near = near;
    this.far = far;
    this.aspect = aspect;
    var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
    var height = 2 * top;
    var width = this.aspect * height;
    var left = -0.5 * width;
    if ((_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.enabled) {
      var fullWidth = this.view.fullWidth;
      var fullHeight = this.view.fullHeight;
      left += this.view.offsetX * width / fullWidth;
      top -= this.view.offsetY * height / fullHeight;
      width *= this.view.width / fullWidth;
      height *= this.view.height / fullHeight;
    }
    makePerspective(this.projectionMatrix, left, left + width, top, top - height, near, this.far);
    // flipY since the origin of OpenGL/WebGL is bottom-left compared with top-left in Canvas2D
    glMatrix.mat4.scale(this.projectionMatrix, this.projectionMatrix, glMatrix.vec3.fromValues(1, -1, 1));
    glMatrix.mat4.invert(this.projectionMatrixInverse, this.projectionMatrix);
    this.triggerUpdate();
    return this;
  };
  _proto.setOrthographic = function setOrthographic(l, r, t, b, near, far) {
    var _this$view2;
    this.projectionMode = exports.CameraProjectionMode.ORTHOGRAPHIC;
    this.rright = r;
    this.left = l;
    this.top = t;
    this.bottom = b;
    this.near = near;
    this.far = far;
    var dx = (this.rright - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.rright + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;
    if ((_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.enabled) {
      var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
      var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    glMatrix.mat4.ortho(this.projectionMatrix, left, right, bottom, top, near, far);
    // flipY since the origin of OpenGL/WebGL is bottom-left compared with top-left in Canvas2D
    glMatrix.mat4.scale(this.projectionMatrix, this.projectionMatrix, glMatrix.vec3.fromValues(1, -1, 1));
    glMatrix.mat4.invert(this.projectionMatrixInverse, this.projectionMatrix);
    this._getOrthoMatrix();
    this.triggerUpdate();
    return this;
  }
  /**
   * Move the camera in world coordinates.
   * It will keep looking at the current focal point.
   *
   * support scalars or vectors.
   * @example
   * setPosition(1, 2, 3);
   * setPosition([1, 2, 3]);
   */;
  _proto.setPosition = function setPosition(x, y, z) {
    if (y === void 0) {
      y = this.position[1];
    }
    if (z === void 0) {
      z = this.position[2];
    }
    var position = createVec3(x, y, z);
    this._setPosition(position);
    this.setFocalPoint(this.focalPoint);
    this.triggerUpdate();
    return this;
  }
  /**
   * Sets the focal point of this camera in world coordinates.
   *
   * support scalars or vectors.
   * @example
   * setFocalPoint(1, 2, 3);
   * setFocalPoint([1, 2, 3]);
   */;
  _proto.setFocalPoint = function setFocalPoint(x, y, z) {
    if (y === void 0) {
      y = this.focalPoint[1];
    }
    if (z === void 0) {
      z = this.focalPoint[2];
    }
    var up = glMatrix.vec3.fromValues(0, 1, 0);
    this.focalPoint = createVec3(x, y, z);
    if (this.trackingMode === exports.CameraTrackingMode.CINEMATIC) {
      var d = glMatrix.vec3.subtract(glMatrix.vec3.create(), this.focalPoint, this.position);
      x = d[0];
      y = d[1];
      z = d[2];
      var r = glMatrix.vec3.length(d);
      var el = rad2deg(Math.asin(y / r));
      var az = 90 + rad2deg(Math.atan2(z, x));
      var m = glMatrix.mat4.create();
      glMatrix.mat4.rotateY(m, m, deg2rad(az));
      glMatrix.mat4.rotateX(m, m, deg2rad(el));
      up = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), [0, 1, 0], m);
    }
    glMatrix.mat4.invert(this.matrix, glMatrix.mat4.lookAt(glMatrix.mat4.create(), this.position, this.focalPoint, up));
    this._getAxes();
    this._getDistance();
    this._getAngles();
    this.triggerUpdate();
    return this;
  };
  _proto.getDistance = function getDistance() {
    return this.distance;
  };
  _proto.getDistanceVector = function getDistanceVector() {
    return this.distanceVector;
  }
  /**
   * Moves the camera towards/from the focal point.
   */;
  _proto.setDistance = function setDistance(d) {
    if (this.distance === d || d < 0) {
      return this;
    }
    this.distance = d;
    if (this.distance < MIN_DISTANCE) {
      this.distance = MIN_DISTANCE;
    }
    this.dollyingStep = this.distance / 100;
    var pos = glMatrix.vec3.create();
    d = this.distance;
    var n = this.forward;
    var f = this.focalPoint;
    pos[0] = d * n[0] + f[0];
    pos[1] = d * n[1] + f[1];
    pos[2] = d * n[2] + f[2];
    this._setPosition(pos);
    this.triggerUpdate();
    return this;
  };
  _proto.setMaxDistance = function setMaxDistance(d) {
    this.maxDistance = d;
    return this;
  };
  _proto.setMinDistance = function setMinDistance(d) {
    this.minDistance = d;
    return this;
  }
  /**
   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
   * the azimuth in degrees
   */;
  _proto.setAzimuth = function setAzimuth(az) {
    this.azimuth = getAngle(az);
    this.computeMatrix();
    this._getAxes();
    if (this.type === exports.CameraType.ORBITING || this.type === exports.CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === exports.CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getAzimuth = function getAzimuth() {
    return this.azimuth;
  }
  /**
   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
   */;
  _proto.setElevation = function setElevation(el) {
    this.elevation = getAngle(el);
    this.computeMatrix();
    this._getAxes();
    if (this.type === exports.CameraType.ORBITING || this.type === exports.CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === exports.CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getElevation = function getElevation() {
    return this.elevation;
  }
  /**
   * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
   */;
  _proto.setRoll = function setRoll(angle) {
    this.roll = getAngle(angle);
    this.computeMatrix();
    this._getAxes();
    if (this.type === exports.CameraType.ORBITING || this.type === exports.CameraType.EXPLORING) {
      this._getPosition();
    } else if (this.type === exports.CameraType.TRACKING) {
      this._getFocalPoint();
    }
    this.triggerUpdate();
    return this;
  };
  _proto.getRoll = function getRoll() {
    return this.roll;
  }
  /**
   * 根据相机矩阵重新计算各种相机参数
   */;
  _proto._update = function _update() {
    this._getAxes();
    this._getPosition();
    this._getDistance();
    this._getAngles();
    this._getOrthoMatrix();
    this.triggerUpdate();
  }
  /**
   * 计算相机矩阵
   */;
  _proto.computeMatrix = function computeMatrix() {
    // 使用四元数描述 3D 旋转
    // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html
    var rotZ = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [0, 0, 1], deg2rad(this.roll));
    glMatrix.mat4.identity(this.matrix);
    // only consider HCS for EXPLORING and ORBITING cameras
    var rotX = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== exports.CameraType.TRACKING || this.type === exports.CameraType.TRACKING ? 1 : -1) * this.elevation));
    var rotY = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== exports.CameraType.TRACKING || this.type === exports.CameraType.TRACKING ? 1 : -1) * this.azimuth));
    var rotQ = glMatrix.quat.multiply(glMatrix.quat.create(), rotY, rotX);
    rotQ = glMatrix.quat.multiply(glMatrix.quat.create(), rotQ, rotZ);
    var rotMatrix = glMatrix.mat4.fromQuat(glMatrix.mat4.create(), rotQ);
    if (this.type === exports.CameraType.ORBITING || this.type === exports.CameraType.EXPLORING) {
      glMatrix.mat4.translate(this.matrix, this.matrix, this.focalPoint);
      glMatrix.mat4.multiply(this.matrix, this.matrix, rotMatrix);
      glMatrix.mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
    } else if (this.type === exports.CameraType.TRACKING) {
      glMatrix.mat4.translate(this.matrix, this.matrix, this.position);
      glMatrix.mat4.multiply(this.matrix, this.matrix, rotMatrix);
    }
  }
  /**
   * Sets the camera position in the camera matrix
   */;
  _proto._setPosition = function _setPosition(x, y, z) {
    this.position = createVec3(x, y, z);
    var m = this.matrix;
    m[12] = this.position[0];
    m[13] = this.position[1];
    m[14] = this.position[2];
    m[15] = 1;
    this._getOrthoMatrix();
  }
  /**
   * Recalculates axes based on the current matrix
   */;
  _proto._getAxes = function _getAxes() {
    glMatrix.vec3.copy(this.right, createVec3(glMatrix.vec4.transformMat4(glMatrix.vec4.create(), [1, 0, 0, 0], this.matrix)));
    glMatrix.vec3.copy(this.up, createVec3(glMatrix.vec4.transformMat4(glMatrix.vec4.create(), [0, 1, 0, 0], this.matrix)));
    glMatrix.vec3.copy(this.forward, createVec3(glMatrix.vec4.transformMat4(glMatrix.vec4.create(), [0, 0, 1, 0], this.matrix)));
    glMatrix.vec3.normalize(this.right, this.right);
    glMatrix.vec3.normalize(this.up, this.up);
    glMatrix.vec3.normalize(this.forward, this.forward);
  }
  /**
   * Recalculates euler angles based on the current state
   */;
  _proto._getAngles = function _getAngles() {
    // Recalculates angles
    var x = this.distanceVector[0];
    var y = this.distanceVector[1];
    var z = this.distanceVector[2];
    var r = glMatrix.vec3.length(this.distanceVector);
    // FAST FAIL: If there is no distance we cannot compute angles
    if (r === 0) {
      this.elevation = 0;
      this.azimuth = 0;
      return;
    }
    if (this.type === exports.CameraType.TRACKING) {
      this.elevation = rad2deg(Math.asin(y / r));
      this.azimuth = rad2deg(Math.atan2(-x, -z));
    } else {
      if (this.rotateWorld) {
        this.elevation = rad2deg(Math.asin(y / r));
        this.azimuth = rad2deg(Math.atan2(-x, -z));
      } else {
        this.elevation = -rad2deg(Math.asin(y / r));
        this.azimuth = -rad2deg(Math.atan2(-x, -z));
      }
    }
  }
  /**
   * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
   */;
  _proto._getPosition = function _getPosition() {
    glMatrix.vec3.copy(this.position, createVec3(glMatrix.vec4.transformMat4(glMatrix.vec4.create(), [0, 0, 0, 1], this.matrix)));
    // 相机位置变化，需要重新计算视距
    this._getDistance();
  }
  /**
   * 重新计算视点，只有 TRACKING 模式视点才会发生变化
   */;
  _proto._getFocalPoint = function _getFocalPoint() {
    glMatrix.vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], glMatrix.mat3.fromMat4(glMatrix.mat3.create(), this.matrix));
    glMatrix.vec3.add(this.focalPoint, this.position, this.distanceVector);
    // 视点变化，需要重新计算视距
    this._getDistance();
  }
  /**
   * 重新计算视距
   */;
  _proto._getDistance = function _getDistance() {
    this.distanceVector = glMatrix.vec3.subtract(glMatrix.vec3.create(), this.focalPoint, this.position);
    this.distance = glMatrix.vec3.length(this.distanceVector);
    this.dollyingStep = this.distance / 100;
  };
  _proto._getOrthoMatrix = function _getOrthoMatrix() {
    if (this.projectionMode !== exports.CameraProjectionMode.ORTHOGRAPHIC) {
      return;
    }
    var position = this.position;
    var rotZ = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [0, 0, 1], -this.roll * Math.PI / 180);
    glMatrix.mat4.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, glMatrix.vec3.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), glMatrix.vec3.fromValues(this.zoom, this.zoom, 1), position);
  };
  _proto.triggerUpdate = function triggerUpdate() {
    if (this.enableUpdate) {
      // update frustum
      var viewMatrix = this.getViewTransform();
      var vpMatrix = glMatrix.mat4.multiply(glMatrix.mat4.create(), this.getPerspective(), viewMatrix);
      this.getFrustum().extractFromVPMatrix(vpMatrix);
      this.eventEmitter.emit(CameraEvent.UPDATED);
    }
  };
  _proto.rotate = function rotate(azimuth, elevation, roll) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.pan = function pan(tx, ty) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.dolly = function dolly(value) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.createLandmark = function createLandmark(name, params) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.gotoLandmark = function gotoLandmark(name, options) {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  _proto.cancelLandmarkAnimation = function cancelLandmarkAnimation() {
    throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
  };
  return Camera;
}();

var CircleUpdater = /*#__PURE__*/function () {
  function CircleUpdater() {}
  var _proto = CircleUpdater.prototype;
  _proto.update = function update(parsedStyle, object) {
    var r = parsedStyle.r;
    var width = r * 2;
    var height = r * 2;
    return {
      width: width,
      height: height
    };
  };
  return CircleUpdater;
}();

var EllipseUpdater = /*#__PURE__*/function () {
  function EllipseUpdater() {}
  var _proto = EllipseUpdater.prototype;
  _proto.update = function update(parsedStyle, object) {
    var rx = parsedStyle.rx,
      ry = parsedStyle.ry;
    var width = rx * 2;
    var height = ry * 2;
    return {
      width: width,
      height: height
    };
  };
  return EllipseUpdater;
}();

var LineUpdater = /*#__PURE__*/function () {
  function LineUpdater() {}
  var _proto = LineUpdater.prototype;
  _proto.update = function update(parsedStyle) {
    var x1 = parsedStyle.x1,
      y1 = parsedStyle.y1,
      x2 = parsedStyle.x2,
      y2 = parsedStyle.y2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      width: width,
      height: height
    };
  };
  return LineUpdater;
}();

var PathUpdater = /*#__PURE__*/function () {
  function PathUpdater() {}
  var _proto = PathUpdater.prototype;
  _proto.update = function update(parsedStyle) {
    var path = parsedStyle.path;
    var _path$rect = path.rect,
      width = _path$rect.width,
      height = _path$rect.height;
    return {
      width: width,
      height: height
    };
  };
  return PathUpdater;
}();

var PolylineUpdater = /*#__PURE__*/function () {
  function PolylineUpdater() {}
  var _proto = PolylineUpdater.prototype;
  _proto.update = function update(parsedStyle) {
    var points = parsedStyle.points.points;
    // FIXME: account for miter lineJoin
    var minX = Math.min.apply(Math, points.map(function (point) {
      return point[0];
    }));
    var maxX = Math.max.apply(Math, points.map(function (point) {
      return point[0];
    }));
    var minY = Math.min.apply(Math, points.map(function (point) {
      return point[1];
    }));
    var maxY = Math.max.apply(Math, points.map(function (point) {
      return point[1];
    }));
    var width = maxX - minX;
    var height = maxY - minY;
    return {
      width: width,
      height: height
    };
  };
  return PolylineUpdater;
}();

var RectUpdater = /*#__PURE__*/function () {
  function RectUpdater() {}
  var _proto = RectUpdater.prototype;
  _proto.update = function update(parsedStyle, object) {
    var img = parsedStyle.img,
      _parsedStyle$width = parsedStyle.width,
      width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width,
      _parsedStyle$height = parsedStyle.height,
      height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
    var contentWidth = width;
    var contentHeight = height;
    // resize with HTMLImageElement's size
    if (img && !util.isString(img)) {
      if (!contentWidth) {
        contentWidth = img.width;
        parsedStyle.width = contentWidth;
      }
      if (!contentHeight) {
        contentHeight = img.height;
        parsedStyle.height = contentHeight;
      }
    }
    return {
      width: contentWidth,
      height: contentHeight
    };
  };
  return RectUpdater;
}();

var TextUpdater = /*#__PURE__*/function () {
  function TextUpdater(globalRuntime) {
    this.globalRuntime = void 0;
    this.globalRuntime = globalRuntime;
  }
  var _proto = TextUpdater.prototype;
  _proto.isReadyToMeasure = function isReadyToMeasure(parsedStyle, object) {
    var text = parsedStyle.text,
      textAlign = parsedStyle.textAlign,
      textBaseline = parsedStyle.textBaseline,
      fontSize = parsedStyle.fontSize,
      fontStyle = parsedStyle.fontStyle,
      fontWeight = parsedStyle.fontWeight,
      fontVariant = parsedStyle.fontVariant,
      lineWidth = parsedStyle.lineWidth;
    return text && fontSize && fontStyle && fontWeight && fontVariant && textAlign && textBaseline && !util.isNil(lineWidth);
  };
  _proto.update = function update(parsedStyle, object) {
    var _object$ownerDocument, _object$ownerDocument2;
    var text = parsedStyle.text,
      textAlign = parsedStyle.textAlign,
      lineWidth = parsedStyle.lineWidth,
      textBaseline = parsedStyle.textBaseline,
      dx = parsedStyle.dx,
      dy = parsedStyle.dy;
    var _ref = (object === null || object === void 0 ? void 0 : (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 ? void 0 : (_object$ownerDocument2 = _object$ownerDocument.defaultView) === null || _object$ownerDocument2 === void 0 ? void 0 : _object$ownerDocument2.getConfig()) || {},
      offscreenCanvas = _ref.offscreenCanvas;
    if (!this.isReadyToMeasure(parsedStyle, object)) {
      parsedStyle.metrics = {
        font: '',
        width: 0,
        height: 0,
        lines: [],
        lineWidths: [],
        lineHeight: 0,
        maxLineWidth: 0,
        fontProperties: {
          ascent: 0,
          descent: 0,
          fontSize: 0
        },
        lineMetrics: []
      };
      return {
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0
      };
    }
    var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
    parsedStyle.metrics = metrics;
    var width = metrics.width,
      height = metrics.height,
      lineHeight = metrics.lineHeight,
      fontProperties = metrics.fontProperties;
    // anchor is left-top by default
    var halfExtents = [width / 2, height / 2, 0];
    // default 'left'
    var anchor = [0, 1];
    var lineXOffset = 0;
    if (textAlign === 'center' || textAlign === 'middle') {
      lineXOffset = lineWidth / 2;
      anchor = [0.5, 1];
    } else if (textAlign === 'right' || textAlign === 'end') {
      lineXOffset = lineWidth;
      anchor = [1, 1];
    }
    var lineYOffset = 0;
    if (textBaseline === 'middle') {
      // eslint-disable-next-line prefer-destructuring
      lineYOffset = halfExtents[1];
    } else if (textBaseline === 'top' || textBaseline === 'hanging') {
      lineYOffset = halfExtents[1] * 2;
    } else if (textBaseline === 'alphabetic') {
      // prevent calling getImageData for ascent metrics
      lineYOffset = runtime.enableCSSParsing ? lineHeight - fontProperties.ascent : 0;
    } else if (textBaseline === 'bottom' || textBaseline === 'ideographic') {
      lineYOffset = 0;
    }
    // TODO: ideographic & bottom
    if (dx) {
      lineXOffset += dx;
    }
    if (dy) {
      lineYOffset += dy;
    }
    // update anchor
    parsedStyle.anchor = [anchor[0], anchor[1], 0];
    return {
      width: halfExtents[0] * 2,
      height: halfExtents[1] * 2,
      offsetX: lineXOffset,
      offsetY: lineYOffset
    };
  };
  return TextUpdater;
}();

var PROPAGATION_LIMIT = 2048;
var EventService = /*#__PURE__*/function () {
  function EventService(globalRuntime, context) {
    var _this = this;
    this.globalRuntime = void 0;
    this.context = void 0;
    this.rootTarget = void 0;
    this.emitter = new EventEmitter__default['default']();
    this.cursor = 'default';
    this.mappingTable = {};
    this.mappingState = {
      trackingData: {}
    };
    this.eventPool = new Map();
    this.pickHandler = void 0;
    this.tmpMatrix = glMatrix.mat4.create();
    this.tmpVec3 = glMatrix.vec3.create();
    this.onPointerDown = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(from) {
        var e, isRightButton, trackingData;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.createPointerEvent(from);
              case 2:
                e = _context.sent;
                _this.dispatchEvent(e, 'pointerdown');
                if (e.pointerType === 'touch') {
                  _this.dispatchEvent(e, 'touchstart');
                } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
                  isRightButton = e.button === 2;
                  _this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');
                }
                trackingData = _this.trackingData(from.pointerId);
                trackingData.pressTargetsByButton[from.button] = e.composedPath();
                _this.freeEvent(e);
              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
    this.onPointerUp = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(from) {
        var now, e, isRightButton, trackingData, pressTarget, clickTarget, currentTarget, _isRightButton, _e$detail, clickEvent, clickHistory;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // if (!(from instanceof FederatedPointerEvent)) {
                //   return;
                // }
                now = performance.now();
                _context2.next = 3;
                return _this.createPointerEvent(from);
              case 3:
                e = _context2.sent;
                _this.dispatchEvent(e, 'pointerup');
                if (e.pointerType === 'touch') {
                  _this.dispatchEvent(e, 'touchend');
                } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
                  isRightButton = e.button === 2;
                  _this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');
                }
                trackingData = _this.trackingData(from.pointerId);
                pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
                clickTarget = pressTarget; // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain
                // the pointerup location.
                if (pressTarget && !e.composedPath().includes(pressTarget)) {
                  currentTarget = pressTarget;
                  while (currentTarget && !e.composedPath().includes(currentTarget)) {
                    e.currentTarget = currentTarget;
                    _this.notifyTarget(e, 'pointerupoutside');
                    if (e.pointerType === 'touch') {
                      _this.notifyTarget(e, 'touchendoutside');
                    } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
                      _isRightButton = e.button === 2;
                      _this.notifyTarget(e, _isRightButton ? 'rightupoutside' : 'mouseupoutside');
                    }
                    if (Node.isNode(currentTarget)) {
                      currentTarget = currentTarget.parentNode;
                    }
                  }
                  delete trackingData.pressTargetsByButton[from.button];
                  // currentTarget is the most specific ancestor holding both the pointerdown and pointerup
                  // targets. That is - it's our click target!
                  clickTarget = currentTarget;
                }
                if (clickTarget) {
                  clickEvent = _this.clonePointerEvent(e, 'click');
                  clickEvent.target = clickTarget;
                  clickEvent.path = [];
                  if (!trackingData.clicksByButton[from.button]) {
                    trackingData.clicksByButton[from.button] = {
                      clickCount: 0,
                      target: clickEvent.target,
                      timeStamp: now
                    };
                  }
                  clickHistory = trackingData.clicksByButton[from.button];
                  if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
                    ++clickHistory.clickCount;
                  } else {
                    clickHistory.clickCount = 1;
                  }
                  clickHistory.target = clickEvent.target;
                  clickHistory.timeStamp = now;
                  clickEvent.detail = clickHistory.clickCount;
                  // @see https://github.com/antvis/G/issues/1091
                  if (!((_e$detail = e.detail) === null || _e$detail === void 0 ? void 0 : _e$detail.preventClick)) {
                    if (clickEvent.pointerType === 'mouse' || clickEvent.pointerType === 'touch') {
                      _this.dispatchEvent(clickEvent, 'click');
                    }
                    _this.dispatchEvent(clickEvent, 'pointertap');
                  }
                  _this.freeEvent(clickEvent);
                }
                _this.freeEvent(e);
              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }();
    this.onPointerMove = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(from) {
        var e, isMouse, trackingData, outTarget, outType, outEvent, leaveEvent, overType, overEvent, overTargetAncestor, didPointerEnter, enterEvent;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _this.createPointerEvent(from);
              case 2:
                e = _context3.sent;
                isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';
                trackingData = _this.trackingData(from.pointerId);
                outTarget = _this.findMountedTarget(trackingData.overTargets); // First pointerout/pointerleave
                if (!(trackingData.overTargets && outTarget !== e.target)) {
                  _context3.next = 21;
                  break;
                }
                // pointerout always occurs on the overTarget when the pointer hovers over another element.
                outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';
                _context3.next = 10;
                return _this.createPointerEvent(from, outType, outTarget || undefined);
              case 10:
                outEvent = _context3.sent;
                _this.dispatchEvent(outEvent, 'pointerout');
                if (isMouse) _this.dispatchEvent(outEvent, 'mouseout');
                // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event
                // is dispatched to all ancestors that no longer capture the pointer.
                if (e.composedPath().includes(outTarget)) {
                  _context3.next = 20;
                  break;
                }
                _context3.next = 16;
                return _this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
              case 16:
                leaveEvent = _context3.sent;
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
                  leaveEvent.currentTarget = leaveEvent.target;
                  _this.notifyTarget(leaveEvent);
                  if (isMouse) {
                    _this.notifyTarget(leaveEvent, 'mouseleave');
                  }
                  if (Node.isNode(leaveEvent.target)) {
                    leaveEvent.target = leaveEvent.target.parentNode;
                  }
                }
                _this.freeEvent(leaveEvent);
              case 20:
                _this.freeEvent(outEvent);
              case 21:
                if (!(outTarget !== e.target)) {
                  _context3.next = 36;
                  break;
                }
                // pointerover always occurs on the new overTarget
                overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';
                overEvent = _this.clonePointerEvent(e, overType); // clone faster
                _this.dispatchEvent(overEvent, 'pointerover');
                if (isMouse) _this.dispatchEvent(overEvent, 'mouseover');
                // Probe whether the newly hovered Node is an ancestor of the original overTarget.
                overTargetAncestor = outTarget && Node.isNode(outTarget) && outTarget.parentNode;
              case 27:
                if (!(overTargetAncestor && overTargetAncestor !== (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode))) {
                  _context3.next = 33;
                  break;
                }
                if (!(overTargetAncestor === e.target)) {
                  _context3.next = 30;
                  break;
                }
                return _context3.abrupt("break", 33);
              case 30:
                overTargetAncestor = overTargetAncestor.parentNode;
                _context3.next = 27;
                break;
              case 33:
                // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered
                // event.
                didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode);
                if (didPointerEnter) {
                  enterEvent = _this.clonePointerEvent(e, 'pointerenter');
                  enterEvent.eventPhase = enterEvent.AT_TARGET;
                  while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
                    enterEvent.currentTarget = enterEvent.target;
                    _this.notifyTarget(enterEvent);
                    if (isMouse) _this.notifyTarget(enterEvent, 'mouseenter');
                    if (Node.isNode(enterEvent.target)) {
                      enterEvent.target = enterEvent.target.parentNode;
                    }
                  }
                  _this.freeEvent(enterEvent);
                }
                _this.freeEvent(overEvent);
              case 36:
                // Then pointermove
                _this.dispatchEvent(e, 'pointermove');
                if (e.pointerType === 'touch') _this.dispatchEvent(e, 'touchmove');
                if (isMouse) {
                  _this.dispatchEvent(e, 'mousemove');
                  _this.cursor = _this.getCursor(e.target);
                }
                trackingData.overTargets = e.composedPath();
                _this.freeEvent(e);
              case 41:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }();
    this.onPointerOut = /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(from) {
        var trackingData, isMouse, outTarget, outEvent, leaveEvent;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // if (!(from instanceof FederatedPointerEvent)) {
                //   return;
                // }
                trackingData = _this.trackingData(from.pointerId);
                if (!trackingData.overTargets) {
                  _context4.next = 17;
                  break;
                }
                isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';
                outTarget = _this.findMountedTarget(trackingData.overTargets); // pointerout first
                _context4.next = 6;
                return _this.createPointerEvent(from, 'pointerout', outTarget || undefined);
              case 6:
                outEvent = _context4.sent;
                _this.dispatchEvent(outEvent);
                if (isMouse) _this.dispatchEvent(outEvent, 'mouseout');
                // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to
                // get an upstream pointerout event (upstream events do not know rootTarget has descendants).
                _context4.next = 11;
                return _this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
              case 11:
                leaveEvent = _context4.sent;
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while (leaveEvent.target && leaveEvent.target !== (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
                  leaveEvent.currentTarget = leaveEvent.target;
                  _this.notifyTarget(leaveEvent);
                  if (isMouse) {
                    _this.notifyTarget(leaveEvent, 'mouseleave');
                  }
                  if (Node.isNode(leaveEvent.target)) {
                    leaveEvent.target = leaveEvent.target.parentNode;
                  }
                }
                trackingData.overTargets = null;
                _this.freeEvent(outEvent);
                _this.freeEvent(leaveEvent);
              case 17:
                _this.cursor = null;
              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return function (_x4) {
        return _ref4.apply(this, arguments);
      };
    }();
    this.onPointerOver = /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(from) {
        var trackingData, e, isMouse, enterEvent;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // if (!(from instanceof FederatedPointerEvent)) {
                //   return;
                // }
                trackingData = _this.trackingData(from.pointerId);
                _context5.next = 3;
                return _this.createPointerEvent(from);
              case 3:
                e = _context5.sent;
                isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';
                _this.dispatchEvent(e, 'pointerover');
                if (isMouse) _this.dispatchEvent(e, 'mouseover');
                if (e.pointerType === 'mouse') _this.cursor = _this.getCursor(e.target);
                // pointerenter events must be fired since the pointer entered from upstream.
                enterEvent = _this.clonePointerEvent(e, 'pointerenter');
                enterEvent.eventPhase = enterEvent.AT_TARGET;
                while (enterEvent.target && enterEvent.target !== (Node.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
                  enterEvent.currentTarget = enterEvent.target;
                  _this.notifyTarget(enterEvent);
                  if (isMouse) {
                    // mouseenter should not bubble
                    // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event#usage_notes
                    _this.notifyTarget(enterEvent, 'mouseenter');
                  }
                  if (Node.isNode(enterEvent.target)) {
                    enterEvent.target = enterEvent.target.parentNode;
                  }
                }
                trackingData.overTargets = e.composedPath();
                _this.freeEvent(e);
                _this.freeEvent(enterEvent);
              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return function (_x5) {
        return _ref5.apply(this, arguments);
      };
    }();
    this.onPointerUpOutside = /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(from) {
        var trackingData, pressTarget, e, currentTarget;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                // if (!(from instanceof FederatedPointerEvent)) {
                //   return;
                // }
                trackingData = _this.trackingData(from.pointerId);
                pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
                _context6.next = 4;
                return _this.createPointerEvent(from);
              case 4:
                e = _context6.sent;
                if (pressTarget) {
                  currentTarget = pressTarget;
                  while (currentTarget) {
                    e.currentTarget = currentTarget;
                    _this.notifyTarget(e, 'pointerupoutside');
                    if (e.pointerType === 'touch') ; else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
                      _this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');
                    }
                    if (Node.isNode(currentTarget)) {
                      currentTarget = currentTarget.parentNode;
                    }
                  }
                  delete trackingData.pressTargetsByButton[from.button];
                }
                _this.freeEvent(e);
              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      return function (_x6) {
        return _ref6.apply(this, arguments);
      };
    }();
    this.onWheel = /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(from) {
        var wheelEvent;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _this.createWheelEvent(from);
              case 2:
                wheelEvent = _context7.sent;
                _this.dispatchEvent(wheelEvent);
                _this.freeEvent(wheelEvent);
              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      return function (_x7) {
        return _ref7.apply(this, arguments);
      };
    }();
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  var _proto = EventService.prototype;
  _proto.init = function init() {
    this.rootTarget = this.context.renderingContext.root.parentNode; // document
    this.addEventMapping('pointerdown', this.onPointerDown);
    this.addEventMapping('pointerup', this.onPointerUp);
    this.addEventMapping('pointermove', this.onPointerMove);
    this.addEventMapping('pointerout', this.onPointerOut);
    this.addEventMapping('pointerleave', this.onPointerOut);
    this.addEventMapping('pointerover', this.onPointerOver);
    this.addEventMapping('pointerupoutside', this.onPointerUpOutside);
    this.addEventMapping('wheel', this.onWheel);
  };
  _proto.destroy = function destroy() {
    this.emitter.removeAllListeners();
    this.mappingTable = {};
    this.mappingState = {};
    this.eventPool.clear();
  };
  _proto.client2Viewport = function client2Viewport(client) {
    var bbox = this.context.contextService.getBoundingClientRect();
    return new Point(client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
  };
  _proto.viewport2Client = function viewport2Client(canvas) {
    var bbox = this.context.contextService.getBoundingClientRect();
    return new Point(canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
  };
  _proto.viewport2Canvas = function viewport2Canvas(_ref8) {
    var x = _ref8.x,
      y = _ref8.y;
    var canvas = this.rootTarget.defaultView;
    var camera = canvas.getCamera();
    var _this$context$config = this.context.config,
      width = _this$context$config.width,
      height = _this$context$config.height;
    var projectionMatrixInverse = camera.getPerspectiveInverse();
    var worldMatrix = camera.getWorldTransform();
    var vpMatrix = glMatrix.mat4.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
    var viewport = glMatrix.vec3.set(this.tmpVec3, x / width * 2 - 1, (1 - y / height) * 2 - 1, 0);
    glMatrix.vec3.transformMat4(viewport, viewport, vpMatrix);
    return new Point(viewport[0], viewport[1]);
  };
  _proto.canvas2Viewport = function canvas2Viewport(canvasP) {
    var canvas = this.rootTarget.defaultView;
    var camera = canvas.getCamera();
    // World -> Clip
    var projectionMatrix = camera.getPerspective();
    var viewMatrix = camera.getViewTransform();
    var vpMatrix = glMatrix.mat4.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
    var clip = glMatrix.vec3.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
    glMatrix.vec3.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
    // Clip -> NDC -> Viewport, flip Y
    var _this$context$config2 = this.context.config,
      width = _this$context$config2.width,
      height = _this$context$config2.height;
    return new Point((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
  };
  _proto.setPickHandler = function setPickHandler(pickHandler) {
    this.pickHandler = pickHandler;
  };
  _proto.addEventMapping = function addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn: fn,
      priority: 0
    });
    this.mappingTable[type].sort(function (a, b) {
      return a.priority - b.priority;
    });
  };
  _proto.mapEvent = function mapEvent(e) {
    if (!this.rootTarget) {
      return;
    }
    var mappers = this.mappingTable[e.type];
    if (mappers) {
      for (var i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e);
      }
    } else {
      console.warn("[EventService]: Event mapping not defined for " + e.type);
    }
  };
  _proto.dispatchEvent = function dispatchEvent(e, type, skipPropagate) {
    // Canvas should skip
    if (!skipPropagate) {
      e.propagationStopped = false;
      e.propagationImmediatelyStopped = false;
      this.propagate(e, type);
    } else {
      // target phase
      e.eventPhase = e.AT_TARGET;
      var canvas = this.rootTarget.defaultView || null;
      e.currentTarget = canvas;
      this.notifyListeners(e, type);
    }
    this.emitter.emit(type || e.type, e);
  };
  _proto.propagate = function propagate(e, type) {
    if (!e.target) {
      return;
    }
    // [target, parent, root, Canvas]
    var composedPath = e.composedPath();
    // event flow: capture -> target -> bubbling
    // capture phase
    e.eventPhase = e.CAPTURING_PHASE;
    for (var i = composedPath.length - 1; i >= 1; i--) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped) return;
    }
    // target phase
    e.eventPhase = e.AT_TARGET;
    e.currentTarget = e.target;
    this.notifyTarget(e, type);
    if (e.propagationStopped || e.propagationImmediatelyStopped) return;
    // find current target in composed path
    var index = composedPath.indexOf(e.currentTarget);
    // bubbling phase
    e.eventPhase = e.BUBBLING_PHASE;
    for (var _i = index + 1; _i < composedPath.length; _i++) {
      e.currentTarget = composedPath[_i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped) return;
    }
  };
  _proto.propagationPath = function propagationPath(target) {
    var propagationPath = [target];
    var canvas = this.rootTarget.defaultView || null;
    if (canvas && canvas === target) {
      propagationPath.unshift(canvas.document);
      return propagationPath;
    }
    for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
      // if (Node.isNode(target) && !target.parentNode) {
      //   throw new Error('Cannot find propagation path to disconnected target');
      // }
      if (Node.isNode(target) && target.parentNode) {
        // [target, parent, parent, root]
        propagationPath.push(target.parentNode);
        target = target.parentNode;
      }
    }
    if (canvas) {
      // @ts-ignore
      propagationPath.push(canvas);
    }
    return propagationPath;
  };
  _proto.hitTest = /*#__PURE__*/function () {
    var _hitTest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(position) {
      var viewportX, viewportY, _this$context$config3, width, height;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              viewportX = position.viewportX, viewportY = position.viewportY;
              _this$context$config3 = this.context.config, width = _this$context$config3.width, height = _this$context$config3.height; // outside canvas
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context8.next = 4;
                break;
              }
              return _context8.abrupt("return", null);
            case 4:
              _context8.next = 6;
              return this.pickHandler(position);
            case 6:
              _context8.t1 = _context8.sent;
              if (_context8.t1) {
                _context8.next = 9;
                break;
              }
              _context8.t1 = this.rootTarget;
            case 9:
              _context8.t0 = _context8.t1;
              if (_context8.t0) {
                _context8.next = 12;
                break;
              }
              _context8.t0 =
              // return Document
              null;
            case 12:
              return _context8.abrupt("return", _context8.t0);
            case 13:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));
    function hitTest(_x8) {
      return _hitTest.apply(this, arguments);
    }
    return hitTest;
  }()
  /**
   * whether the native event trigger came from Canvas,
   * should account for HTML shape
   */
  ;
  _proto.isNativeEventFromCanvas = function isNativeEventFromCanvas(event) {
    var _event$nativeEvent;
    var $el = this.context.contextService.getDomElement();
    var target = (_event$nativeEvent = event.nativeEvent) === null || _event$nativeEvent === void 0 ? void 0 : _event$nativeEvent.target;
    if (target) {
      // from <canvas>
      if (target === $el) {
        return true;
      }
      // from <svg>
      if ($el && $el.contains) {
        return $el.contains(target);
      }
    }
    if (event.nativeEvent.composedPath) {
      return event.nativeEvent.composedPath().indexOf($el) > -1;
    }
    // account for Touch
    return false;
  };
  _proto.getExistedHTML = function getExistedHTML(event) {
    if (event.nativeEvent.composedPath) {
      var htmls = this.globalRuntime.displayObjectPool.getHTMLs();
      for (var _iterator = _createForOfIteratorHelperLoose(htmls), _step; !(_step = _iterator()).done;) {
        var html = _step.value;
        if (event.nativeEvent.composedPath().indexOf(html) > -1) {
          return html;
        }
      }
    }
    return null;
  };
  _proto.pickTarget = /*#__PURE__*/function () {
    var _pickTarget = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(event) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", this.hitTest({
                clientX: event.clientX,
                clientY: event.clientY,
                viewportX: event.viewportX,
                viewportY: event.viewportY,
                x: event.canvasX,
                y: event.canvasY
              }));
            case 1:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));
    function pickTarget(_x9) {
      return _pickTarget.apply(this, arguments);
    }
    return pickTarget;
  }();
  _proto.createPointerEvent = /*#__PURE__*/function () {
    var _createPointerEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(from, type, target) {
      var event, existedHTML;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              event = this.allocateEvent(FederatedPointerEvent);
              this.copyPointerData(from, event);
              this.copyMouseData(from, event);
              this.copyData(from, event);
              event.nativeEvent = from.nativeEvent;
              event.originalEvent = from;
              existedHTML = this.getExistedHTML(event);
              if (!(target !== null && target !== void 0)) {
                _context10.next = 11;
                break;
              }
              _context10.t0 = target;
              _context10.next = 20;
              break;
            case 11:
              _context10.t1 = existedHTML;
              if (_context10.t1) {
                _context10.next = 19;
                break;
              }
              _context10.t2 = this.isNativeEventFromCanvas(event);
              if (!_context10.t2) {
                _context10.next = 18;
                break;
              }
              _context10.next = 17;
              return this.pickTarget(event);
            case 17:
              _context10.t2 = _context10.sent;
            case 18:
              _context10.t1 = _context10.t2;
            case 19:
              _context10.t0 = _context10.t1;
            case 20:
              event.target = _context10.t0;
              if (typeof type === 'string') {
                event.type = type;
              }
              return _context10.abrupt("return", event);
            case 23:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));
    function createPointerEvent(_x10, _x11, _x12) {
      return _createPointerEvent.apply(this, arguments);
    }
    return createPointerEvent;
  }();
  _proto.createWheelEvent = /*#__PURE__*/function () {
    var _createWheelEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(from) {
      var event, existedHTML;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              event = this.allocateEvent(FederatedWheelEvent);
              this.copyWheelData(from, event);
              this.copyMouseData(from, event);
              this.copyData(from, event);
              event.nativeEvent = from.nativeEvent;
              event.originalEvent = from;
              existedHTML = this.getExistedHTML(event);
              _context11.t0 = existedHTML;
              if (_context11.t0) {
                _context11.next = 15;
                break;
              }
              _context11.t1 = this.isNativeEventFromCanvas(event);
              if (!_context11.t1) {
                _context11.next = 14;
                break;
              }
              _context11.next = 13;
              return this.pickTarget(event);
            case 13:
              _context11.t1 = _context11.sent;
            case 14:
              _context11.t0 = _context11.t1;
            case 15:
              event.target = _context11.t0;
              return _context11.abrupt("return", event);
            case 17:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));
    function createWheelEvent(_x13) {
      return _createWheelEvent.apply(this, arguments);
    }
    return createWheelEvent;
  }();
  _proto.trackingData = function trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  };
  _proto.cloneWheelEvent = function cloneWheelEvent(from) {
    var event = this.allocateEvent(FederatedWheelEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = from.type;
    return event;
  };
  _proto.clonePointerEvent = function clonePointerEvent(from, type) {
    var event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type !== null && type !== void 0 ? type : event.type;
    return event;
  };
  _proto.copyPointerData = function copyPointerData(from, to) {
    // if (
    //   !(
    //     from instanceof FederatedPointerEvent &&
    //     to instanceof FederatedPointerEvent
    //   )
    // )
    //   return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  };
  _proto.copyMouseData = function copyMouseData(from, to) {
    // if (
    //   !(
    //     from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent
    //   )
    // )
    //   return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.shiftKey = from.shiftKey;
    to.client.copyFrom(from.client);
    to.movement.copyFrom(from.movement);
    to.canvas.copyFrom(from.canvas);
    to.screen.copyFrom(from.screen);
    to.global.copyFrom(from.global);
    to.offset.copyFrom(from.offset);
  };
  _proto.copyWheelData = function copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  };
  _proto.copyData = function copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.page.copyFrom(from.page);
    to.viewport.copyFrom(from.viewport);
  };
  _proto.allocateEvent = function allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    // @ts-ignore
    var event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.path = [];
    event.target = null;
    return event;
  };
  _proto.freeEvent = function freeEvent(event) {
    if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');
    var constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    // @ts-ignore
    this.eventPool.get(constructor).push(event);
  };
  _proto.notifyTarget = function notifyTarget(e, type) {
    var _type;
    type = (_type = type) !== null && _type !== void 0 ? _type : e.type;
    var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? type + "capture" : type;
    this.notifyListeners(e, key);
    if (e.eventPhase === e.AT_TARGET) {
      this.notifyListeners(e, type);
    }
  };
  _proto.notifyListeners = function notifyListeners(e, type) {
    // hack EventEmitter, stops if the `propagationImmediatelyStopped` flag is set
    // @ts-ignore
    var emitter = e.currentTarget.emitter;
    // @ts-ignore
    var listeners = emitter._events[type];
    if (!listeners) return;
    if ('fn' in listeners) {
      if (listeners.once) {
        emitter.removeListener(type, listeners.fn, undefined, true);
      }
      listeners.fn.call(e.currentTarget || listeners.context, e);
      // listeners.fn.call(listeners.context, e);
    } else {
      for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
        if (listeners[i].once) {
          emitter.removeListener(type, listeners[i].fn, undefined, true);
        }
        listeners[i].fn.call(e.currentTarget || listeners[i].context, e);
        // listeners[i].fn.call(listeners[i].context, e);
      }
    }
  }
  /**
   * some detached nodes may exist in propagation path, need to skip them
   */;
  _proto.findMountedTarget = function findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    var currentTarget = propagationPath[propagationPath.length - 1];
    for (var i = propagationPath.length - 2; i >= 0; i--) {
      var target = propagationPath[i];
      if (target === this.rootTarget || Node.isNode(target) && target.parentNode === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  };
  _proto.getCursor = function getCursor(target) {
    var tmp = target;
    while (tmp) {
      var cursor = Element.isElement(tmp) && tmp.getAttribute('cursor');
      if (cursor) {
        return cursor;
      }
      tmp = Node.isNode(tmp) && tmp.parentNode;
    }
  };
  return EventService;
}();

/**
 * used in following scenes:
 * - g `ctx.measureText`
 * - g-plugin-canvas-picker `ctx.isPointInPath`
 * - g-plugin-device-renderer `ctx.createLinearGradient` and generate texture
 *
 * @see https://blog.scottlogic.com/2020/03/19/offscreen-canvas.html
 */
var OffscreenCanvasCreator = /*#__PURE__*/function () {
  function OffscreenCanvasCreator() {
    this.canvas = void 0;
    this.context = void 0;
  }
  var _proto = OffscreenCanvasCreator.prototype;
  _proto.getOrCreateCanvas = function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
    if (this.canvas) {
      return this.canvas;
    }
    // user-defined offscreen canvas
    if (offscreenCanvas) {
      this.canvas = offscreenCanvas;
      this.context = this.canvas.getContext('2d', contextAttributes);
    } else {
      try {
        // OffscreenCanvas2D measureText can be up to 40% faster.
        this.canvas = new window.OffscreenCanvas(0, 0);
        this.context = this.canvas.getContext('2d', contextAttributes);
        if (!this.context || !this.context.measureText) {
          this.canvas = document.createElement('canvas');
          this.context = this.canvas.getContext('2d');
        }
      } catch (ex) {
        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d', contextAttributes);
      }
    }
    this.canvas.width = 10;
    this.canvas.height = 10;
    return this.canvas;
  };
  _proto.getOrCreateContext = function getOrCreateContext(offscreenCanvas, contextAttributes) {
    if (this.context) {
      return this.context;
    }
    this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
    return this.context;
  };
  return OffscreenCanvasCreator;
}();

/**
 * why we need re-render
 */
(function (RenderReason) {
  RenderReason[RenderReason["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
  RenderReason[RenderReason["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
  RenderReason[RenderReason["NONE"] = 2] = "NONE";
})(exports.RenderReason || (exports.RenderReason = {}));

/**
 * Use frame renderer implemented by `g-canvas/svg/webgl`, in every frame we do followings:
 * * update & merge dirty rectangles
 * * begin frame
 * * filter by visible
 * * sort by z-index in scene graph
 * * culling with strategies registered in `g-canvas/webgl`
 * * end frame
 */
var RenderingService = /*#__PURE__*/function () {
  function RenderingService(globalRuntime, context) {
    this.globalRuntime = void 0;
    this.context = void 0;
    this.inited = false;
    this.stats = {
      /**
       * total display objects in scenegraph
       */
      total: 0,
      /**
       * number of display objects need to render in current frame
       */
      rendered: 0
    };
    this.zIndexCounter = 0;
    this.renderOrderChangedEvent = new CustomEvent(exports.ElementEvent.RENDER_ORDER_CHANGED);
    this.hooks = {
      /**
       * called before any frame rendered
       */
      init: new AsyncParallelHook(),
      /**
       * only dirty object which has sth changed will be rendered
       */
      dirtycheck: new SyncWaterfallHook(['object']),
      /**
       * do culling
       */
      cull: new SyncWaterfallHook(['object', 'camera']),
      /**
       * called at beginning of each frame, won't get called if nothing to re-render
       */
      beginFrame: new SyncHook([]),
      /**
       * called before every dirty object get rendered
       */
      beforeRender: new SyncHook(['objectToRender']),
      /**
       * called when every dirty object rendering even it's culled
       */
      render: new SyncHook(['objectToRender']),
      /**
       * called after every dirty object get rendered
       */
      afterRender: new SyncHook(['objectToRender']),
      endFrame: new SyncHook([]),
      destroy: new SyncHook([]),
      /**
       * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
       */
      pick: new AsyncSeriesWaterfallHook(['result']),
      /**
       * Unsafe but sync version of pick.
       */
      pickSync: new SyncWaterfallHook(['result']),
      /**
       * used in event system
       */
      pointerDown: new SyncHook(['event']),
      pointerUp: new SyncHook(['event']),
      pointerMove: new SyncHook(['event']),
      pointerOut: new SyncHook(['event']),
      pointerOver: new SyncHook(['event']),
      pointerWheel: new SyncHook(['event']),
      pointerCancel: new SyncHook(['event'])
    };
    this.globalRuntime = globalRuntime;
    this.context = context;
  }
  var _proto = RenderingService.prototype;
  _proto.init = /*#__PURE__*/function () {
    var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var context;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _extends({}, this.globalRuntime, this.context); // register rendering plugins
              this.context.renderingPlugins.forEach(function (plugin) {
                plugin.apply(context, runtime);
              });
              // await this.hooks.init.callPromise();
              _context.next = 4;
              return this.hooks.init.promise();
            case 4:
              this.inited = true;
            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function init() {
      return _init.apply(this, arguments);
    }
    return init;
  }();
  _proto.getStats = function getStats() {
    return this.stats;
  }
  /**
   * Meet the following conditions:
   * * disable DirtyRectangleRendering
   * * camera changed
   */;
  _proto.disableDirtyRectangleRendering = function disableDirtyRectangleRendering() {
    var renderer = this.context.config.renderer;
    var _renderer$getConfig = renderer.getConfig(),
      enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
    return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(exports.RenderReason.CAMERA_CHANGED);
  };
  _proto.render = function render(canvasConfig, rerenderCallback) {
    var _this = this;
    this.stats.total = 0;
    this.stats.rendered = 0;
    this.zIndexCounter = 0;
    var renderingContext = this.context.renderingContext;
    this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
    this.globalRuntime.sceneGraphService.triggerPendingEvents();
    if (renderingContext.renderReasons.size && this.inited) {
      this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
      this.hooks.beginFrame.call();
      renderingContext.renderListCurrentFrame.forEach(function (object) {
        _this.hooks.beforeRender.call(object);
        _this.hooks.render.call(object);
        _this.hooks.afterRender.call(object);
      });
      this.hooks.endFrame.call();
      renderingContext.renderListCurrentFrame = [];
      renderingContext.renderReasons.clear();
      rerenderCallback();
    }
    // console.log('stats', this.stats);
  };
  _proto.renderDisplayObject = function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
    var _this2 = this;
    var _canvasConfig$rendere = canvasConfig.renderer.getConfig(),
      enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck,
      enableCulling = _canvasConfig$rendere.enableCulling;
    // recalc style values
    if (this.globalRuntime.enableCSSParsing) {
      this.globalRuntime.styleValueRegistry.recalc(displayObject);
    }
    // TODO: relayout
    // dirtycheck first
    var objectChanged = enableDirtyCheck ? this.hooks.dirtycheck.call(displayObject) : displayObject;
    if (objectChanged) {
      var objectToRender = enableCulling ? this.hooks.cull.call(objectChanged, this.context.camera) : objectChanged;
      if (objectToRender) {
        this.stats.rendered++;
        renderingContext.renderListCurrentFrame.push(objectToRender);
      }
    }
    displayObject.renderable.dirty = false;
    displayObject.sortable.renderOrder = this.zIndexCounter++;
    this.stats.total++;
    // sort is very expensive, use cached result if posible
    var sortable = displayObject.sortable;
    var renderOrderChanged = false;
    if (sortable.dirty) {
      sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
      renderOrderChanged = true;
      sortable.dirty = false;
    }
    // recursive rendering its children
    (sortable.sorted || displayObject.childNodes).forEach(function (child) {
      _this2.renderDisplayObject(child, canvasConfig, renderingContext);
    });
    if (renderOrderChanged) {
      displayObject.forEach(function (child) {
        _this2.renderOrderChangedEvent.target = child;
        _this2.renderOrderChangedEvent.detail = {
          renderOrder: child.sortable.renderOrder
        };
        child.ownerDocument.defaultView.dispatchEvent(_this2.renderOrderChangedEvent, true);
      });
    }
  };
  _proto.destroy = function destroy() {
    this.inited = false;
    this.hooks.destroy.call();
    this.globalRuntime.sceneGraphService.clearPendingEvents();
  };
  _proto.dirtify = function dirtify() {
    // need re-render
    this.context.renderingContext.renderReasons.add(exports.RenderReason.DISPLAY_OBJECT_CHANGED);
  };
  return RenderingService;
}();

var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
/**
 * support the following DOM API:
 * * getElementById
 * * getElementsByClassName
 * * getElementsByName
 * * getElementsByTag
 * * querySelector
 * * querySelectorAll
 */
var DefaultSceneGraphSelector = /*#__PURE__*/function () {
  function DefaultSceneGraphSelector() {}
  var _proto = DefaultSceneGraphSelector.prototype;
  _proto.selectOne = function selectOne(query, root) {
    var _this = this;
    if (query.startsWith('.')) {
      return root.find(function (node) {
        // return !node.shadow && node.id === query.substring(1);
        return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this.getIdOrClassname(query)) > -1;
      });
    } else if (query.startsWith('#')) {
      // getElementById('id')
      return root.find(function (node) {
        // return !node.shadow && node.id === query.substring(1);
        return node.id === _this.getIdOrClassname(query);
      });
    } else if (query.startsWith('[')) {
      var _this$getAttribute = this.getAttribute(query),
        name = _this$getAttribute.name,
        value = _this$getAttribute.value;
      if (name) {
        // getElementByName();
        return root.find(function (node) {
          return root !== node && (name === 'name' ? node.name === value : _this.attributeToString(node, name) === value);
        });
      } else {
        return null;
      }
    } else {
      // getElementsByTag('circle');
      return root.find(function (node) {
        return root !== node && node.nodeName === query;
      });
    }
  };
  _proto.selectAll = function selectAll(query, root) {
    var _this2 = this;
    // only support `[name="${name}"]` `.className` `#id`
    if (query.startsWith('.')) {
      // getElementsByClassName('className');
      // should not include itself
      return root.findAll(function (node) {
        return root !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
      });
    } else if (query.startsWith('#')) {
      return root.findAll(function (node) {
        return root !== node && node.id === _this2.getIdOrClassname(query);
      });
    } else if (query.startsWith('[')) {
      var _this$getAttribute2 = this.getAttribute(query),
        name = _this$getAttribute2.name,
        value = _this$getAttribute2.value;
      if (name) {
        // getElementsByName();
        return root.findAll(function (node) {
          return root !== node && (name === 'name' ? node.name === value : _this2.attributeToString(node, name) === value);
        });
      } else {
        return [];
      }
    } else {
      // getElementsByTag('circle');
      return root.findAll(function (node) {
        return root !== node && node.nodeName === query;
      });
    }
  };
  _proto.is = function is(query, node) {
    // a simple `matches` implementation
    if (query.startsWith('.')) {
      return node.className === this.getIdOrClassname(query);
    } else if (query.startsWith('#')) {
      return node.id === this.getIdOrClassname(query);
    } else if (query.startsWith('[')) {
      var _this$getAttribute3 = this.getAttribute(query),
        name = _this$getAttribute3.name,
        value = _this$getAttribute3.value;
      return name === 'name' ? node.name === value : this.attributeToString(node, name) === value;
    } else {
      return node.nodeName === query;
    }
  };
  _proto.getIdOrClassname = function getIdOrClassname(query) {
    return query.substring(1);
  };
  _proto.getAttribute = function getAttribute(query) {
    var matches = query.match(ATTRIBUTE_REGEXP);
    var name = '';
    var value = '';
    if (matches && matches.length > 2) {
      name = matches[1].replace(/"/g, '');
      value = matches[2].replace(/"/g, '');
    }
    return {
      name: name,
      value: value
    };
  };
  _proto.attributeToString = function attributeToString(node, name) {
    if (!node.getAttribute) {
      return '';
    }
    var value = node.getAttribute(name);
    if (util.isNil(value)) {
      return '';
    }
    if (value.toString) {
      return value.toString();
    }
    return '';
  };
  return DefaultSceneGraphSelector;
}();

function markRenderableDirty(e) {
  var renderable = e.renderable;
  if (renderable) {
    renderable.renderBoundsDirty = true;
    renderable.boundsDirty = true;
  }
}
var reparentEvent = new MutationEvent(exports.ElementEvent.REPARENT, null, '', '', '', 0, '', '');
/**
 * update transform in scene graph
 *
 * @see https://community.khronos.org/t/scene-graphs/50542/7
 */
var DefaultSceneGraphService = /*#__PURE__*/function () {
  function DefaultSceneGraphService(runtime) {
    var _this = this;
    this.runtime = void 0;
    this.pendingEvents = [];
    this.boundsChangedEvent = new CustomEvent(exports.ElementEvent.BOUNDS_CHANGED);
    this.rotate = function () {
      var parentInvertRotation = glMatrix.quat.create();
      return function (element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === 'number') {
          degrees = glMatrix.vec3.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this.rotateLocal(element, degrees);
        } else {
          var rotation = glMatrix.quat.create();
          glMatrix.quat.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
          var rot = _this.getRotation(element);
          var parentRot = _this.getRotation(element.parentNode);
          glMatrix.quat.copy(parentInvertRotation, parentRot);
          glMatrix.quat.invert(parentInvertRotation, parentInvertRotation);
          glMatrix.quat.multiply(rotation, parentInvertRotation, rotation);
          glMatrix.quat.multiply(transform.localRotation, rotation, rot);
          glMatrix.quat.normalize(transform.localRotation, transform.localRotation);
          _this.dirtifyLocal(element, transform);
        }
      };
    }();
    this.rotateLocal = function () {
      var rotation = glMatrix.quat.create();
      return function (element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === 'number') {
          degrees = glMatrix.vec3.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        glMatrix.quat.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
        glMatrix.quat.mul(transform.localRotation, transform.localRotation, rotation);
        _this.dirtifyLocal(element, transform);
      };
    }();
    this.setEulerAngles = function () {
      var invParentRot = glMatrix.quat.create();
      return function (element, degrees, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof degrees === 'number') {
          degrees = glMatrix.vec3.fromValues(degrees, y, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this.setLocalEulerAngles(element, degrees);
        } else {
          glMatrix.quat.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
          var parentRotation = _this.getRotation(element.parentNode);
          glMatrix.quat.copy(invParentRot, glMatrix.quat.invert(glMatrix.quat.create(), parentRotation));
          glMatrix.quat.mul(transform.localRotation, transform.localRotation, invParentRot);
          _this.dirtifyLocal(element, transform);
        }
      };
    }();
    this.translateLocal = function () {
      return function (element, translation, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof translation === 'number') {
          translation = glMatrix.vec3.fromValues(translation, y, z);
        }
        var transform = element.transformable;
        if (glMatrix.vec3.equals(translation, glMatrix.vec3.create())) {
          return;
        }
        glMatrix.vec3.transformQuat(translation, translation, transform.localRotation);
        glMatrix.vec3.add(transform.localPosition, transform.localPosition, translation);
        _this.dirtifyLocal(element, transform);
      };
    }();
    this.setPosition = function () {
      var parentInvertMatrix = glMatrix.mat4.create();
      var tmpPosition = glMatrix.vec3.create();
      return function (element, position) {
        var transform = element.transformable;
        tmpPosition[0] = position[0];
        tmpPosition[1] = position[1];
        tmpPosition[2] = position[2] || 0;
        if (glMatrix.vec3.equals(_this.getPosition(element), tmpPosition)) {
          return;
        }
        glMatrix.vec3.copy(transform.position, tmpPosition);
        if (element.parentNode === null || !element.parentNode.transformable) {
          glMatrix.vec3.copy(transform.localPosition, tmpPosition);
        } else {
          var parentTransform = element.parentNode.transformable;
          glMatrix.mat4.copy(parentInvertMatrix, parentTransform.worldTransform);
          glMatrix.mat4.invert(parentInvertMatrix, parentInvertMatrix);
          glMatrix.vec3.transformMat4(transform.localPosition, tmpPosition, parentInvertMatrix);
        }
        _this.dirtifyLocal(element, transform);
      };
    }();
    this.setLocalPosition = function () {
      var tmpPosition = glMatrix.vec3.create();
      return function (element, position) {
        var transform = element.transformable;
        tmpPosition[0] = position[0];
        tmpPosition[1] = position[1];
        tmpPosition[2] = position[2] || 0;
        if (glMatrix.vec3.equals(transform.localPosition, tmpPosition)) {
          return;
        }
        glMatrix.vec3.copy(transform.localPosition, tmpPosition);
        _this.dirtifyLocal(element, transform);
      };
    }();
    this.translate = function () {
      var zeroVec3 = glMatrix.vec3.create();
      var tmpVec3 = glMatrix.vec3.create();
      var tr = glMatrix.vec3.create();
      return function (element, translation, y, z) {
        if (y === void 0) {
          y = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof translation === 'number') {
          translation = glMatrix.vec3.set(tmpVec3, translation, y, z);
        }
        if (glMatrix.vec3.equals(translation, zeroVec3)) {
          return;
        }
        glMatrix.vec3.add(tr, _this.getPosition(element), translation);
        _this.setPosition(element, tr);
      };
    }();
    this.setRotation = function () {
      var parentInvertRotation = glMatrix.quat.create();
      return function (element, rotation, y, z, w) {
        var transform = element.transformable;
        if (typeof rotation === 'number') {
          rotation = glMatrix.quat.fromValues(rotation, y, z, w);
        }
        if (element.parentNode === null || !element.parentNode.transformable) {
          _this.setLocalRotation(element, rotation);
        } else {
          var parentRot = _this.getRotation(element.parentNode);
          glMatrix.quat.copy(parentInvertRotation, parentRot);
          glMatrix.quat.invert(parentInvertRotation, parentInvertRotation);
          glMatrix.quat.multiply(transform.localRotation, parentInvertRotation, rotation);
          glMatrix.quat.normalize(transform.localRotation, transform.localRotation);
          _this.dirtifyLocal(element, transform);
        }
      };
    };
    this.displayObjectDependencyMap = new WeakMap();
    this.calcLocalTransform = function () {
      var tmpMat = glMatrix.mat4.create();
      var tmpPosition = glMatrix.vec3.create();
      var tmpQuat = glMatrix.quat.fromValues(0, 0, 0, 1);
      return function (transform) {
        var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
        if (hasSkew) {
          glMatrix.mat4.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, glMatrix.vec3.fromValues(1, 1, 1), transform.origin);
          // apply skew2D
          if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
            var tmpMat4 = glMatrix.mat4.identity(tmpMat);
            tmpMat4[4] = Math.tan(transform.localSkew[0]);
            tmpMat4[1] = Math.tan(transform.localSkew[1]);
            glMatrix.mat4.multiply(transform.localTransform, transform.localTransform, tmpMat4);
          }
          var scaling = glMatrix.mat4.fromRotationTranslationScaleOrigin(tmpMat, tmpQuat, tmpPosition, transform.localScale, transform.origin);
          glMatrix.mat4.multiply(transform.localTransform, transform.localTransform, scaling);
        } else {
          // @see https://github.com/mattdesl/css-mat4/blob/master/index.js
          glMatrix.mat4.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, transform.localScale, transform.origin);
        }
      };
    }();
    this.runtime = runtime;
  }
  var _proto = DefaultSceneGraphService.prototype;
  _proto.matches = function matches(query, root) {
    return this.runtime.sceneGraphSelector.is(query, root);
  };
  _proto.querySelector = function querySelector(query, root) {
    return this.runtime.sceneGraphSelector.selectOne(query, root);
  };
  _proto.querySelectorAll = function querySelectorAll(query, root) {
    return this.runtime.sceneGraphSelector.selectAll(query, root);
    // .filter((node) => !node.shadow);
  };
  _proto.attach = function attach(child, parent, index) {
    var _sortable$sorted, _child$style;
    var detached = false;
    if (child.parentNode) {
      detached = child.parentNode !== parent;
      this.detach(child);
    }
    child.parentNode = parent;
    if (!util.isNil(index)) {
      child.parentNode.childNodes.splice(index, 0, child);
    } else {
      child.parentNode.childNodes.push(child);
    }
    // parent needs re-sort
    var sortable = parent.sortable;
    if ((sortable === null || sortable === void 0 ? void 0 : (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) || ((_child$style = child.style) === null || _child$style === void 0 ? void 0 : _child$style.zIndex)) {
      // if (sortable) {
      // only child has z-Index
      sortable.dirty = true;
    }
    // this.updateGraphDepth(child);
    var transform = child.transformable;
    if (transform) {
      this.dirtifyWorld(child, transform);
    }
    if (transform.frozen) {
      this.unfreezeParentToRoot(child);
    }
    if (detached) {
      child.dispatchEvent(reparentEvent);
    }
  };
  _proto.detach = function detach(child) {
    if (child.parentNode) {
      var _sortable$sorted2, _child$style2;
      var transform = child.transformable;
      // if (transform) {
      //   const worldTransform = this.getWorldTransform(child, transform);
      //   mat4.getScaling(transform.localScale, worldTransform);
      //   mat4.getTranslation(transform.localPosition, worldTransform);
      //   mat4.getRotation(transform.localRotation, worldTransform);
      //   transform.localDirtyFlag = true;
      // }
      // parent needs re-sort
      var sortable = child.parentNode.sortable;
      // if (sortable) {
      if ((sortable === null || sortable === void 0 ? void 0 : (_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) || ((_child$style2 = child.style) === null || _child$style2 === void 0 ? void 0 : _child$style2.zIndex)) {
        sortable.dirty = true;
      }
      var index = child.parentNode.childNodes.indexOf(child);
      if (index > -1) {
        child.parentNode.childNodes.splice(index, 1);
      }
      if (transform) {
        this.dirtifyWorld(child, transform);
      }
      child.parentNode = null;
    }
  };
  _proto.getOrigin = function getOrigin(element) {
    return element.transformable.origin;
  }
  /**
   * same as pivot in Pixi.js
   *
   * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
   */;
  _proto.setOrigin = function setOrigin(element, origin, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (typeof origin === 'number') {
      origin = glMatrix.vec3.fromValues(origin, y, z);
    }
    var transform = element.transformable;
    if (glMatrix.vec3.equals(origin, transform.origin)) {
      return;
    }
    var originVec = transform.origin;
    // const delta = vec3.subtract(vec3.create(), origin, originVec);
    // vec3.add(transform.localPosition, transform.localPosition, delta);
    // update origin
    originVec[0] = origin[0];
    originVec[1] = origin[1];
    originVec[2] = origin[2] || 0;
    this.dirtifyLocal(element, transform);
  }
  /**
   * rotate in world space
   */;
  /**
   * set euler angles(degrees) in local space
   */
  _proto.setLocalEulerAngles = function setLocalEulerAngles(element, degrees, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (typeof degrees === 'number') {
      degrees = glMatrix.vec3.fromValues(degrees, y, z);
    }
    var transform = element.transformable;
    glMatrix.quat.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
    this.dirtifyLocal(element, transform);
  }
  /**
   * translate in local space
   *
   * @example
   * ```
   * translateLocal(x, y, z)
   * translateLocal(vec3(x, y, z))
   * ```
   */;
  /**
   * scale in local space
   */
  _proto.scaleLocal = function scaleLocal(element, scaling) {
    var transform = element.transformable;
    glMatrix.vec3.multiply(transform.localScale, transform.localScale, glMatrix.vec3.fromValues(scaling[0], scaling[1], scaling[2] || 1));
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalScale = function setLocalScale(element, scaling) {
    var transform = element.transformable;
    var updatedScaling = glMatrix.vec3.fromValues(scaling[0], scaling[1], scaling[2] || transform.localScale[2]);
    if (glMatrix.vec3.equals(updatedScaling, transform.localScale)) {
      return;
    }
    glMatrix.vec3.copy(transform.localScale, updatedScaling);
    this.dirtifyLocal(element, transform);
  }
  /**
   * translate in world space
   *
   * @example
   * ```
   * translate(x, y, z)
   * translate(vec3(x, y, z))
   * ```
   *
   * 对应 g 原版的 translate 2D
   * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
   */;
  _proto.setLocalRotation = function setLocalRotation(element, rotation, y, z, w) {
    if (typeof rotation === 'number') {
      rotation = glMatrix.quat.fromValues(rotation, y, z, w);
    }
    var transform = element.transformable;
    glMatrix.quat.copy(transform.localRotation, rotation);
    this.dirtifyLocal(element, transform);
  };
  _proto.setLocalSkew = function setLocalSkew(element, skew, y) {
    if (typeof skew === 'number') {
      skew = glMatrix.vec2.fromValues(skew, y);
    }
    var transform = element.transformable;
    glMatrix.vec2.copy(transform.localSkew, skew);
    this.dirtifyLocal(element, transform);
  };
  _proto.dirtifyLocal = function dirtifyLocal(element, transform) {
    if (!transform.localDirtyFlag) {
      transform.localDirtyFlag = true;
      if (!transform.dirtyFlag) {
        this.dirtifyWorld(element, transform);
      }
    }
  };
  _proto.dirtifyWorld = function dirtifyWorld(element, transform) {
    if (!transform.dirtyFlag) {
      this.unfreezeParentToRoot(element);
    }
    this.dirtifyWorldInternal(element, transform);
    this.dirtifyToRoot(element, true);
  };
  _proto.triggerPendingEvents = function triggerPendingEvents() {
    var _this2 = this;
    var set = new Set();
    var trigger = function trigger(element, detail) {
      if (element.isConnected && !set.has(element.entity)) {
        _this2.boundsChangedEvent.detail = detail;
        _this2.boundsChangedEvent.target = element;
        if (element.isMutationObserved) {
          element.dispatchEvent(_this2.boundsChangedEvent);
        } else {
          element.ownerDocument.defaultView.dispatchEvent(_this2.boundsChangedEvent, true);
        }
        set.add(element.entity);
      }
    };
    this.pendingEvents.forEach(function (_ref) {
      var element = _ref[0],
        detail = _ref[1];
      if (detail.affectChildren) {
        element.forEach(function (e) {
          trigger(e, detail);
        });
      } else {
        trigger(element, detail);
      }
    });
    this.clearPendingEvents();
    set.clear();
  };
  _proto.clearPendingEvents = function clearPendingEvents() {
    this.pendingEvents = [];
  };
  _proto.dirtifyToRoot = function dirtifyToRoot(element, affectChildren) {
    if (affectChildren === void 0) {
      affectChildren = false;
    }
    var p = element;
    // only need to re-render itself
    if (p.renderable) {
      p.renderable.dirty = true;
    }
    while (p) {
      markRenderableDirty(p);
      p = p.parentNode;
    }
    if (affectChildren) {
      element.forEach(function (e) {
        markRenderableDirty(e);
      });
    }
    // inform dependencies
    this.informDependentDisplayObjects(element);
    // reuse the same custom event
    this.pendingEvents.push([element, {
      affectChildren: affectChildren
    }]);
  };
  _proto.updateDisplayObjectDependency = function updateDisplayObjectDependency(name, oldPath, newPath, object) {
    // clear ref to old clip path
    if (oldPath && oldPath !== newPath) {
      var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
      if (oldDependencyMap && oldDependencyMap[name]) {
        var index = oldDependencyMap[name].indexOf(object);
        oldDependencyMap[name].splice(index, 1);
      }
    }
    if (newPath) {
      var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
      if (!newDependencyMap) {
        this.displayObjectDependencyMap.set(newPath, {});
        newDependencyMap = this.displayObjectDependencyMap.get(newPath);
      }
      if (!newDependencyMap[name]) {
        newDependencyMap[name] = [];
      }
      newDependencyMap[name].push(object);
    }
  };
  _proto.informDependentDisplayObjects = function informDependentDisplayObjects(object) {
    var _this3 = this;
    var dependencyMap = this.displayObjectDependencyMap.get(object);
    if (dependencyMap) {
      Object.keys(dependencyMap).forEach(function (name) {
        dependencyMap[name].forEach(function (target) {
          _this3.dirtifyToRoot(target, true);
          target.dispatchEvent(new MutationEvent(exports.ElementEvent.ATTR_MODIFIED, target, _this3, _this3, name, MutationEvent.MODIFICATION, _this3, _this3));
          if (target.isCustomElement && target.isConnected) {
            if (target.attributeChangedCallback) {
              target.attributeChangedCallback(name, _this3, _this3);
            }
          }
        });
      });
    }
  };
  _proto.getPosition = function getPosition(element) {
    var transform = element.transformable;
    return glMatrix.mat4.getTranslation(transform.position, this.getWorldTransform(element, transform));
  };
  _proto.getRotation = function getRotation(element) {
    var transform = element.transformable;
    return glMatrix.mat4.getRotation(transform.rotation, this.getWorldTransform(element, transform));
  };
  _proto.getScale = function getScale(element) {
    var transform = element.transformable;
    return glMatrix.mat4.getScaling(transform.scaling, this.getWorldTransform(element, transform));
  };
  _proto.getWorldTransform = function getWorldTransform(element, transform) {
    if (transform === void 0) {
      transform = element.transformable;
    }
    if (!transform.localDirtyFlag && !transform.dirtyFlag) {
      return transform.worldTransform;
    }
    if (element.parentNode && element.parentNode.transformable) {
      this.getWorldTransform(element.parentNode);
    }
    this.sync(element, transform);
    return transform.worldTransform;
  };
  _proto.getLocalPosition = function getLocalPosition(element) {
    return element.transformable.localPosition;
  };
  _proto.getLocalRotation = function getLocalRotation(element) {
    return element.transformable.localRotation;
  };
  _proto.getLocalScale = function getLocalScale(element) {
    return element.transformable.localScale;
  };
  _proto.getLocalSkew = function getLocalSkew(element) {
    return element.transformable.localSkew;
  };
  _proto.getLocalTransform = function getLocalTransform(element) {
    var transform = element.transformable;
    if (transform.localDirtyFlag) {
      this.calcLocalTransform(transform);
      transform.localDirtyFlag = false;
    }
    return transform.localTransform;
  };
  _proto.setLocalTransform = function setLocalTransform(element, transform) {
    var t = glMatrix.mat4.getTranslation(glMatrix.vec3.create(), transform);
    var r = glMatrix.mat4.getRotation(glMatrix.quat.create(), transform);
    var s = glMatrix.mat4.getScaling(glMatrix.vec3.create(), transform);
    this.setLocalScale(element, s);
    this.setLocalPosition(element, t);
    this.setLocalRotation(element, r);
  };
  _proto.resetLocalTransform = function resetLocalTransform(element) {
    this.setLocalScale(element, [1, 1, 1]);
    this.setLocalPosition(element, [0, 0, 0]);
    this.setLocalEulerAngles(element, [0, 0, 0]);
    this.setLocalSkew(element, [0, 0]);
  };
  _proto.getTransformedGeometryBounds = function getTransformedGeometryBounds(element, render, existedAABB) {
    if (render === void 0) {
      render = false;
    }
    var bounds = this.getGeometryBounds(element, render);
    if (!AABB.isEmpty(bounds)) {
      var aabb = existedAABB || new AABB();
      aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      return aabb;
    } else {
      return null;
    }
  }
  /**
   * won't account for children
   */;
  _proto.getGeometryBounds = function getGeometryBounds(element, render) {
    if (render === void 0) {
      render = false;
    }
    var geometry = element.geometry;
    if (geometry.dirty) {
      runtime.styleValueRegistry.updateGeometry(element);
    }
    var bounds = render ? geometry.renderBounds : geometry.contentBounds || null;
    // return (bounds && new AABB(bounds.center, bounds.halfExtents)) || new AABB();
    return bounds || new AABB();
  }
  /**
   * account for children in world space
   */;
  _proto.getBounds = function getBounds(element, render) {
    var _this4 = this;
    if (render === void 0) {
      render = false;
    }
    var renderable = element.renderable;
    if (!renderable.boundsDirty && !render && renderable.bounds) {
      return renderable.bounds;
    }
    if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {
      return renderable.renderBounds;
    }
    // reuse existed if possible
    var existedAABB = render ? renderable.renderBounds : renderable.bounds;
    // reset with geometry's aabb
    var aabb = this.getTransformedGeometryBounds(element, render, existedAABB);
    // merge children's aabbs
    var children = element.childNodes;
    children.forEach(function (child) {
      var childBounds = _this4.getBounds(child, render);
      if (childBounds) {
        if (!aabb) {
          aabb = existedAABB || new AABB();
          aabb.update(childBounds.center, childBounds.halfExtents);
        } else {
          aabb.add(childBounds);
        }
      }
    });
    if (render) {
      // FIXME: account for clip path
      var clipped = findClosestClipPathTarget(element);
      if (clipped) {
        // use bounds under world space
        var clipPathBounds = clipped.style.clipPath.getBounds(render);
        if (!aabb) {
          aabb = clipPathBounds;
        } else if (clipPathBounds) {
          aabb = clipPathBounds.intersection(aabb);
        }
      }
    }
    if (!aabb) {
      aabb = new AABB();
    }
    if (aabb) {
      if (render) {
        renderable.renderBounds = aabb;
      } else {
        renderable.bounds = aabb;
      }
    }
    if (render) {
      renderable.renderBoundsDirty = false;
    } else {
      renderable.boundsDirty = false;
    }
    return aabb;
  }
  /**
   * account for children in local space
   */;
  _proto.getLocalBounds = function getLocalBounds(element) {
    if (element.parentNode) {
      var parentInvert = glMatrix.mat4.create();
      if (element.parentNode.transformable) {
        parentInvert = glMatrix.mat4.invert(glMatrix.mat4.create(), this.getWorldTransform(element.parentNode));
      }
      var bounds = this.getBounds(element);
      if (!AABB.isEmpty(bounds)) {
        var localBounds = new AABB();
        localBounds.setFromTransformedAABB(bounds, parentInvert);
        return localBounds;
      }
    }
    return this.getBounds(element);
  };
  _proto.getBoundingClientRect = function getBoundingClientRect(element) {
    var _element$ownerDocumen, _element$ownerDocumen2;
    var aabb;
    var bounds = this.getGeometryBounds(element);
    if (!AABB.isEmpty(bounds)) {
      aabb = new AABB();
      // apply transformation to aabb
      aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
    }
    // calc context's offset
    var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 ? void 0 : (_element$ownerDocumen2 = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.getContextService().getBoundingClientRect();
    if (aabb) {
      var _aabb$getMin = aabb.getMin(),
        left = _aabb$getMin[0],
        top = _aabb$getMin[1];
      var _aabb$getMax = aabb.getMax(),
        right = _aabb$getMax[0],
        bottom = _aabb$getMax[1];
      return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);
    }
    return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
  };
  _proto.dirtifyWorldInternal = function dirtifyWorldInternal(element, transform) {
    var _this5 = this;
    if (!transform.dirtyFlag) {
      transform.dirtyFlag = true;
      transform.frozen = false;
      element.childNodes.forEach(function (child) {
        var childTransform = child.transformable;
        if (!childTransform.dirtyFlag) {
          _this5.dirtifyWorldInternal(child, childTransform);
        }
      });
      var renderable = element.renderable;
      if (renderable) {
        renderable.renderBoundsDirty = true;
        renderable.boundsDirty = true;
        renderable.dirty = true;
      }
    }
  };
  _proto.syncHierarchy = function syncHierarchy(element) {
    var transform = element.transformable;
    if (transform.frozen) {
      return;
    }
    transform.frozen = true;
    if (transform.localDirtyFlag || transform.dirtyFlag) {
      this.sync(element, transform);
    }
    var children = element.childNodes;
    for (var i = 0; i < children.length; i++) {
      this.syncHierarchy(children[i]);
    }
  };
  _proto.sync = function sync(element, transform) {
    if (transform.localDirtyFlag) {
      this.calcLocalTransform(transform);
      transform.localDirtyFlag = false;
    }
    if (transform.dirtyFlag) {
      var parent = element.parentNode;
      var parentTransform = parent && parent.transformable;
      if (parent === null || !parentTransform) {
        glMatrix.mat4.copy(transform.worldTransform, transform.localTransform);
      } else {
        // TODO: should we support scale compensation?
        // @see https://github.com/playcanvas/engine/issues/1077#issuecomment-359765557
        glMatrix.mat4.multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
      }
      transform.dirtyFlag = false;
    }
  };
  _proto.unfreezeParentToRoot = function unfreezeParentToRoot(child) {
    var p = child.parentNode;
    while (p) {
      var transform = p.transformable;
      if (transform) {
        transform.frozen = false;
      }
      p = p.parentNode;
    }
  };
  return DefaultSceneGraphService;
}();

var TEXT_METRICS = {
  MetricsString: '|ÉqÅ',
  BaselineSymbol: 'M',
  BaselineMultiplier: 1.4,
  HeightMultiplier: 2,
  Newlines: [0x000a, 0x000d // carriage return
  ],

  BreakingSpaces: [0x0009, 0x0020, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2008, 0x2009, 0x200a, 0x205f, 0x3000 // ideographic space
  ]
};

var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
// Line breaking rules in CJK (Kinsoku Shori)
// Refer from https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages
var regexCannotStartZhCn = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
var regexCannotEndZhCn = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
var regexCannotStartZhTw = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
var regexCannotEndZhTw = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
var regexCannotStartJaJp = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
var regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
var regexCannotStartKoKr = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
var regexCannotEndKoKr = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
var regexCannotStart = new RegExp(regexCannotStartZhCn.source + "|" + regexCannotStartZhTw.source + "|" + regexCannotStartJaJp.source + "|" + regexCannotStartKoKr.source);
var regexCannotEnd = new RegExp(regexCannotEndZhCn.source + "|" + regexCannotEndZhTw.source + "|" + regexCannotEndJaJp.source + "|" + regexCannotEndKoKr.source);
/**
 * Borrow from pixi/packages/text/src/TextMetrics.ts
 */
var TextService = /*#__PURE__*/function () {
  function TextService(runtime) {
    var _this = this;
    this.runtime = void 0;
    this.fontMetricsCache = {};
    this.shouldBreakByKinsokuShorui = function (char, nextChar) {
      if (_this.isBreakingSpace(nextChar)) return false;
      if (char) {
        // Line breaking rules in CJK (Kinsoku Shori)
        if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(char)) {
          return true;
        }
      }
      return false;
    };
    this.trimByKinsokuShorui = function (prev) {
      var next = [].concat(prev);
      var prevLine = next[next.length - 2];
      if (!prevLine) {
        return prev;
      }
      var lastChar = prevLine[prevLine.length - 1];
      next[next.length - 2] = prevLine.slice(0, -1);
      next[next.length - 1] = lastChar + next[next.length - 1];
      return next;
    };
    this.runtime = runtime;
  }
  /**
   * font metrics cache
   */
  var _proto = TextService.prototype;
  /**
   * Calculates the ascent, descent and fontSize of a given font-style.
   */
  _proto.measureFont = function measureFont(font, offscreenCanvas) {
    // as this method is used for preparing assets, don't recalculate things if we don't need to
    if (this.fontMetricsCache[font]) {
      return this.fontMetricsCache[font];
    }
    var properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    var canvas = this.runtime.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    context.font = font;
    var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
    var width = Math.ceil(context.measureText(metricsString).width);
    var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
    var height = TEXT_METRICS.HeightMultiplier * baseline;
    baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
    // @ts-ignore
    canvas.width = width;
    // @ts-ignore
    canvas.height = height;
    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);
    context.font = font;
    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(metricsString, 0, baseline);
    var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i = 0;
    var idx = 0;
    var stop = false;
    // ascent. scan from top to bottom until we find a non red pixel
    for (i = 0; i < baseline; ++i) {
      for (var j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i;
    idx = pixels - line;
    stop = false;
    // descent. scan from bottom to top until we find a non red pixel
    for (i = height; i > baseline; --i) {
      for (var _j = 0; _j < line; _j += 4) {
        if (imagedata[idx + _j] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    this.fontMetricsCache[font] = properties;
    return properties;
  };
  _proto.measureText = function measureText(text, parsedStyle, offscreenCanvas) {
    var fontSize = parsedStyle.fontSize,
      wordWrap = parsedStyle.wordWrap,
      strokeHeight = parsedStyle.lineHeight,
      lineWidth = parsedStyle.lineWidth,
      textBaseline = parsedStyle.textBaseline,
      textAlign = parsedStyle.textAlign,
      letterSpacing = parsedStyle.letterSpacing,
      textPath = parsedStyle.textPath,
      textPathSide = parsedStyle.textPathSide,
      textPathStartOffset = parsedStyle.textPathStartOffset,
      _parsedStyle$leading = parsedStyle.leading,
      leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
    var font = toFontString(parsedStyle);
    var fontProperties;
    if (runtime.enableCSSParsing) {
      fontProperties = this.measureFont(font, offscreenCanvas);
      // fallback in case UA disallow canvas data extraction
      // (toDataURI, getImageData functions)
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = fontSize;
        fontProperties.ascent = fontSize;
      }
    } else {
      fontProperties = {
        fontSize: fontSize
      };
    }
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    context.font = font;
    // no overflowing by default
    parsedStyle.isOverflowing = false;
    var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    // account for textPath
    if (textPath) {
      var totalPathLength = textPath.getTotalLength();
      // const startingPoint = textPath.getPoint(0);
      for (var i = 0; i < lines.length; i++) {
        var width = context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
        // for (
        //   let i = reverse ? lines[0].length - 1 : 0;
        //   reverse ? i >= 0 : i < lines[0].length;
        //   reverse ? i-- : i++
        // ) {
        //   graphemeInfo = lineBounds[i];
        //   if (positionInPath > totalPathLength) {
        //     positionInPath %= totalPathLength;
        //   } else if (positionInPath < 0) {
        //     positionInPath += totalPathLength;
        //   }
        //   // it would probably much faster to send all the grapheme position for a line
        //   // and calculate path position/angle at once.
        //   this.setGraphemeOnPath(
        //     positionInPath,
        //     graphemeInfo,
        //     startingPoint
        //   );
        //   positionInPath += graphemeInfo.kernedWidth;
        // }
      }
    } else {
      for (var _i = 0; _i < lines.length; _i++) {
        // char width + letterSpacing
        var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
        lineWidths[_i] = _lineWidth;
        maxLineWidth = Math.max(maxLineWidth, _lineWidth);
      }
      var _width = maxLineWidth + lineWidth;
      // if (dropShadow) {
      //   width += dropShadowDistance;
      // }
      var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
      var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);
      // if (dropShadow) {
      //   height += dropShadowDistance;
      // }
      lineHeight += leading;
      // handle vertical text baseline
      var offsetY = 0;
      if (textBaseline === 'middle') {
        offsetY = -height / 2;
      } else if (textBaseline === 'bottom' || textBaseline === 'alphabetic' || textBaseline === 'ideographic') {
        offsetY = -height;
      } else if (textBaseline === 'top' || textBaseline === 'hanging') {
        offsetY = 0;
      }
      return {
        font: font,
        width: _width,
        height: height,
        lines: lines,
        lineWidths: lineWidths,
        lineHeight: lineHeight,
        maxLineWidth: maxLineWidth,
        fontProperties: fontProperties,
        lineMetrics: lineWidths.map(function (width, i) {
          var offsetX = 0;
          // handle horizontal text align
          if (textAlign === 'center' || textAlign === 'middle') {
            offsetX -= width / 2;
          } else if (textAlign === 'right' || textAlign === 'end') {
            offsetX -= width;
          }
          return new Rectangle(offsetX - lineWidth / 2, offsetY + i * lineHeight, width + lineWidth, lineHeight);
        })
      };
    }
  };
  _proto.setGraphemeOnPath = function setGraphemeOnPath() {};
  _proto.wordWrap = function wordWrap(text, parsedStyle, offscreenCanvas) {
    var _this2 = this;
    var _parsedStyle$wordWrap = parsedStyle.wordWrapWidth,
      wordWrapWidth = _parsedStyle$wordWrap === void 0 ? 0 : _parsedStyle$wordWrap,
      letterSpacing = parsedStyle.letterSpacing,
      _parsedStyle$maxLines = parsedStyle.maxLines,
      maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines,
      textOverflow = parsedStyle.textOverflow;
    var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
    var maxWidth = wordWrapWidth + letterSpacing;
    var ellipsis = '';
    if (textOverflow === 'ellipsis') {
      ellipsis = '...';
    } else if (textOverflow && textOverflow !== 'clip') {
      ellipsis = textOverflow;
    }
    var lines = [];
    var currentIndex = 0;
    var currentWidth = 0;
    var cache = {};
    var calcWidth = function calcWidth(char) {
      return _this2.getFromCache(char, letterSpacing, cache, context);
    };
    var ellipsisWidth = Array.from(ellipsis).reduce(function (prev, cur) {
      return prev + calcWidth(cur);
    }, 0);
    var chars = Array.from(text);
    for (var i = 0; i < chars.length; i++) {
      var char = chars[i];
      var prevChar = text[i - 1];
      var nextChar = text[i + 1];
      var charWidth = calcWidth(char);
      if (this.isNewline(char)) {
        currentIndex++;
        // exceed maxLines, break immediately
        if (currentIndex >= maxLines) {
          parsedStyle.isOverflowing = true;
          break;
        }
        currentWidth = 0;
        lines[currentIndex] = '';
        continue;
      }
      if (currentWidth > 0 && currentWidth + charWidth > maxWidth) {
        if (currentIndex + 1 >= maxLines) {
          parsedStyle.isOverflowing = true;
          // If there is not enough space to display the string itself, it is clipped.
          // @see https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow#values
          if (ellipsisWidth > 0 && ellipsisWidth <= maxWidth) {
            // Backspace from line's end.
            var currentLineLength = lines[currentIndex].length;
            var lastLineWidth = 0;
            var lastLineIndex = currentLineLength;
            for (var _i2 = 0; _i2 < currentLineLength; _i2++) {
              var width = calcWidth(lines[currentIndex][_i2]);
              if (lastLineWidth + width + ellipsisWidth > maxWidth) {
                lastLineIndex = _i2;
                break;
              }
              lastLineWidth += width;
            }
            lines[currentIndex] = (lines[currentIndex] || '').slice(0, lastLineIndex) + ellipsis;
          }
          break;
        }
        currentIndex++;
        currentWidth = 0;
        lines[currentIndex] = '';
        if (this.isBreakingSpace(char)) {
          continue;
        }
        if (!this.canBreakInLastChar(char)) {
          lines = this.trimToBreakable(lines);
          currentWidth = this.sumTextWidthByCache(lines[currentIndex] || '', cache);
        }
        if (this.shouldBreakByKinsokuShorui(char, nextChar)) {
          lines = this.trimByKinsokuShorui(lines);
          currentWidth += calcWidth(prevChar || '');
        }
      }
      currentWidth += charWidth;
      lines[currentIndex] = (lines[currentIndex] || '') + char;
    }
    return lines.join('\n');
  };
  _proto.isBreakingSpace = function isBreakingSpace(char) {
    if (typeof char !== 'string') {
      return false;
    }
    return TEXT_METRICS.BreakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
  };
  _proto.isNewline = function isNewline(char) {
    if (typeof char !== 'string') {
      return false;
    }
    return TEXT_METRICS.Newlines.indexOf(char.charCodeAt(0)) >= 0;
  };
  _proto.trimToBreakable = function trimToBreakable(prev) {
    var next = [].concat(prev);
    var prevLine = next[next.length - 2];
    var index = this.findBreakableIndex(prevLine);
    if (index === -1 || !prevLine) return next;
    var trimmedChar = prevLine.slice(index, index + 1);
    var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
    var trimFrom = index + 1;
    var trimTo = index + (isTrimmedWithSpace ? 0 : 1);
    next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
    next[next.length - 2] = prevLine.slice(0, trimTo);
    return next;
  };
  _proto.canBreakInLastChar = function canBreakInLastChar(char) {
    if (char && LATIN_REGEX.test(char)) return false;
    return true;
  };
  _proto.sumTextWidthByCache = function sumTextWidthByCache(text, cache) {
    return text.split('').reduce(function (sum, c) {
      if (!cache[c]) throw Error('cannot count the word without cache');
      return sum + cache[c];
    }, 0);
  };
  _proto.findBreakableIndex = function findBreakableIndex(line) {
    for (var i = line.length - 1; i >= 0; i--) {
      if (!LATIN_REGEX.test(line[i])) return i;
    }
    return -1;
  };
  _proto.getFromCache = function getFromCache(key, letterSpacing, cache, context) {
    var width = cache[key];
    if (typeof width !== 'number') {
      var spacing = key.length * letterSpacing;
      width = context.measureText(key).width + spacing;
      cache[key] = width;
    }
    return width;
  };
  return TextService;
}();

var _this = undefined;
var runtime = {};
/**
 * Replace with IoC container
 */
var geometryUpdaterFactory = function () {
  var _ref;
  var rectUpdater = new RectUpdater();
  var polylineUpdater = new PolylineUpdater();
  return _ref = {}, _ref[exports.Shape.CIRCLE] = new CircleUpdater(), _ref[exports.Shape.ELLIPSE] = new EllipseUpdater(), _ref[exports.Shape.RECT] = rectUpdater, _ref[exports.Shape.IMAGE] = rectUpdater, _ref[exports.Shape.GROUP] = rectUpdater, _ref[exports.Shape.LINE] = new LineUpdater(), _ref[exports.Shape.TEXT] = new TextUpdater(runtime), _ref[exports.Shape.POLYLINE] = polylineUpdater, _ref[exports.Shape.POLYGON] = polylineUpdater, _ref[exports.Shape.PATH] = new PathUpdater(), _ref[exports.Shape.HTML] = null, _ref[exports.Shape.MESH] = null, _ref;
}();
var CSSPropertySyntaxFactory = function () {
  var _ref2;
  var color = new CSSPropertyColor();
  var length = new CSSPropertyLengthOrPercentage();
  return _ref2 = {}, _ref2[exports.PropertySyntax.PERCENTAGE] = null, _ref2[exports.PropertySyntax.NUMBER] = new CSSPropertyNumber(), _ref2[exports.PropertySyntax.ANGLE] = new CSSPropertyAngle(), _ref2[exports.PropertySyntax.DEFINED_PATH] = new CSSPropertyClipPath(), _ref2[exports.PropertySyntax.PAINT] = color, _ref2[exports.PropertySyntax.COLOR] = color, _ref2[exports.PropertySyntax.FILTER] = new CSSPropertyFilter(), _ref2[exports.PropertySyntax.LENGTH] = length, _ref2[exports.PropertySyntax.LENGTH_PERCENTAGE] = length, _ref2[exports.PropertySyntax.LENGTH_PERCENTAGE_12] = new CSSPropertyLengthOrPercentage12(), _ref2[exports.PropertySyntax.LENGTH_PERCENTAGE_14] = new CSSPropertyLengthOrPercentage14(), _ref2[exports.PropertySyntax.COORDINATE] = new CSSPropertyLocalPosition(), _ref2[exports.PropertySyntax.OFFSET_DISTANCE] = new CSSPropertyOffsetDistance(), _ref2[exports.PropertySyntax.OPACITY_VALUE] = new CSSPropertyOpacity(), _ref2[exports.PropertySyntax.PATH] = new CSSPropertyPath(), _ref2[exports.PropertySyntax.LIST_OF_POINTS] = new CSSPropertyPoints(), _ref2[exports.PropertySyntax.SHADOW_BLUR] = new CSSPropertyShadowBlur(), _ref2[exports.PropertySyntax.TEXT] = new CSSPropertyText(), _ref2[exports.PropertySyntax.TEXT_TRANSFORM] = new CSSPropertyTextTransform(), _ref2[exports.PropertySyntax.TRANSFORM] = new CSSPropertyTransform(), _ref2[exports.PropertySyntax.TRANSFORM_ORIGIN] = new CSSPropertyTransformOrigin(), _ref2[exports.PropertySyntax.Z_INDEX] = new CSSPropertyZIndex(), _ref2[exports.PropertySyntax.MARKER] = new CSSPropertyMarker(), _ref2;
}();
var getGlobalThis = function getGlobalThis() {
  if (typeof globalThis !== 'undefined') return globalThis;
  if (typeof self !== 'undefined') return self;
  if (typeof window !== 'undefined') return window;
  // @ts-ignore
  if (typeof global !== 'undefined') return global;
  if (typeof _this !== 'undefined') return _this;
  throw new Error('Unable to locate global `this`');
};
/**
 * Camera
 * `g-camera-api` will provide an advanced implementation
 */
runtime.CameraContribution = Camera;
/**
 * `g-web-animations-api` will provide an AnimationTimeline
 */
runtime.AnimationTimeline = null;
runtime.EasingFunction = null;
runtime.offscreenCanvas = new OffscreenCanvasCreator();
runtime.displayObjectPool = new DisplayObjectPool();
runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
runtime.textService = new TextService(runtime);
runtime.geometryUpdaterFactory = geometryUpdaterFactory;
runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
runtime.styleValueRegistry = new DefaultStyleValueRegistry();
runtime.layoutRegistry = null;
runtime.globalThis = getGlobalThis();
runtime.enableCSSParsing = true;

var AbstractRendererPlugin = /*#__PURE__*/function () {
  function AbstractRendererPlugin() {
    this.context = void 0;
    this.plugins = [];
  }
  var _proto = AbstractRendererPlugin.prototype;
  _proto.addRenderingPlugin = function addRenderingPlugin(plugin) {
    this.plugins.push(plugin);
    this.context.renderingPlugins.push(plugin);
  };
  _proto.removeAllRenderingPlugins = function removeAllRenderingPlugins() {
    var _this = this;
    this.plugins.forEach(function (plugin) {
      var index = _this.context.renderingPlugins.indexOf(plugin);
      if (index >= 0) {
        _this.context.renderingPlugins.splice(index, 1);
      }
    });
  };
  return AbstractRendererPlugin;
}();
var AbstractRenderer = /*#__PURE__*/function () {
  function AbstractRenderer(config) {
    this.plugins = [];
    this.config = void 0;
    this.config = _extends({
      /**
       * only dirty object will cause re-render
       */
      enableDirtyCheck: true,
      enableCulling: false,
      /**
       * enable auto rendering by default
       */
      enableAutoRendering: true,
      /**
       * enable dirty rectangle rendering by default
       */
      enableDirtyRectangleRendering: true,
      enableDirtyRectangleRenderingDebug: false
    }, config);
  }
  var _proto2 = AbstractRenderer.prototype;
  _proto2.registerPlugin = function registerPlugin(plugin) {
    var index = this.plugins.findIndex(function (p) {
      return p === plugin;
    });
    if (index === -1) {
      this.plugins.push(plugin);
    }
  };
  _proto2.unregisterPlugin = function unregisterPlugin(plugin) {
    var index = this.plugins.findIndex(function (p) {
      return p === plugin;
    });
    if (index > -1) {
      this.plugins.splice(index, 1);
    }
  };
  _proto2.getPlugins = function getPlugins() {
    return this.plugins;
  };
  _proto2.getPlugin = function getPlugin(name) {
    return this.plugins.find(function (plugin) {
      return plugin.name === name;
    });
  };
  _proto2.getConfig = function getConfig() {
    return this.config;
  };
  _proto2.setConfig = function setConfig(config) {
    Object.assign(this.config, config);
  };
  return AbstractRenderer;
}();

/**
 * apply following rules:
 * 1. `visibility` in scenegraph node
 * 2. other custom culling strategies, eg. frustum culling
 */
var CullingPlugin = /*#__PURE__*/function () {
  function CullingPlugin(strategies) {
    this.strategies = void 0;
    this.strategies = strategies;
  }
  var _proto = CullingPlugin.prototype;
  _proto.apply = function apply(context) {
    var camera = context.camera,
      renderingService = context.renderingService,
      renderingContext = context.renderingContext;
    var strategies = this.strategies;
    renderingService.hooks.cull.tap(CullingPlugin.tag, function (object) {
      if (object) {
        var cullable = object.cullable;
        // cullable.visible = true;
        // const renderBounds = object.getRenderBounds();
        // if (AABB.isEmpty(renderBounds)) {
        //   cullable.visible = false;
        // } else {
        //   const isShape2D = shape2D.indexOf(object.nodeName as Shape) > -1;
        //   const [p0, p1, p2, p3] = camera.getFrustum().planes;
        //   tmpAABB.setMinMax([-p1.distance, -p3.distance, 0], [p0.distance, p2.distance, 0]);
        //   cullable.visible = isShape2D ? renderBounds.intersects(tmpAABB) : true;
        // }
        if (strategies.length === 0) {
          cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
        } else {
          // eg. implemented by g-webgl(frustum culling)
          cullable.visible = strategies.every(function (strategy) {
            return strategy.isVisible(camera, object);
          });
        }
        if (!object.isCulled() && object.isVisible()) {
          return object;
        } else {
          // if (this.renderingContext.renderListLastFrame.indexOf(object) > -1) {
          object.dispatchEvent(new CustomEvent(exports.ElementEvent.CULLED));
          // }
        }

        return null;
      }
      return object;
    });
    renderingService.hooks.afterRender.tap(CullingPlugin.tag, function (object) {
      object.cullable.visibilityPlaneMask = -1;
    });
  };
  return CullingPlugin;
}();
CullingPlugin.tag = 'Culling';

/**
 * Filter dirty renderables and calculate the "dirty rectangle" which will be clear when frame began
 */
var DirtyCheckPlugin = /*#__PURE__*/function () {
  function DirtyCheckPlugin() {}
  var _proto = DirtyCheckPlugin.prototype;
  _proto.apply = function apply(context) {
    var renderingService = context.renderingService;
    renderingService.hooks.dirtycheck.tap(DirtyCheckPlugin.tag, function (object) {
      if (object) {
        var renderable = object.renderable;
        var isDirty = renderable.dirty || renderingService.disableDirtyRectangleRendering();
        if (isDirty) {
          return object;
        } else {
          return null;
        }
      }
      return object;
    });
  };
  return DirtyCheckPlugin;
}();
DirtyCheckPlugin.tag = 'DirtyCheck';

/**
 * support mouse & touch events
 * @see https://github.com/pixijs/pixi.js/blob/dev/packages/interaction/README.md
 *
 * also provide some extra events such as `drag`
 */
var EventPlugin = /*#__PURE__*/function () {
  function EventPlugin() {
    var _this = this;
    this.autoPreventDefault = false;
    this.rootPointerEvent = new FederatedPointerEvent(null);
    this.rootWheelEvent = new FederatedWheelEvent(null);
    this.context = void 0;
    this.onPointerMove = function (nativeEvent) {
      var _this$context$renderi, _this$context$renderi2;
      var canvas = (_this$context$renderi = _this.context.renderingContext.root) === null || _this$context$renderi === void 0 ? void 0 : (_this$context$renderi2 = _this$context$renderi.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === 'touch') return;
      var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
      for (var _iterator = _createForOfIteratorHelperLoose(normalizedEvents), _step; !(_step = _iterator()).done;) {
        var normalizedEvent = _step.value;
        var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas);
        _this.context.eventService.mapEvent(event);
      }
      _this.setCursor(_this.context.eventService.cursor);
    };
  }
  var _proto = EventPlugin.prototype;
  _proto.apply = function apply(context) {
    var _this2 = this;
    this.context = context;
    var renderingService = context.renderingService;
    var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
    this.context.eventService.setPickHandler( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(position) {
        var _yield$_this2$context, picked;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2.context.renderingService.hooks.pick.promise({
                  position: position,
                  picked: [],
                  topmost: true // we only concern the topmost element
                });
              case 2:
                _yield$_this2$context = _context.sent;
                picked = _yield$_this2$context.picked;
                return _context.abrupt("return", picked[0] || null);
              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    renderingService.hooks.pointerWheel.tap(EventPlugin.tag, function (nativeEvent) {
      var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
      _this2.context.eventService.mapEvent(wheelEvent);
    });
    renderingService.hooks.pointerDown.tap(EventPlugin.tag, function (nativeEvent) {
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === 'touch') return;
      var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      if (_this2.autoPreventDefault && events[0].isNormalized) {
        var cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);
        if (cancelable) {
          nativeEvent.preventDefault();
        }
      }
      for (var _iterator2 = _createForOfIteratorHelperLoose(events), _step2; !(_step2 = _iterator2()).done;) {
        var event = _step2.value;
        var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas);
        _this2.context.eventService.mapEvent(federatedEvent);
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    });
    renderingService.hooks.pointerUp.tap(EventPlugin.tag, function (nativeEvent) {
      if (canvas.supportsTouchEvents && nativeEvent.pointerType === 'touch') return;
      // account for element in SVG
      var $element = _this2.context.contextService.getDomElement();
      var outside = 'outside';
      try {
        outside = $element && nativeEvent.target && nativeEvent.target !== $element && $element.contains && !$element.contains(nativeEvent.target) ? 'outside' : '';
      } catch (e) {
        // nativeEvent.target maybe not Node, such as Window
        // @see https://github.com/antvis/G/issues/1235
      }
      var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
      for (var _iterator3 = _createForOfIteratorHelperLoose(normalizedEvents), _step3; !(_step3 = _iterator3()).done;) {
        var normalizedEvent = _step3.value;
        var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas);
        event.type += outside;
        _this2.context.eventService.mapEvent(event);
      }
      _this2.setCursor(_this2.context.eventService.cursor);
    });
    renderingService.hooks.pointerMove.tap(EventPlugin.tag, this.onPointerMove);
    renderingService.hooks.pointerOver.tap(EventPlugin.tag, this.onPointerMove);
    renderingService.hooks.pointerOut.tap(EventPlugin.tag, this.onPointerMove);
  };
  _proto.getViewportXY = function getViewportXY(nativeEvent) {
    var x;
    var y;
    /**
     * Should account for CSS Transform applied on container.
     * @see https://github.com/antvis/G/issues/1161
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
     */
    var offsetX = nativeEvent.offsetX,
      offsetY = nativeEvent.offsetY,
      clientX = nativeEvent.clientX,
      clientY = nativeEvent.clientY;
    if (this.context.config.supportsCSSTransform && !util.isNil(offsetX) && !util.isNil(offsetY)) {
      x = offsetX;
      y = offsetY;
    } else {
      var point = this.context.eventService.client2Viewport(new Point(clientX, clientY));
      x = point.x;
      y = point.y;
    }
    return {
      x: x,
      y: y
    };
  };
  _proto.bootstrapEvent = function bootstrapEvent(event, nativeEvent, view) {
    event.view = view;
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this.transferMouseData(event, nativeEvent);
    var _this$getViewportXY = this.getViewportXY(nativeEvent),
      x = _this$getViewportXY.x,
      y = _this$getViewportXY.y;
    event.viewport.x = x;
    event.viewport.y = y;
    var _this$context$eventSe = this.context.eventService.viewport2Canvas(event.viewport),
      canvasX = _this$context$eventSe.x,
      canvasY = _this$context$eventSe.y;
    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === 'pointerleave') {
      event.type = 'pointerout';
    }
    if (event.type.startsWith('mouse')) {
      event.type = event.type.replace('mouse', 'pointer');
    }
    if (event.type.startsWith('touch')) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  };
  _proto.normalizeWheelEvent = function normalizeWheelEvent(nativeEvent) {
    var event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent);
    event.deltaMode = nativeEvent.deltaMode;
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    var _this$getViewportXY2 = this.getViewportXY(nativeEvent),
      x = _this$getViewportXY2.x,
      y = _this$getViewportXY2.y;
    event.viewport.x = x;
    event.viewport.y = y;
    var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport),
      canvasX = _this$context$eventSe2.x,
      canvasY = _this$context$eventSe2.y;
    event.canvas.x = canvasX;
    event.canvas.y = canvasY;
    event.global.copyFrom(event.canvas);
    event.offset.copyFrom(event.canvas);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  /**
   * Transfers base & mouse event data from the nativeEvent to the federated event.
   */;
  _proto.transferMouseData = function transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.metaKey = nativeEvent.metaKey;
    event.shiftKey = nativeEvent.shiftKey;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.screen.x = nativeEvent.screenX;
    event.screen.y = nativeEvent.screenY;
    event.relatedTarget = null;
  };
  _proto.setCursor = function setCursor(cursor) {
    this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || 'default');
  };
  _proto.normalizeToPointerEvent = function normalizeToPointerEvent(event, canvas) {
    var normalizedEvents = [];
    if (canvas.isTouchEvent(event)) {
      for (var i = 0; i < event.changedTouches.length; i++) {
        var touch = event.changedTouches[i];
        // use changedTouches instead of touches since touchend has no touches
        // @see https://stackoverflow.com/a/10079076
        if (util.isUndefined(touch.button)) touch.button = 0;
        if (util.isUndefined(touch.buttons)) touch.buttons = 1;
        if (util.isUndefined(touch.isPrimary)) {
          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
        }
        if (util.isUndefined(touch.width)) touch.width = touch.radiusX || 1;
        if (util.isUndefined(touch.height)) touch.height = touch.radiusY || 1;
        if (util.isUndefined(touch.tiltX)) touch.tiltX = 0;
        if (util.isUndefined(touch.tiltY)) touch.tiltY = 0;
        if (util.isUndefined(touch.pointerType)) touch.pointerType = 'touch';
        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Touch/identifier
        if (util.isUndefined(touch.pointerId)) touch.pointerId = touch.identifier || 0;
        if (util.isUndefined(touch.pressure)) touch.pressure = touch.force || 0.5;
        if (util.isUndefined(touch.twist)) touch.twist = 0;
        if (util.isUndefined(touch.tangentialPressure)) touch.tangentialPressure = 0;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (canvas.isMouseEvent(event)) {
      var tempEvent = event;
      if (util.isUndefined(tempEvent.isPrimary)) tempEvent.isPrimary = true;
      if (util.isUndefined(tempEvent.width)) tempEvent.width = 1;
      if (util.isUndefined(tempEvent.height)) tempEvent.height = 1;
      if (util.isUndefined(tempEvent.tiltX)) tempEvent.tiltX = 0;
      if (util.isUndefined(tempEvent.tiltY)) tempEvent.tiltY = 0;
      if (util.isUndefined(tempEvent.pointerType)) tempEvent.pointerType = 'mouse';
      if (util.isUndefined(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;
      if (util.isUndefined(tempEvent.pressure)) tempEvent.pressure = 0.5;
      if (util.isUndefined(tempEvent.twist)) tempEvent.twist = 0;
      if (util.isUndefined(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  };
  return EventPlugin;
}();
EventPlugin.tag = 'Event';

// group is not a 2d shape
var shape2D = [exports.Shape.CIRCLE, exports.Shape.ELLIPSE, exports.Shape.IMAGE, exports.Shape.RECT, exports.Shape.LINE, exports.Shape.POLYLINE, exports.Shape.POLYGON, exports.Shape.TEXT, exports.Shape.PATH, exports.Shape.HTML];
var FrustumCullingStrategy = /*#__PURE__*/function () {
  function FrustumCullingStrategy() {}
  var _proto = FrustumCullingStrategy.prototype;
  _proto.isVisible = function isVisible(camera, object) {
    var _object$parentNode, _object$parentNode$cu;
    // return true;
    var cullable = object.cullable;
    if (!cullable.enable) {
      return true;
    }
    var renderBounds = object.getRenderBounds();
    if (AABB.isEmpty(renderBounds)) {
      return false;
    }
    // get VP matrix from camera
    var frustum = camera.getFrustum();
    var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 ? void 0 : (_object$parentNode$cu = _object$parentNode.cullable) === null || _object$parentNode$cu === void 0 ? void 0 : _object$parentNode$cu.visibilityPlaneMask;
    cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || exports.Mask.INDETERMINATE, frustum.planes);
    cullable.visible = cullable.visibilityPlaneMask !== exports.Mask.OUTSIDE;
    return cullable.visible;
  }
  /**
   *
   * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」
   * @see https://github.com/antvis/GWebGPUEngine/issues/3
   *
   * * 基础相交测试 the basic intersection test
   * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
   * * TODO: 平面一致性测试 the plane-coherency test
   * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
   *
   * @param aabb aabb
   * @param parentPlaneMask mask of parent
   * @param planes planes of frustum
   */;
  _proto.computeVisibilityWithPlaneMask = function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
    if (parentPlaneMask === exports.Mask.OUTSIDE || parentPlaneMask === exports.Mask.INSIDE) {
      // 父节点完全位于视锥内或者外部，直接返回
      return parentPlaneMask;
    }
    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.
    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)
    var mask = exports.Mask.INSIDE;
    var isShape2D = shape2D.indexOf(object.nodeName) > -1;
    // Use viewport culling for 2D shapes
    // @see https://github.com/antvis/g/issues/914
    for (var k = 0, len = planes.length; k < len; ++k) {
      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.
      var flag = 1 << k;
      if ((parentPlaneMask & flag) === 0) {
        // 父节点处于当前面内部，可以跳过
        continue;
      }
      // skip near & far planes when testing 2D shapes
      if (isShape2D && (k === 4 || k === 5)) {
        continue;
      }
      // p-vertex n-vertex <-|plane p-vertex n-vertex
      // 使用 p-vertex 和 n-vertex 加速，避免进行平面和 aabb 全部顶点的相交检测
      var _planes$k = planes[k],
        normal = _planes$k.normal,
        distance = _planes$k.distance;
      if (glMatrix.vec3.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance < 0) {
        return exports.Mask.OUTSIDE;
      }
      if (glMatrix.vec3.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance < 0) {
        // 和当前面相交，对应位置为1，继续检测下一个面
        mask |= flag;
      }
    }
    return mask;
  };
  return FrustumCullingStrategy;
}();

var PrepareRendererPlugin = /*#__PURE__*/function () {
  function PrepareRendererPlugin() {
    this.rBush = void 0;
    this.toSync = new Set();
  }
  var _proto = PrepareRendererPlugin.prototype;
  // private isFirstTimeRendering = true;
  // private syncing = false;
  _proto.apply = function apply(context) {
    var _this = this;
    var renderingService = context.renderingService,
      renderingContext = context.renderingContext,
      rBushRoot = context.rBushRoot;
    var canvas = renderingContext.root.ownerDocument.defaultView;
    this.rBush = rBushRoot;
    var handleAttributeChanged = function handleAttributeChanged(e) {
      var object = e.target;
      object.renderable.dirty = true;
      renderingService.dirtify();
    };
    var handleBoundsChanged = function handleBoundsChanged(e) {
      var affectChildren = e.detail.affectChildren;
      var object = e.target;
      if (affectChildren) {
        object.forEach(function (node) {
          _this.toSync.add(node);
        });
      }
      var p = object;
      while (p) {
        if (p.renderable) {
          _this.toSync.add(p);
        }
        p = p.parentElement;
      }
      // this.pushToSync(e.composedPath().slice(0, -2) as DisplayObject[]);
      renderingService.dirtify();
    };
    var handleMounted = function handleMounted(e) {
      var object = e.target;
      if (runtime.enableCSSParsing) {
        // recalc style values
        runtime.styleValueRegistry.recalc(object);
      }
      runtime.sceneGraphService.dirtifyToRoot(object);
      renderingService.dirtify();
    };
    var handleUnmounted = function handleUnmounted(e) {
      var object = e.target;
      var rBushNode = object.rBushNode;
      if (rBushNode.aabb) {
        _this.rBush.remove(rBushNode.aabb);
      }
      _this.toSync.delete(object);
      runtime.sceneGraphService.dirtifyToRoot(object);
      renderingService.dirtify();
    };
    renderingService.hooks.init.tapPromise(PrepareRendererPlugin.tag, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(exports.ElementEvent.MOUNTED, handleMounted);
              canvas.addEventListener(exports.ElementEvent.UNMOUNTED, handleUnmounted);
              canvas.addEventListener(exports.ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
              canvas.addEventListener(exports.ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    renderingService.hooks.destroy.tap(PrepareRendererPlugin.tag, function () {
      canvas.removeEventListener(exports.ElementEvent.MOUNTED, handleMounted);
      canvas.removeEventListener(exports.ElementEvent.UNMOUNTED, handleUnmounted);
      canvas.removeEventListener(exports.ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      canvas.removeEventListener(exports.ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
      _this.toSync.clear();
    });
    renderingService.hooks.endFrame.tap(PrepareRendererPlugin.tag, function () {
      // if (this.isFirstTimeRendering) {
      //   this.isFirstTimeRendering = false;
      //   this.syncing = true;
      //   // @see https://github.com/antvis/G/issues/1117
      //   setTimeout(() => {
      //     this.syncRTree();
      //     console.log('fcp...');
      //   });
      // } else {
      //   console.log('next...');
      _this.syncRTree();
      // }
    });
  };
  _proto.syncRTree = function syncRTree() {
    var _this2 = this;
    // if (this.syncing) {
    //   return;
    // }
    // bounds changed, need re-inserting its children
    var bulk = [];
    Array.from(this.toSync)
    // some objects may be removed since last frame
    .filter(function (object) {
      return object.isConnected;
    }).forEach(function (node) {
      var rBushNode = node.rBushNode;
      // clear dirty node
      if (rBushNode && rBushNode.aabb) {
        _this2.rBush.remove(rBushNode.aabb);
      }
      var renderBounds = node.getRenderBounds();
      if (renderBounds) {
        var _renderBounds$getMin = renderBounds.getMin(),
          minX = _renderBounds$getMin[0],
          minY = _renderBounds$getMin[1];
        var _renderBounds$getMax = renderBounds.getMax(),
          maxX = _renderBounds$getMax[0],
          maxY = _renderBounds$getMax[1];
        if (!rBushNode.aabb) {
          // @ts-ignore
          rBushNode.aabb = {};
        }
        rBushNode.aabb.id = node.entity;
        rBushNode.aabb.minX = minX;
        rBushNode.aabb.minY = minY;
        rBushNode.aabb.maxX = maxX;
        rBushNode.aabb.maxY = maxY;
      }
      if (rBushNode.aabb) {
        // TODO: NaN occurs when width/height of Rect is 0
        if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
          bulk.push(rBushNode.aabb);
        }
      }
    });
    // use bulk inserting, which is ~2-3 times faster
    // @see https://github.com/mourner/rbush#bulk-inserting-data
    this.rBush.load(bulk);
    bulk.length = 0;
    this.toSync.clear();
    // this.syncing = false;
  };
  return PrepareRendererPlugin;
}();
PrepareRendererPlugin.tag = 'Prepare';

function isCanvas(value) {
  return !!value.document;
}
(function (CanvasEvent) {
  CanvasEvent["READY"] = "ready";
  CanvasEvent["BEFORE_RENDER"] = "beforerender";
  CanvasEvent["RERENDER"] = "rerender";
  CanvasEvent["AFTER_RENDER"] = "afterrender";
  CanvasEvent["BEFORE_DESTROY"] = "beforedestroy";
  CanvasEvent["AFTER_DESTROY"] = "afterdestroy";
  CanvasEvent["RESIZE"] = "resize";
  CanvasEvent["DIRTY_RECTANGLE"] = "dirtyrectangle";
})(exports.CanvasEvent || (exports.CanvasEvent = {}));
var DEFAULT_CAMERA_Z = 500;
var DEFAULT_CAMERA_NEAR = 0.1;
var DEFAULT_CAMERA_FAR = 1000;
/**
 * reuse custom event preventing from re-create them in every frame
 */
var mountedEvent = new CustomEvent(exports.ElementEvent.MOUNTED);
var unmountedEvent = new CustomEvent(exports.ElementEvent.UNMOUNTED);
var beforeRenderEvent = new CustomEvent(exports.CanvasEvent.BEFORE_RENDER);
var rerenderEvent = new CustomEvent(exports.CanvasEvent.RERENDER);
var afterRenderEvent = new CustomEvent(exports.CanvasEvent.AFTER_RENDER);
/**
 * can be treated like Window in DOM
 * provide some extra methods like `window`, such as:
 * * `window.requestAnimationFrame`
 * * `window.devicePixelRatio`
 *
 * prototype chains: Canvas(Window) -> EventTarget
 */
var Canvas = /*#__PURE__*/function (_EventTarget) {
  _inheritsLoose(Canvas, _EventTarget);
  /**
   * window.document
   */

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry
   */

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
   */

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
   */

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
   */

  /**
   * whether the runtime supports PointerEvent?
   * if not, the event system won't trigger pointer events like `pointerdown`
   */

  /**
   * whether the runtime supports TouchEvent?
   * if not, the event system won't trigger touch events like `touchstart`
   */

  /**
   * is this native event a TouchEvent?
   */

  /**
   * is this native event a MouseEvent?
   */

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element
   */

  /**
   * rAF in auto rendering
   */

  function Canvas(config) {
    var _this;
    _this = _EventTarget.call(this) || this;
    // create document
    _this.document = void 0;
    _this.customElements = void 0;
    _this.requestAnimationFrame = void 0;
    _this.cancelAnimationFrame = void 0;
    _this.devicePixelRatio = void 0;
    _this.supportsPointerEvents = void 0;
    _this.supportsTouchEvents = void 0;
    _this.isTouchEvent = void 0;
    _this.isMouseEvent = void 0;
    _this.Element = DisplayObject;
    _this.frameId = void 0;
    _this.inited = false;
    _this.readyPromise = void 0;
    _this.resolveReadyPromise = void 0;
    _this.context = {};
    _this.document = new Document();
    _this.document.defaultView = _assertThisInitialized(_this);
    // create registry of custom elements
    _this.customElements = new CustomElementRegistry();
    var container = config.container,
      canvas = config.canvas,
      offscreenCanvas = config.offscreenCanvas,
      width = config.width,
      height = config.height,
      devicePixelRatio = config.devicePixelRatio,
      renderer = config.renderer,
      background = config.background,
      cursor = config.cursor,
      document = config.document,
      requestAnimationFrame = config.requestAnimationFrame,
      cancelAnimationFrame = config.cancelAnimationFrame,
      createImage = config.createImage,
      supportsPointerEvents = config.supportsPointerEvents,
      supportsTouchEvents = config.supportsTouchEvents,
      supportsCSSTransform = config.supportsCSSTransform,
      isTouchEvent = config.isTouchEvent,
      isMouseEvent = config.isMouseEvent;
    cleanExistedCanvas(container, _assertThisInitialized(_this));
    var canvasWidth = width;
    var canvasHeight = height;
    var dpr = devicePixelRatio;
    // use user-defined <canvas> or OffscreenCanvas
    if (canvas) {
      // infer width & height with dpr
      dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
      dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
      canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
      canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
    }
    /**
     * implements `Window` interface
     */
    _this.devicePixelRatio = dpr;
    _this.requestAnimationFrame = requestAnimationFrame !== null && requestAnimationFrame !== void 0 ? requestAnimationFrame : raf.bind(runtime.globalThis);
    _this.cancelAnimationFrame = cancelAnimationFrame !== null && cancelAnimationFrame !== void 0 ? cancelAnimationFrame : caf.bind(runtime.globalThis);
    /**
     * limits query
     */
    // the following feature-detect from hammer.js
    // @see https://github.com/hammerjs/hammer.js/blob/master/src/inputjs/input-consts.js#L5
    _this.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : 'ontouchstart' in runtime.globalThis;
    _this.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
    _this.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function (event) {
      return _this.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
    };
    _this.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function (event) {
      return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
    };
    _this.initRenderingContext({
      container: container,
      canvas: canvas,
      width: canvasWidth,
      height: canvasHeight,
      renderer: renderer,
      offscreenCanvas: offscreenCanvas,
      devicePixelRatio: dpr,
      cursor: cursor || 'default',
      background: background || 'transparent',
      createImage: createImage,
      document: document,
      supportsCSSTransform: supportsCSSTransform
    });
    _this.initDefaultCamera(canvasWidth, canvasHeight);
    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.initRenderer(renderer);
            case 2:
              _this.dispatchEvent(new CustomEvent(exports.CanvasEvent.READY));
              if (_this.readyPromise) {
                _this.resolveReadyPromise();
              }
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
    return _this;
  }
  var _proto = Canvas.prototype;
  _proto.initRenderingContext = function initRenderingContext(mergedConfig) {
    this.context.config = mergedConfig;
    // bind rendering context, shared by all renderers
    this.context.renderingContext = {
      /**
       * the root node in scene graph
       */
      root: this.document.documentElement,
      renderListCurrentFrame: [],
      unculledEntities: [],
      renderReasons: new Set(),
      force: false,
      dirty: false
    };
  };
  _proto.initDefaultCamera = function initDefaultCamera(width, height) {
    var _this2 = this;
    // set a default ortho camera
    var camera = new runtime.CameraContribution();
    camera.setType(exports.CameraType.EXPLORING, exports.CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
    // keep ref since it will use raf in camera animation
    camera.canvas = this;
    // redraw when camera changed
    camera.eventEmitter.on(CameraEvent.UPDATED, function () {
      _this2.context.renderingContext.renderReasons.add(exports.RenderReason.CAMERA_CHANGED);
    });
    // bind camera
    this.context.camera = camera;
  };
  _proto.getConfig = function getConfig() {
    return this.context.config;
  }
  /**
   * get the root displayObject in scenegraph
   * @alias this.document.documentElement
   */;
  _proto.getRoot = function getRoot() {
    return this.document.documentElement;
  }
  /**
   * get the camera of canvas
   */;
  _proto.getCamera = function getCamera() {
    return this.context.camera;
  };
  _proto.getContextService = function getContextService() {
    return this.context.contextService;
  };
  _proto.getEventService = function getEventService() {
    return this.context.eventService;
  };
  _proto.getRenderingService = function getRenderingService() {
    return this.context.renderingService;
  };
  _proto.getRenderingContext = function getRenderingContext() {
    return this.context.renderingContext;
  };
  _proto.getStats = function getStats() {
    return this.getRenderingService().getStats();
  }
  // /**
  //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
  //  */
  // getComputedStyle(node: DisplayObject) {
  //   return node.computedStyle;
  // }
  ;
  /**
   * `cleanUp` means clean all the internal services of Canvas which happens when calling `canvas.destroy()`.
   */
  _proto.destroy = function destroy(cleanUp, skipTriggerEvent) {
    if (cleanUp === void 0) {
      cleanUp = true;
    }
    if (skipTriggerEvent === void 0) {
      skipTriggerEvent = false;
    }
    if (!skipTriggerEvent) {
      this.dispatchEvent(new CustomEvent(exports.CanvasEvent.BEFORE_DESTROY));
    }
    if (this.frameId) {
      var cancelRAF = this.getConfig().cancelAnimationFrame || cancelAnimationFrame;
      cancelRAF(this.frameId);
    }
    // unmount all children
    var root = this.getRoot();
    this.unmountChildren(root);
    if (cleanUp) {
      // destroy Document
      this.document.destroy();
      this.getEventService().destroy();
    }
    // destroy services
    this.getRenderingService().destroy();
    this.getContextService().destroy();
    // clear root after renderservice destroyed
    if (cleanUp && this.context.rBushRoot) {
      // clear rbush
      this.context.rBushRoot.clear();
      this.context.rBushRoot = null;
      this.context.renderingContext.root = null;
    }
    if (!skipTriggerEvent) {
      this.dispatchEvent(new CustomEvent(exports.CanvasEvent.AFTER_DESTROY));
    }
  }
  /**
   * compatible with G 3.0
   * @deprecated
   * @alias resize
   */;
  _proto.changeSize = function changeSize(width, height) {
    this.resize(width, height);
  };
  _proto.resize = function resize(width, height) {
    // update canvas' config
    var canvasConfig = this.context.config;
    canvasConfig.width = width;
    canvasConfig.height = height;
    // resize context
    this.getContextService().resize(width, height);
    // resize camera
    var camera = this.context.camera;
    var projectionMode = camera.getProjectionMode();
    camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
    if (projectionMode === exports.CameraProjectionMode.ORTHOGRAPHIC) {
      camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
    } else {
      camera.setAspect(width / height);
    }
    this.dispatchEvent(new CustomEvent(exports.CanvasEvent.RESIZE, {
      width: width,
      height: height
    }));
  }
  // proxy to document.documentElement
  ;
  _proto.appendChild = function appendChild(child, index) {
    return this.document.documentElement.appendChild(child, index);
  };
  _proto.insertBefore = function insertBefore(newChild, refChild) {
    return this.document.documentElement.insertBefore(newChild, refChild);
  };
  _proto.removeChild = function removeChild(child) {
    return this.document.documentElement.removeChild(child);
  }
  /**
   * Remove all children which can be appended to its original parent later again.
   */;
  _proto.removeChildren = function removeChildren() {
    this.document.documentElement.removeChildren();
  }
  /**
   * Recursively destroy all children which can not be appended to its original parent later again.
   * But the canvas remains running which means display objects can be appended later.
   */;
  _proto.destroyChildren = function destroyChildren() {
    this.document.documentElement.destroyChildren();
  };
  _proto.render = function render() {
    var _this3 = this;
    this.dispatchEvent(beforeRenderEvent);
    var renderingService = this.getRenderingService();
    renderingService.render(this.getConfig(), function () {
      // trigger actual rerender event
      // @see https://github.com/antvis/G/issues/1268
      _this3.dispatchEvent(rerenderEvent);
    });
    this.dispatchEvent(afterRenderEvent);
  };
  _proto.run = function run() {
    var _this4 = this;
    var tick = function tick() {
      _this4.render();
      _this4.frameId = requestAnimationFrame(tick);
    };
    tick();
  };
  _proto.initRenderer = /*#__PURE__*/function () {
    var _initRenderer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(renderer) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (renderer) {
                _context2.next = 2;
                break;
              }
              throw new Error('Renderer is required.');
            case 2:
              // reset
              this.inited = false;
              this.readyPromise = undefined;
              // FIXME: should re-create here?
              this.context.rBushRoot = new RBush__default['default']();
              // reset rendering plugins
              this.context.renderingPlugins = [];
              this.context.renderingPlugins.push(new EventPlugin(), new PrepareRendererPlugin(), new DirtyCheckPlugin(), new CullingPlugin([new FrustumCullingStrategy()]));
              //
              this.loadRendererContainerModule(renderer);
              // init context service
              this.context.contextService = new this.context.ContextService(_extends({}, runtime, this.context));
              // init rendering service
              this.context.renderingService = new RenderingService(runtime, this.context);
              // init event service
              this.context.eventService = new EventService(runtime, this.context);
              this.context.eventService.init();
              _context2.next = 14;
              return this.context.contextService.init();
            case 14:
              _context2.next = 16;
              return this.context.renderingService.init();
            case 16:
              this.inited = true;
              this.getRoot().forEach(function (node) {
                var renderable = node.renderable;
                if (renderable) {
                  renderable.renderBoundsDirty = true;
                  renderable.boundsDirty = true;
                  renderable.dirty = true;
                }
              });
              // keep current scenegraph unchanged, just trigger mounted event
              this.mountChildren(this.getRoot());
              if (renderer.getConfig().enableAutoRendering) {
                this.run();
              }
            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    function initRenderer(_x) {
      return _initRenderer.apply(this, arguments);
    }
    return initRenderer;
  }();
  _proto.loadRendererContainerModule = function loadRendererContainerModule(renderer) {
    var _this5 = this;
    // load other container modules provided by g-canvas/g-svg/g-webgl
    var plugins = renderer.getPlugins();
    plugins.forEach(function (plugin) {
      plugin.context = _this5.context;
      plugin.init(runtime);
    });
  };
  _proto.setRenderer = /*#__PURE__*/function () {
    var _setRenderer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(renderer) {
      var canvasConfig, oldRenderer;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              // update canvas' config
              canvasConfig = this.getConfig();
              if (!(canvasConfig.renderer === renderer)) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return");
            case 3:
              oldRenderer = canvasConfig.renderer;
              canvasConfig.renderer = renderer;
              // keep all children undestroyed
              this.destroy(false, true);
              // destroy all plugins, reverse will mutate origin array
              [].concat(oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()).reverse().forEach(function (plugin) {
                plugin.destroy(runtime);
              });
              _context3.next = 9;
              return this.initRenderer(renderer);
            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
    function setRenderer(_x2) {
      return _setRenderer.apply(this, arguments);
    }
    return setRenderer;
  }();
  _proto.setCursor = function setCursor(cursor) {
    var canvasConfig = this.getConfig();
    canvasConfig.cursor = cursor;
    this.getContextService().applyCursorStyle(cursor);
  };
  _proto.unmountChildren = function unmountChildren(parent) {
    var _this6 = this;
    // unmountChildren recursively
    parent.childNodes.forEach(function (child) {
      _this6.unmountChildren(child);
    });
    if (this.inited) {
      if (parent.isMutationObserved) {
        parent.dispatchEvent(unmountedEvent);
      } else {
        unmountedEvent.target = parent;
        this.dispatchEvent(unmountedEvent, true);
      }
      // skip document.documentElement
      if (parent !== this.document.documentElement) {
        parent.ownerDocument = null;
      }
      parent.isConnected = false;
    }
    // trigger after unmounted
    if (parent.isCustomElement) {
      if (parent.disconnectedCallback) {
        parent.disconnectedCallback();
      }
    }
  };
  _proto.mountChildren = function mountChildren(parent) {
    var _this7 = this;
    if (this.inited) {
      if (!parent.isConnected) {
        parent.ownerDocument = this.document;
        parent.isConnected = true;
        if (parent.isMutationObserved) {
          parent.dispatchEvent(mountedEvent);
        } else {
          mountedEvent.target = parent;
          this.dispatchEvent(mountedEvent, true);
        }
      }
    } else {
      console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", 'appended child: ', parent.nodeName);
    }
    // recursively mount children
    parent.childNodes.forEach(function (child) {
      _this7.mountChildren(child);
    });
    // trigger after mounted
    if (parent.isCustomElement) {
      if (parent.connectedCallback) {
        parent.connectedCallback();
      }
    }
  };
  _proto.client2Viewport = function client2Viewport(client) {
    return this.getEventService().client2Viewport(client);
  };
  _proto.viewport2Client = function viewport2Client(canvas) {
    return this.getEventService().viewport2Client(canvas);
  };
  _proto.viewport2Canvas = function viewport2Canvas(viewport) {
    return this.getEventService().viewport2Canvas(viewport);
  };
  _proto.canvas2Viewport = function canvas2Viewport(canvas) {
    return this.getEventService().canvas2Viewport(canvas);
  }
  /**
   * @deprecated
   * @alias client2Viewport
   */;
  _proto.getPointByClient = function getPointByClient(clientX, clientY) {
    return this.client2Viewport({
      x: clientX,
      y: clientY
    });
  }
  /**
   * @deprecated
   * @alias viewport2Client
   */;
  _proto.getClientByPoint = function getClientByPoint(x, y) {
    return this.viewport2Client({
      x: x,
      y: y
    });
  };
  _createClass(Canvas, [{
    key: "ready",
    get: function get() {
      var _this8 = this;
      if (!this.readyPromise) {
        this.readyPromise = new Promise(function (resolve) {
          _this8.resolveReadyPromise = function () {
            resolve(_this8);
          };
        });
        if (this.inited) {
          this.resolveReadyPromise();
        }
      }
      return this.readyPromise;
    }
  }]);
  return Canvas;
}(EventTarget);

Object.defineProperty(exports, 'RBush', {
  enumerable: true,
  get: function () {
    return RBush__default['default'];
  }
});
exports.AABB = AABB;
exports.AbstractRenderer = AbstractRenderer;
exports.AbstractRendererPlugin = AbstractRendererPlugin;
exports.BUILT_IN_PROPERTIES = BUILT_IN_PROPERTIES;
exports.CSS = CSS;
exports.CSSGradientValue = CSSGradientValue;
exports.CSSKeywordValue = CSSKeywordValue;
exports.CSSRGB = CSSRGB;
exports.CSSStyleValue = CSSStyleValue;
exports.CSSUnitValue = CSSUnitValue;
exports.Camera = Camera;
exports.CameraEvent = CameraEvent;
exports.Canvas = Canvas;
exports.Circle = Circle;
exports.CircleUpdater = CircleUpdater;
exports.CustomElement = CustomElement;
exports.CustomElementRegistry = CustomElementRegistry;
exports.CustomEvent = CustomEvent;
exports.DefaultSceneGraphSelector = DefaultSceneGraphSelector;
exports.DefaultSceneGraphService = DefaultSceneGraphService;
exports.DisplayObject = DisplayObject;
exports.DisplayObjectPool = DisplayObjectPool;
exports.Document = Document;
exports.EMPTY_PARSED_PATH = EMPTY_PARSED_PATH;
exports.ERROR_MSG_METHOD_NOT_IMPLEMENTED = ERROR_MSG_METHOD_NOT_IMPLEMENTED;
exports.Element = Element;
exports.Ellipse = Ellipse;
exports.EllipseUpdater = EllipseUpdater;
exports.EventService = EventService;
exports.EventTarget = EventTarget;
exports.FederatedEvent = FederatedEvent;
exports.FederatedMouseEvent = FederatedMouseEvent;
exports.FederatedPointerEvent = FederatedPointerEvent;
exports.FederatedWheelEvent = FederatedWheelEvent;
exports.Frustum = Frustum;
exports.Group = Group;
exports.HTML = HTML;
exports.Image = Image;
exports.Line = Line;
exports.LineUpdater = LineUpdater;
exports.MutationEvent = MutationEvent;
exports.Node = Node;
exports.OffscreenCanvasCreator = OffscreenCanvasCreator;
exports.Path = Path;
exports.PathUpdater = PathUpdater;
exports.Plane = Plane;
exports.Point = Point;
exports.Polygon = Polygon;
exports.Polyline = Polyline;
exports.PolylineUpdater = PolylineUpdater;
exports.Rect = Rect;
exports.RectUpdater = RectUpdater;
exports.Rectangle = Rectangle;
exports.RenderingService = RenderingService;
exports.Text = Text;
exports.TextService = TextService;
exports.TextUpdater = TextUpdater;
exports.computeLinearGradient = computeLinearGradient;
exports.computeRadialGradient = computeRadialGradient;
exports.convertToPath = convertToPath;
exports.createVec3 = createVec3;
exports.decompose = decompose;
exports.definedProps = definedProps;
exports.deg2rad = deg2rad;
exports.deg2turn = deg2turn;
exports.findClosestClipPathTarget = findClosestClipPathTarget;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.getAngle = getAngle;
exports.getEuler = getEuler;
exports.getOrCalculatePathTotalLength = getOrCalculatePathTotalLength;
exports.grad2deg = grad2deg;
exports.isBrowser = isBrowser;
exports.isCSSGradientValue = isCSSGradientValue;
exports.isCSSRGB = isCSSRGB;
exports.isCanvas = isCanvas;
exports.isDisplayObject = isDisplayObject;
exports.isFederatedEvent = isFederatedEvent;
exports.isFillOrStrokeAffected = isFillOrStrokeAffected;
exports.isPattern = isPattern;
exports.mergeColors = mergeColors;
exports.parseColor = parseColor;
exports.parseLength = parseLength;
exports.parsePath = parsePath;
exports.parseTransform = parseTransform;
exports.parsedTransformToMat4 = parsedTransformToMat4;
exports.propertyMetadataCache = propertyMetadataCache;
exports.rad2deg = rad2deg;
exports.resetEntityCounter = resetEntityCounter;
exports.runtime = runtime;
exports.setDOMSize = setDOMSize;
exports.translatePathToString = translatePathToString;
exports.turn2deg = turn2deg;
