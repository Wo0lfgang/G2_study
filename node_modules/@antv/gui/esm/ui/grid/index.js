import { __assign, __awaiter, __extends, __generator, __read, __rest, __spreadArray } from "tslib";
import { fadeOut } from '../../animation';
import { GUI } from '../../core/gui';
import { classNames, distance, getCallbackValue, select, transition } from '../../util';
var CLASS_NAMES = classNames({
    lineGroup: 'line-group',
    line: 'line',
    regionGroup: 'region-group',
    region: 'region',
}, 'grid');
function renderStraight(points) {
    return points.reduce(function (acc, curr, idx) { return "".concat(acc).concat(idx === 0 ? 'M' : ' L').concat(curr[0], ",").concat(curr[1]); }, '');
}
function renderSurround(points, cfg, reversed) {
    var _a = cfg.connect, connect = _a === void 0 ? 'line' : _a, center = cfg.center;
    if (connect === 'line')
        return renderStraight(points);
    if (!center)
        return '';
    var radius = distance(points[0], center);
    var sweepFlag = reversed ? 0 : 1;
    return points.reduce(function (r, _a, idx) {
        var _b = __read(_a, 2), p0 = _b[0], p1 = _b[1];
        if (idx === 0)
            return "M".concat(p0, ",").concat(p1);
        return "".concat(r, "A").concat(radius, ",").concat(radius, ",0,0,").concat(sweepFlag, ",").concat(p0, ",").concat(p1);
    }, '');
}
function getLinePath(points, cfg, reversed) {
    if (cfg.type === 'surround')
        return renderSurround(points, cfg, reversed);
    return renderStraight(points);
}
function connectPaths(from, to, cfg) {
    var type = cfg.type, connect = cfg.connect, center = cfg.center, closed = cfg.closed;
    var closeFlag = closed ? ' Z' : '';
    var _a = __read([getLinePath(from, cfg), getLinePath(to.slice().reverse(), cfg, true)], 2), path1 = _a[0], path2 = _a[1];
    var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
    var createPath = function (insertA, insertB) { return "".concat(path1, " ").concat(insertA, " ").concat(path2, " ").concat(insertB, " ").concat(closeFlag); };
    if (connect === 'line' || type === 'surround')
        return createPath("L".concat(endOfTo.join()), "L".concat(startOfFrom.join()));
    if (!center)
        throw new Error('Arc grid need to specified center');
    var _c = __read([distance(endOfTo, center), distance(startOfFrom, center)], 2), raduis1 = _c[0], radius2 = _c[1];
    return createPath("A".concat(raduis1, ",").concat(raduis1, ",0,0,1,").concat(endOfTo.join(' '), " L").concat(endOfTo.join()), "A".concat(radius2, ",").concat(radius2, ",0,0,0,").concat(startOfFrom.join(' ')));
}
function renderGridLine(container, items, cfg, style) {
    var animate = cfg.animate;
    var lines = items.map(function (item, idx) { return ({
        id: item.id || "grid-line-".concat(idx),
        path: getLinePath(item.points, cfg),
    }); });
    container
        .selectAll(CLASS_NAMES.line.class)
        .data(lines, function (d) { return d.id; })
        .join(function (enter) {
        return enter
            .append('path')
            .attr('className', CLASS_NAMES.line.name)
            .styles({
            stroke: '#D9D9D9',
            lineWidth: 1,
            lineDash: [4, 4],
        })
            .each(function (datum, index) {
            var lineStyle = getCallbackValue(__assign({ path: datum.path }, style), [datum, index, lines]);
            this.attr(lineStyle);
        });
    }, function (update) {
        return update.each(function (datum, index) {
            var lineStyle = getCallbackValue(__assign({ path: datum.path }, style), [datum, index, lines]);
            transition(this, lineStyle, animate.update);
        });
    }, function (exit) {
        return exit.each(function () {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, ((_a = fadeOut(this, animate.exit)) === null || _a === void 0 ? void 0 : _a.finished)];
                        case 1:
                            _b.sent();
                            this.remove();
                            return [2 /*return*/];
                    }
                });
            });
        });
    });
}
function renderAlternateRegion(container, items, cfg) {
    var animate = cfg.animate, type = cfg.type, center = cfg.center, connect = cfg.connect, areaFill = cfg.areaFill, closed = cfg.closed;
    if (items.length < 2 || !areaFill || !connect)
        return;
    var colors = Array.isArray(areaFill) ? areaFill : [areaFill, 'transparent'];
    var getColor = function (idx) { return colors[idx % colors.length]; };
    var regions = [];
    for (var idx = 0; idx < items.length - 1; idx++) {
        var _a = __read([items[idx].points, items[idx + 1].points], 2), prev = _a[0], curr = _a[1];
        var path = connectPaths(prev, curr, cfg);
        regions.push({ path: path, fill: getColor(idx) });
    }
    container
        .selectAll(CLASS_NAMES.region.class)
        .data(regions, function (_, i) { return i; })
        .join(function (enter) {
        return enter
            .append('path')
            .each(function (datum, index) {
            var regionStyle = getCallbackValue(datum, [datum, index, regions]);
            this.attr(regionStyle);
        })
            .attr('className', CLASS_NAMES.region.name);
    }, function (update) {
        return update.each(function (datum, index) {
            var regionStyle = getCallbackValue(datum, [datum, index, regions]);
            transition(this, regionStyle, animate.update);
        });
    }, function (exit) {
        return exit.each(function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fadeOut(this, animate.exit)];
                        case 1:
                            _a.sent();
                            this.remove();
                            return [2 /*return*/];
                    }
                });
            });
        });
    });
}
function dataFormatter(data, cfg) {
    var closed = cfg.closed;
    if (!closed)
        return data;
    return data.map(function (datum) {
        var points = datum.points;
        var _a = __read(points), start = _a[0], rest = _a.slice(1);
        return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start], false) });
    });
}
var Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    function Grid() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Grid.prototype.render = function (attributes, container) {
        // @ts-ignore do no passBy className
        var className = attributes.class, _a = attributes.items, items = _a === void 0 ? [] : _a, animate = attributes.animate, type = attributes.type, center = attributes.center, areaFill = attributes.areaFill, closed = attributes.closed, style = __rest(attributes, ["class", "items", "animate", "type", "center", "areaFill", "closed"]);
        var data = dataFormatter(items, attributes);
        var lineGroup = select(container).maybeAppendByClassName(CLASS_NAMES.lineGroup, 'g');
        var regionGroup = select(container).maybeAppendByClassName(CLASS_NAMES.regionGroup, 'g');
        renderGridLine(lineGroup, data, attributes, style);
        renderAlternateRegion(regionGroup, data, attributes);
    };
    return Grid;
}(GUI));
export { Grid };
//# sourceMappingURL=index.js.map