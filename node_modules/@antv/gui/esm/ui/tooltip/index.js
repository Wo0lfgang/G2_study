import { __assign, __decorate, __extends, __read, __rest } from "tslib";
import { deepMix, substitute, isString, isElement } from '@antv/util';
import { createDom } from '@antv/dom-util';
import { GUI } from '../../core/gui';
import { applyStyleSheet, parseHTML, throttle } from '../../util';
import { CLASS_NAME, TOOLTIP_STYLE } from './constant';
var Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    function Tooltip(options) {
        var _this = _super.call(this, deepMix({}, Tooltip.defaultOptions, options)) || this;
        _this.visibility = 'visible';
        _this.initShape();
        _this.render(_this.attributes, _this);
        return _this;
    }
    Object.defineProperty(Tooltip.prototype, "HTMLTooltipElement", {
        get: function () {
            return this.element;
        },
        enumerable: false,
        configurable: true
    });
    Tooltip.prototype.getContainer = function () {
        return this.element;
    };
    Object.defineProperty(Tooltip.prototype, "position", {
        set: function (_a) {
            var _b = __read(_a, 2), x = _b[0], y = _b[1];
            this.attr({ x: x, y: y });
            this.updatePosition();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "elementSize", {
        get: function () {
            var width = this.element.offsetWidth;
            var height = this.element.offsetHeight;
            return { width: width, height: height };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "items", {
        get: function () {
            var items = this.attributes.items;
            return items.map(function (_a, idx) {
                var _b = _a.name, name = _b === void 0 ? '' : _b, value = _a.value, _c = _a.color, color = _c === void 0 ? 'black' : _c, index = _a.index, rest = __rest(_a, ["name", "value", "color", "index"]);
                return __assign({ name: name, value: value, color: color, index: index !== null && index !== void 0 ? index : idx }, rest);
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "HTMLTooltipItemsElements", {
        get: function () {
            var template = this.attributes.template;
            var itemsHTML = [];
            this.items.forEach(function (item) {
                itemsHTML.push(createDom(substitute(template.item, item)));
            });
            return itemsHTML;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "customContent", {
        /**
         * 解析自定义内容
         */
        get: function () {
            var customContent = this.attributes.customContent;
            if (isString(customContent))
                return parseHTML(customContent);
            if (isElement(customContent))
                return customContent;
            return undefined;
        },
        enumerable: false,
        configurable: true
    });
    Tooltip.prototype.render = function (attributes, container) {
        this.renderHTMLTooltipElement();
        this.updatePosition();
    };
    Tooltip.prototype.update = function (cfg) {
        this.attr(deepMix({}, this.attributes, cfg));
        this.render(this.attributes, this);
    };
    Tooltip.prototype.clear = function () {
        // 清空容器内容
        this.element.innerHTML = '';
    };
    Tooltip.prototype.destroy = function () {
        var _a, _b;
        (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        (_b = this.customContent) === null || _b === void 0 ? void 0 : _b.remove();
    };
    Tooltip.prototype.show = function () {
        this.visibility = 'visible';
        this.element.style.visibility = 'visible';
    };
    Tooltip.prototype.hide = function () {
        this.visibility = 'hidden';
        this.element.style.visibility = 'hidden';
    };
    /**
     * 初始化容器
     */
    Tooltip.prototype.initShape = function () {
        var template = this.attributes.template;
        this.element = createDom(template.container);
        if (this.id)
            this.element.setAttribute('id', this.id);
    };
    /**
     * 更新 HTML 上的内容
     */
    Tooltip.prototype.renderHTMLTooltipElement = function () {
        var _a, _b;
        var _c = this.attributes, title = _c.title, enterable = _c.enterable;
        var container = this.element;
        var customContent = this.customContent;
        this.element.style.pointerEvents = enterable ? 'auto' : 'none';
        this.clear();
        if (customContent)
            container.appendChild(customContent);
        else {
            var template = this.attributes.template;
            if (title) {
                // 置入title
                container.innerHTML = template.title;
                // 更新标题
                container.getElementsByClassName(CLASS_NAME.TITLE)[0].innerHTML = title;
            }
            else
                (_b = (_a = container.getElementsByClassName(CLASS_NAME.TITLE)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.remove();
            var itemsHTML = this.HTMLTooltipItemsElements;
            var ul_1 = document.createElement('ul');
            ul_1.className = CLASS_NAME.LIST;
            itemsHTML.forEach(function (item) {
                ul_1.appendChild(item);
            });
            this.element.appendChild(ul_1);
        }
        // 应用样式表
        var style = this.attributes.style;
        applyStyleSheet(container, style);
        this.element.style.visibility = this.visibility;
    };
    /**
     * 根据 position 和指针位置，计算出 tooltip 相对于指针的偏移量
     * @param assignPosition {TooltipPosition} tooltip相对于指针的位置，不指定时使用默认参数
     */
    Tooltip.prototype.getRelativeOffsetFromCursor = function (assignPosition) {
        var _a = this.attributes, position = _a.position, offset = _a.offset;
        var positionName = (assignPosition || position).split('-');
        var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
        var _b = this.elementSize, width = _b.width, height = _b.height;
        var absolutelyOffset = [-width / 2, -height / 2];
        positionName.forEach(function (pos) {
            var _a = __read(absolutelyOffset, 2), abs1 = _a[0], abs2 = _a[1];
            var _b = __read(positionScore[pos], 2), pos1 = _b[0], pos2 = _b[1];
            absolutelyOffset = [abs1 + (width / 2 + offset[0]) * pos1, abs2 + (height / 2 + offset[1]) * pos2];
        });
        return absolutelyOffset;
    };
    /**
     * 将相对于指针的偏移量生效到dom元素上
     */
    Tooltip.prototype.setOffsetPosition = function (_a) {
        var _b = __read(_a, 2), offsetX = _b[0], offsetY = _b[1];
        var _c = this.attributes, _d = _c.x, x = _d === void 0 ? 0 : _d, _e = _c.y, y = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
        // // 设置属性
        this.element.style.left = "".concat(x + cx + offsetX, "px");
        this.element.style.top = "".concat(y + cy + offsetY, "px");
    };
    /**
     * 更新tooltip的位置
     */
    Tooltip.prototype.updatePosition = function () {
        // 尝试当前的位置使用默认position能否放下
        // 如果不能，则改变取溢出边的反向position
        /**
         * 默认位置
         *    ⬇️
         * 计算自动调整位置
         *    ⬇️
         * 实际摆放位置
         */
        this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
    };
    /**
     * 计算自动调整位置后的相对位置
     * @param offsetX 根据position计算的横向偏移量
     * @param offsetY 根据position计算的纵向偏移量
     */
    Tooltip.prototype.autoPosition = function (_a) {
        var _b = __read(_a, 2), offsetX = _b[0], offsetY = _b[1];
        var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, autoPosition = _c.autoPosition, bounding = _c.bounding;
        if (!autoPosition)
            return [offsetX, offsetY];
        // 更新前的位置和宽度
        var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
        // 预期放置的位置
        var _e = __read([cursorX + offsetX, cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
        var position = this.attributes.position;
        // 反方向
        var inversion = {
            left: 'right',
            right: 'left',
            top: 'bottom',
            bottom: 'top',
        };
        // 各个边界是否超出容器边界
        var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
        var edgeCompare = {
            left: expectLeft < boundingX,
            right: expectLeft + offsetWidth > boundingX + boundingWidth,
            top: expectTop < boundingY,
            bottom: expectTop + offsetHeight > boundingY + boundingHeight,
        };
        // 修正的位置
        var correctivePosition = [];
        // 判断是否超出边界
        position.split('-').forEach(function (pos) {
            // 如果在当前方向超出边界，则设置其反方向
            if (edgeCompare[pos])
                correctivePosition.push(inversion[pos]);
            else
                correctivePosition.push(pos);
        });
        var correctedPositionString = correctivePosition.join('-');
        return this.getRelativeOffsetFromCursor(correctedPositionString);
    };
    Tooltip.tag = 'tooltip';
    Tooltip.defaultOptions = {
        style: {
            x: 0,
            y: 0,
            visibility: 'visible',
            title: '',
            position: 'bottom-right',
            offset: [5, 5],
            follow: true,
            enterable: false,
            autoPosition: true,
            items: [],
            container: {
                x: 0,
                y: 0,
            },
            bounding: {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
            },
            template: {
                container: "<div class=\"".concat(CLASS_NAME.CONTAINER, "\"></div>"),
                title: "<div class=\"".concat(CLASS_NAME.TITLE, "\"></div>"),
                item: "<li class=\"".concat(CLASS_NAME.LIST_ITEM, "\" data-index={index}>\n        <span class=\"").concat(CLASS_NAME.NAME, "\">\n          <span class=\"").concat(CLASS_NAME.MARKER, "\" style=\"background:{color}\"></span>\n          <span class=\"").concat(CLASS_NAME.NAME_LABEL, "\" title=\"{name}\">{name}</span>\n        </span>\n        <span class=\"").concat(CLASS_NAME.VALUE, "\" title=\"{value}\">{value}</span>\n      </li>"),
            },
            style: TOOLTIP_STYLE,
        },
    };
    __decorate([
        throttle(100)
    ], Tooltip.prototype, "updatePosition", null);
    return Tooltip;
}(GUI));
export { Tooltip };
//# sourceMappingURL=index.js.map