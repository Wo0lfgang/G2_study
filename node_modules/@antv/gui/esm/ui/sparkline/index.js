import { __assign, __extends, __read } from "tslib";
import { clone, deepMix, isNumber, isArray, isFunction } from '@antv/util';
import { Linear, Band } from '@antv/scale';
import { GUI } from '../../core/gui';
import { maybeAppend, subObject } from '../../util';
import { Lines } from './lines';
import { Columns } from './columns';
import { getRange, getStackedData } from './utils';
import { dataToLines, lineToLinePath, lineToCurvePath, linesToAreaPaths, linesToStackAreaPaths, linesToStackCurveAreaPaths, } from './path';
var Sparkline = /** @class */ (function (_super) {
    __extends(Sparkline, _super);
    function Sparkline(options) {
        return _super.call(this, deepMix({}, Sparkline.defaultOptions, options)) || this;
    }
    Object.defineProperty(Sparkline.prototype, "rawData", {
        /**
         * 将data统一格式化为数组形式
         * 如果堆叠，则生成堆叠数据
         */
        get: function () {
            var rawData = this.attributes.data;
            if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
                return [[]];
            var data = clone(rawData);
            // number[] -> number[][]
            return isNumber(data[0]) ? [data] : data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sparkline.prototype, "data", {
        get: function () {
            if (this.attributes.isStack)
                return getStackedData(this.rawData);
            return this.rawData;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sparkline.prototype, "scales", {
        get: function () {
            return this.createScales(this.data);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sparkline.prototype, "baseline", {
        /**
         * 基准线，默认为 0
         */
        get: function () {
            var y = this.scales.y;
            var _a = __read(y.getOptions().domain || [0, 0], 2), y1 = _a[0], y2 = _a[1];
            if (y2 < 0) {
                return y.map(y2);
            }
            return y.map(y1 < 0 ? 0 : y1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sparkline.prototype, "containerCfg", {
        get: function () {
            var _a = this.attributes, width = _a.width, height = _a.height;
            return { width: width, height: height };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sparkline.prototype, "linesCfg", {
        get: function () {
            var _this = this;
            if (this.attributes.type !== 'line')
                throw new Error('linesCfg can only be used in line type');
            var _a = this.attributes, isStack = _a.isStack, smooth = _a.smooth;
            var areaStyle = subObject(this.attributes, 'area');
            var lineStyle = subObject(this.attributes, 'line');
            var width = this.containerCfg.width;
            var data = this.data;
            if (data[0].length === 0)
                return { lines: [], areas: [] };
            var _b = this.scales, x = _b.x, y = _b.y;
            // 线条Path
            var lines = dataToLines(data, { type: 'line', x: x, y: y });
            // 生成区域path
            var areas = [];
            if (areaStyle) {
                var baseline = this.baseline;
                if (isStack) {
                    areas = smooth
                        ? linesToStackCurveAreaPaths(lines, width, baseline)
                        : linesToStackAreaPaths(lines, width, baseline);
                }
                else {
                    areas = linesToAreaPaths(lines, smooth, width, baseline);
                }
            }
            return {
                lines: lines.map(function (line, idx) {
                    return __assign({ stroke: _this.getColor(idx), path: smooth ? lineToCurvePath(line) : lineToLinePath(line) }, lineStyle);
                }),
                areas: areas.map(function (path, idx) {
                    return __assign({ path: path, fill: _this.getColor(idx) }, areaStyle);
                }),
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sparkline.prototype, "columnsCfg", {
        get: function () {
            var _this = this;
            if (this.attributes.type !== 'column')
                throw new Error('columnsCfg can only be used in column type');
            var columnStyle = subObject(this.attributes, 'column');
            var isStack = this.attributes.isStack;
            var height = this.containerCfg.height;
            var data = this.rawData;
            if (!data)
                return { columns: [] };
            if (isStack)
                data = getStackedData(data);
            var _a = this.createScales(data), x = _a.x, y = _a.y;
            var _b = __read(getRange(data), 2), minVal = _b[0], maxVal = _b[1];
            var heightScale = new Linear({
                domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
                range: [0, height],
            });
            var bandWidth = x.getBandWidth();
            var rawData = this.rawData;
            return {
                columns: data.map(function (column, i) {
                    return column.map(function (val, j) {
                        var barWidth = bandWidth / data.length;
                        return __assign(__assign({ fill: _this.getColor(i) }, columnStyle), (isStack
                            ? {
                                x: x.map(j),
                                y: y.map(val),
                                width: bandWidth,
                                height: heightScale.map(rawData[i][j]),
                            }
                            : {
                                x: x.map(j) + barWidth * i,
                                y: val >= 0 ? y.map(val) : y.map(0),
                                width: barWidth,
                                height: heightScale.map(Math.abs(val)),
                            }));
                    });
                }),
            };
        },
        enumerable: false,
        configurable: true
    });
    Sparkline.prototype.render = function (attributes, container) {
        this.containerShape = maybeAppend(container, '.container', 'rect').attr('className', 'container').node();
        var type = attributes.type;
        var className = "spark".concat(type);
        var cfg = type === 'line' ? this.linesCfg : this.columnsCfg;
        this.sparkShape = maybeAppend(container, ".".concat(className), function () {
            if (type === 'line')
                return new Lines({ className: className, style: cfg });
            return new Columns({ className: className, style: cfg });
        })
            .styles(cfg)
            .node();
    };
    /**
     * 组件的更新
     */
    Sparkline.prototype.update = function (cfg) {
        this.attr(deepMix({}, this.attributes, cfg));
        this.render(this.attributes, this);
    };
    /**
     * 组件的清除
     */
    Sparkline.prototype.clear = function () {
        this.removeChild(this.sparkShape);
        this.sparkShape.clear();
        this.sparkShape.destroy();
    };
    /**
     * 根据数据索引获取color
     */
    Sparkline.prototype.getColor = function (index) {
        var color = this.attributes.color;
        if (isArray(color)) {
            return color[index % color.length];
        }
        if (isFunction(color)) {
            return color.call(null, index);
        }
        return color;
    };
    /**
     * 根据数据生成scale
     */
    Sparkline.prototype.createScales = function (data) {
        var _a, _b;
        var _c = this.attributes, type = _c.type, _d = _c.range, range = _d === void 0 ? [] : _d;
        var _e = this.containerCfg, width = _e.width, height = _e.height;
        var _f = __read(getRange(data), 2), minVal = _f[0], maxVal = _f[1];
        var yScale = new Linear({
            domain: [(_a = range[0]) !== null && _a !== void 0 ? _a : minVal, (_b = range[1]) !== null && _b !== void 0 ? _b : maxVal],
            range: [height, 0],
        });
        if (type === 'line') {
            return {
                type: type,
                x: new Linear({
                    domain: [0, data[0].length - 1],
                    range: [0, width],
                }),
                y: yScale,
            };
        }
        var _g = this.attributes, isGroup = _g.isGroup, spacing = _g.spacing;
        return {
            type: type,
            x: new Band({
                domain: data[0].map(function (val, idx) { return idx; }),
                range: [0, width],
                paddingInner: isGroup ? spacing : 0,
            }),
            y: yScale,
        };
    };
    Sparkline.tag = 'sparkline';
    Sparkline.defaultOptions = {
        style: {
            type: 'line',
            width: 200,
            height: 20,
            // data: [],
            isStack: false,
            nice: true,
            color: ['#83daad', '#edbf45', '#d2cef9', '#e290b3', '#6f63f4'],
            smooth: true,
            lineLineWidth: 1,
            areaOpacity: 0,
            isGroup: false,
            columnLineWidth: 1,
            columnStroke: '#fff',
            columnPadding: 0.1,
        },
    };
    return Sparkline;
}(GUI));
export { Sparkline };
//# sourceMappingURL=index.js.map