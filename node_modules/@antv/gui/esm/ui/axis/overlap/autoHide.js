import { __read, __spreadArray } from "tslib";
import { defined, getLocalBBox } from '../../../util';
import { intersect } from '../../../layout/intersect';
import { isAxisHorizontal, isAxisVertical } from '../guides/axisLine';
import { boundTest } from '../utils/helper';
var methods = {
    parity: function (items, _a) {
        var _b = _a.seq, seq = _b === void 0 ? 2 : _b;
        return items.filter(function (item, i) { return (i % seq ? ((item.style.visibility = 'hidden'), false) : true); });
    },
};
var filterDefined = function (arr) { return arr.filter(function (d) { return defined(d); }); };
export default function equidistance(labels, overlapCfg, cfg, utils) {
    var count = labels.length;
    var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
    if (count <= 1)
        return;
    if (count === 2 && keepHeader && keepTail)
        return;
    var parityHide = methods.parity;
    var reset = function (els) { return (els.forEach(utils.show), els); };
    var seq = 2;
    // 浅复制
    var source = labels.slice();
    var target = labels.slice();
    // Generally, 100 ticks cost less than 20ms. If cost time exceed, means ticks count is too large to see.
    var timeout = 200;
    var now = Date.now();
    var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function (d) { return d.getBBox().width; })), false));
    if (cfg.type === 'linear' && (isAxisHorizontal(cfg) || isAxisVertical(cfg))) {
        var minX = getLocalBBox(labels[0]).left;
        var maxX = getLocalBBox(labels[count - 1]).right;
        var distance = Math.abs(maxX - minX) || 1;
        seq = Math.max(Math.floor((count * minLabelWidth) / distance), seq);
    }
    var first;
    var last;
    if (keepHeader) {
        first = source.splice(0, 1)[0];
    }
    if (keepTail) {
        last = source.splice(-1, 1)[0];
        source.reverse();
    }
    while (boundTest(filterDefined(last ? __spreadArray(__spreadArray([last], __read(target), false), [first], false) : __spreadArray([first], __read(target), false)), overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
        // 每两步，减一个 (不需要考虑保留 first)
        if (last && !first && seq % 2 === 0) {
            var rest = source.splice(0, 1);
            rest.forEach(utils.hide);
        }
        else if (last && first) {
            // 如果有 first 的话，每一步，减一个（增加迭代次数）
            var rest = source.splice(0, 1);
            rest.forEach(utils.hide);
        }
        target = parityHide(reset(source), { seq: seq });
        seq++;
        // layout time exceeded;
        if (Date.now() - now > timeout)
            return;
    }
}
export function greedy(labels, overlapCfg) {
    var count = labels.length;
    if (count <= 1)
        return;
    var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
    if (count === 2 && keepHeader && keepTail)
        return;
    // 浅复制
    var source = labels.slice();
    var a;
    source.forEach(function (b, i) {
        if (!i || !a || !intersect(a, b, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin)) {
            a = b;
        }
        else if (i === count - 1 && keepTail) {
            a.style.visibility = 'hidden';
        }
        else {
            b.style.visibility = 'hidden';
        }
    });
}
//# sourceMappingURL=autoHide.js.map