import { __read } from "tslib";
import { isNil } from '@antv/util';
import { getFont, parseLength } from '../../../util';
import { boundTest } from '../utils/helper';
export default function ellipseLabels(labels, overlapCfg, cfg, utils) {
    if (labels.length <= 1)
        return;
    var _a = overlapCfg.suffix, suffix = _a === void 0 ? '...' : _a, minLength = overlapCfg.minLength, maxLength = overlapCfg.maxLength, ellipsisStep = overlapCfg.step, _b = overlapCfg.margin, margin = _b === void 0 ? [0, 0, 0, 0] : _b;
    var font = getFont(utils.getTextShape(labels[0]));
    var step = parseLength(ellipsisStep, font) || 1;
    var min = parseLength(minLength, font) || 1;
    var max = parseLength(maxLength, font);
    // Enable to ellipsis label when overlap.
    if (isNil(max) || max === Infinity) {
        max = Math.max.apply(null, labels.map(function (d) { return d.getBBox().width; }));
    }
    // Generally, 100 ticks cost less than 300ms. If cost time exceed, means ticks count is too large to see.
    var timeout = 300;
    var now = Date.now();
    var source = labels.slice();
    var _c = __read(margin, 4), _d = _c[0], top = _d === void 0 ? 0 : _d, _e = _c[1], right = _e === void 0 ? 0 : _e, _f = _c[2], bottom = _f === void 0 ? top : _f, _g = _c[3], left = _g === void 0 ? right : _g;
    var _loop_1 = function (allowedLength) {
        source.forEach(function (label) {
            utils.ellipsis(utils.getTextShape(label), allowedLength, suffix);
        });
        source = boundTest(labels, margin);
        // 碰撞检测
        if (source.length < 1)
            return { value: void 0 };
        // layout time exceeded;
        if (Date.now() - now > timeout)
            return { value: void 0 };
    };
    for (var allowedLength = max; allowedLength > min + step; allowedLength -= step) {
        var state_1 = _loop_1(allowedLength);
        if (typeof state_1 === "object")
            return state_1.value;
    }
}
//# sourceMappingURL=autoEllipsis.js.map