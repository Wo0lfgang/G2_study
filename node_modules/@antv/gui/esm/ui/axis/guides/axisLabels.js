import { __assign, __read, __rest, __spreadArray } from "tslib";
import { vec2 } from '@antv/matrix-util';
import { get, isFunction, memoize } from '@antv/util';
import { fadeOut, onAnimateFinished } from '../../../animation';
import { ellipsisIt, getCallbackValue, getTransform, inRange, percentTransform, radToDeg, renderExtDo, select, styleSeparator, transition, } from '../../../util';
import { CLASS_NAMES } from '../constant';
import { processOverlap } from '../overlap';
import { getFactor } from '../utils';
import { getDirectionVector, getLineTangentVector, getValuePos } from './axisLine';
import { filterExec, getCallbackStyle } from './utils';
var angleNormalizer = function (angle) {
    var normalizedAngle = angle;
    while (normalizedAngle < 0)
        normalizedAngle += 360;
    return normalizedAngle % 360;
};
var getAngle = memoize(function (v1, v2) {
    var _a = __read(v1, 2), x1 = _a[0], y1 = _a[1];
    var _b = __read(v2, 2), x2 = _b[0], y2 = _b[1];
    var _c = __read([x1 * x2 + y1 * y2, x1 * y2 - y1 * x2], 2), dot = _c[0], det = _c[1];
    return Math.atan2(det, dot);
}, function (v1, v2) { return __spreadArray(__spreadArray([], __read(v1), false), __read(v2), false).join(); });
function getLabelVector(value, cfg) {
    return getDirectionVector(value, cfg.labelDirection, cfg);
}
/** to correct label rotation to avoid inverted character */
function correctLabelRotation(_rotate) {
    var rotate = (_rotate + 360) % 180;
    if (!inRange(rotate, -90, 90))
        rotate += 180;
    return rotate;
}
/** get rotation from preset or layout */
function getLabelRotation(datum, label, cfg) {
    var labelAlign = cfg.labelAlign;
    var customRotate = getTransform(label, 'rotate');
    if (customRotate)
        return +customRotate % 180;
    var rotate = 0;
    var labelVector = getLabelVector(datum.value, cfg);
    var tangentVector = getLineTangentVector(datum.value, cfg);
    if (labelAlign === 'horizontal')
        return 0;
    if (labelAlign === 'perpendicular')
        rotate = getAngle([1, 0], labelVector);
    else
        rotate = getAngle([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
    return correctLabelRotation(radToDeg(rotate));
}
/** get the label align according to its tick and label angle  */
function getLabelAlign(value, rotate, cfg) {
    var type = cfg.type, labelAlign = cfg.labelAlign;
    var labelVector = getLabelVector(value, cfg);
    var labelAngle = angleNormalizer(rotate);
    var tickAngle = angleNormalizer(radToDeg(getAngle([1, 0], labelVector)));
    if ([90, 270].includes(tickAngle) && !labelAngle)
        return 'middle';
    if (!(tickAngle % 180) && [90, 270].includes(labelAngle))
        return 'middle';
    if (type === 'linear') {
        if (tickAngle === 0) {
            if (inRange(labelAngle, 0, 90, false, true))
                return 'start';
            if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360))
                return 'start';
        }
        if (tickAngle === 90) {
            if (inRange(labelAngle, 0, 90, false, true))
                return 'start';
            if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360))
                return 'end';
        }
        if (tickAngle === 270) {
            if (inRange(labelAngle, 0, 90, false, true))
                return 'end';
            if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360))
                return 'start';
        }
        if (tickAngle === 180) {
            if (labelAngle === 90)
                return 'start';
            if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360))
                return 'end';
        }
    }
    else {
        if (labelAlign === 'parallel')
            return 'middle';
        if (inRange(labelAngle, 90, 270)) {
            if (inRange(tickAngle, 90, 270))
                return 'start';
            return 'end';
        }
        if (inRange(tickAngle, 90, 270))
            return 'end';
        return 'start';
    }
    // TODO 笛卡尔坐标系倾斜状态布局
    return 'start';
    // const align = { '1': 'start', '-1': 'end' };
    // if (labelAlign === 'parallel') return 'middle';
    // if (Math.abs(tickVector[1]) === 1) {
    //   if (labelAlign === 'perpendicular') return tickVector[1] === unionFactor ? 'end' : 'start';
    //   else return 'middle';
    // }
    // if (tickVector[0] > 0) return align[unionFactor];
    // return align[-unionFactor as VerticalFactor];
}
function setRotateAndAdjustLabelAlign(rotate, group, cfg) {
    group.setLocalEulerAngles(+rotate);
    var value = group.__data__.value;
    var textAlign = getLabelAlign(value, rotate, cfg);
    var label = group.querySelector(CLASS_NAMES.labelItem.class);
    (label === null || label === void 0 ? void 0 : label.nodeName) === 'text' && select(label).style('textAlign', textAlign);
}
function getLabelPos(datum, index, data, cfg) {
    var showTick = cfg.showTick, tickLength = cfg.tickLength, tickDirection = cfg.tickDirection, labelDirection = cfg.labelDirection, labelSpacing = cfg.labelSpacing;
    var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index, data]);
    var _a = __read([getLabelVector(datum.value, cfg), getFactor(labelDirection, tickDirection)], 2), labelVector = _a[0], unionFactor = _a[1];
    var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index, data]) : 0;
    var _b = __read(vec2.add([0, 0], vec2.scale([0, 0], labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, cfg)), 2), x = _b[0], y = _b[1];
    return { x: x, y: y };
}
function formatter(datum, index, data, cfg) {
    var labelFormatter = cfg.labelFormatter;
    var element = isFunction(labelFormatter)
        ? function () { return renderExtDo(getCallbackValue(labelFormatter, [datum, index, data, getLabelVector(datum.value, cfg)])); }
        : function () { return renderExtDo(datum.label || ''); };
    return element;
}
function overlapHandler(cfg) {
    processOverlap(this.node().childNodes, cfg, {
        hide: function (label) {
            label.style.visibility = 'hidden';
        },
        show: function (label) {
            label.style.visibility = 'visible';
        },
        rotate: function (label, angle) {
            setRotateAndAdjustLabelAlign(+angle, label, cfg);
        },
        ellipsis: function (label, len, suffix) {
            if (len === void 0) { len = Infinity; }
            label && ellipsisIt(label, len, suffix);
        },
        getTextShape: function (label) { return label.querySelector('text'); },
    });
}
function createLabel(datum, index, data, cfg, style, animate) {
    var _this = this;
    // 1. set style
    // 2. set position
    // 3. set rotation
    // 4. set label align
    var label = select(this).append(datum.element).attr('className', CLASS_NAMES.labelItem.name).node();
    var _a = __read(styleSeparator(getCallbackStyle(style, [datum, index, data])), 2), labelStyle = _a[0], _b = _a[1], transform = _b.transform, groupStyle = __rest(_b, ["transform"]);
    (label === null || label === void 0 ? void 0 : label.nodeName) === 'text' &&
        label.attr(__assign({ fontSize: 12, fontFamily: 'sans-serif', fontWeight: 'normal', textAlign: 'center', textBaseline: 'middle' }, labelStyle));
    this.attr(groupStyle);
    var animation = transition(this, getLabelPos(datum, index, data, cfg), animate);
    var layout = function () {
        percentTransform(_this, transform);
        var rotate = getLabelRotation(datum, _this, cfg);
        setRotateAndAdjustLabelAlign(rotate, _this, cfg);
    };
    onAnimateFinished(animation, layout);
    return animation;
}
function createLabels(container, element, data, cfg, style, animate) {
    var elements = get(element, '_elements');
    if (elements.length === 0)
        return null;
    var transitions = get(element, '_transitions');
    var animations = elements.map(function (el) { return createLabel.call(el, el.__data__, 0, data, cfg, style, animate); });
    animations.forEach(function (a, i) { return (transitions[i] = a); });
    // to avoid async manipulations
    if (animations.filter(function (a) { return !!a; }).length === 0)
        overlapHandler.call(container, cfg);
    else {
        Promise.all(animations).then(function () {
            overlapHandler.call(container, cfg);
        });
    }
    return animations;
}
export function renderLabels(container, data, cfg, style, animate) {
    var finalData = filterExec(data, cfg.labelFilter).map(function (datum, index, arr) { return (__assign({ element: formatter(datum, index, arr, cfg) }, datum)); });
    return container
        .selectAll(CLASS_NAMES.label.class)
        .data(finalData, function (d, i) { return "".concat(d.value, "-").concat(d.label); })
        .join(function (enter) {
        return enter
            .append('g')
            .attr('className', CLASS_NAMES.label.name)
            .call(function (element) {
            createLabels(container, element, finalData, cfg, style, false);
        });
    }, function (update) {
        return update
            .each(function () {
            select(this).node().removeChildren();
        })
            .call(function (element) {
            createLabels(container, element, finalData, cfg, style, animate.update);
        });
    }, function (exit) {
        return exit.transition(function () {
            var _this = this;
            var animation = fadeOut(this, animate.exit);
            onAnimateFinished(animation, function () {
                select(_this).remove();
            });
            return animation;
        });
    })
        .transitions();
}
//# sourceMappingURL=axisLabels.js.map