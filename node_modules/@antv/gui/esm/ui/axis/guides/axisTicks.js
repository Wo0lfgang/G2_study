import { __assign, __read, __spreadArray } from "tslib";
import { DisplayObject } from '@antv/g';
import { isFunction, memoize } from '@antv/util';
import { fadeOut, onAnimateFinished } from '../../../animation';
import { getCallbackValue, select, styleSeparator, transition } from '../../../util';
import { CLASS_NAMES } from '../constant';
import { getDirectionVector, getValuePos } from './axisLine';
import { filterExec, getCallbackStyle } from './utils';
export function getTickVector(value, cfg) {
    return getDirectionVector(value, cfg.tickDirection, cfg);
}
export var getTickPoints = memoize(function (unitVector, tickLength) {
    var _a = __read(unitVector, 2), dx = _a[0], dy = _a[1];
    return [
        [0, 0],
        [dx * tickLength, dy * tickLength],
    ];
}, function (unitVector, tickLength) { return __spreadArray(__spreadArray([], __read(unitVector), false), [tickLength], false).join(); });
function getTickLineLayout(datum, index, data, tickVector, cfg) {
    var tickLength = cfg.tickLength;
    var _a = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index, data])), 2), _b = __read(_a[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a[1], 2), x2 = _c[0], y2 = _c[1];
    return { x1: x1, x2: x2, y1: y1, y2: y2 };
}
function createTickEl(container, datum, index, data, cfg) {
    var formatter = cfg.tickFormatter;
    var tickVector = getTickVector(datum.value, cfg);
    var el = 'line';
    if (formatter instanceof DisplayObject)
        el = function () { return formatter; };
    else if (isFunction(formatter))
        el = function () { return getCallbackValue(formatter, [datum, index, data, tickVector]); };
    return container.append(el).attr('className', CLASS_NAMES.tickItem.name);
}
function applyTickStyle(datum, index, data, tick, group, cfg, style) {
    var tickVector = getTickVector(datum.value, cfg);
    var _a = getTickLineLayout(datum, index, data, tickVector, cfg), x1 = _a.x1, x2 = _a.x2, y1 = _a.y1, y2 = _a.y2;
    var _b = __read(styleSeparator(getCallbackStyle(style, [datum, index, data])), 2), tickStyle = _b[0], groupStyle = _b[1];
    tick.node().nodeName === 'line' && tick.styles(__assign({ x1: x1, x2: x2, y1: y1, y2: y2 }, tickStyle));
    group.attr(groupStyle);
    tick.styles(tickStyle);
}
function createTick(datum, index, data, cfg, style, animate) {
    var tick = createTickEl(select(this), datum, index, data, cfg);
    applyTickStyle(datum, index, data, tick, this, cfg, style);
    var _a = __read(getValuePos(datum.value, cfg), 2), x = _a[0], y = _a[1];
    return transition(this, { x: x, y: y }, animate);
}
export function renderTicks(container, axisData, cfg, callbackableStyle, animate) {
    var finalData = filterExec(axisData, cfg.tickFilter);
    return container
        .selectAll(CLASS_NAMES.tick.class)
        .data(finalData, function (d) { return d.id || d.label; })
        .join(function (enter) {
        return enter
            .append('g')
            .attr('className', CLASS_NAMES.tick.name)
            .transition(function (datum, index) {
            return createTick.call(this, datum, index, finalData, cfg, callbackableStyle, false);
        });
    }, function (update) {
        return update.transition(function (datum, index) {
            this.removeChildren();
            return createTick.call(this, datum, index, finalData, cfg, callbackableStyle, animate.update);
        });
    }, function (exit) {
        return exit.transition(function () {
            var _this = this;
            var animation = fadeOut(this, animate.exit);
            onAnimateFinished(animation, function () { return _this.remove(); });
            return animation;
        });
    })
        .transitions();
}
//# sourceMappingURL=axisTicks.js.map