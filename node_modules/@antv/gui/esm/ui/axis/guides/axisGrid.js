import { __assign, __read } from "tslib";
import { vec2 } from '@antv/matrix-util';
import { isFunction } from '@antv/util';
import { degToRad, getCallbackValue } from '../../../util';
import { Grid } from '../../grid';
import { CLASS_NAMES } from '../constant';
import { getDirectionVector, getValuePos } from './axisLine';
import { filterExec } from './utils';
function getGridVector(value, cfg) {
    return getDirectionVector(value, cfg.gridDirection, cfg);
}
function getGridCenter(cfg) {
    var type = cfg.type, gridCenter = cfg.gridCenter;
    if (type === 'linear')
        return gridCenter;
    return gridCenter || cfg.center;
}
function renderStraight(data, cfg) {
    var _a = cfg.gridLength, gridLength = _a === void 0 ? 0 : _a;
    return data.map(function (_a) {
        var value = _a.value;
        var _b = __read(getValuePos(value, cfg), 2), x = _b[0], y = _b[1];
        var _c = __read(vec2.scale([0, 0], getGridVector(value, cfg), gridLength), 2), dx = _c[0], dy = _c[1];
        return {
            points: [
                [x, y],
                [x + dx, y + dy],
            ],
        };
    });
}
function renderSurround(data, cfg, style) {
    var controlAngles = style.controlAngles;
    var center = getGridCenter(cfg);
    if (!center)
        throw new Error('grid center is not provide');
    if (data.length < 2)
        throw new Error('Invalid grid data');
    if (!controlAngles || controlAngles.length === 0)
        throw new Error('Invalid gridControlAngles');
    var _a = __read(center, 2), cx = _a[0], cy = _a[1];
    return data.map(function (_a) {
        var value = _a.value;
        var _b = __read(getValuePos(value, cfg), 2), sx = _b[0], sy = _b[1];
        var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
        var points = [];
        controlAngles.forEach(function (angle) {
            var angleInRad = degToRad(angle);
            var _a = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a[0], sina = _a[1];
            var x = dx * cosa - dy * sina + cx;
            var y = dx * sina + dy * cosa + cy;
            points.push([x, y]);
        });
        return { points: points };
    });
}
export function renderGrid(container, data, cfg, style, animate) {
    var type = style.type, closed = style.closed, areaFill = style.areaFill, connect = style.connect;
    var center = getGridCenter(cfg);
    var finalData = filterExec(data, cfg.gridFilter);
    var gridItems = type === 'segment' ? renderStraight(finalData, cfg) : renderSurround(finalData, cfg, style);
    container
        .maybeAppendByClassName(CLASS_NAMES.grid, function () { return new Grid({}); })
        .update(__assign(__assign({ type: type, animate: animate, connect: connect, closed: closed, center: center }, style), { items: gridItems, areaFill: isFunction(areaFill)
            ? finalData.map(function (datum, index) { return getCallbackValue(areaFill, [datum, index, finalData]); })
            : areaFill }));
}
//# sourceMappingURL=axisGrid.js.map