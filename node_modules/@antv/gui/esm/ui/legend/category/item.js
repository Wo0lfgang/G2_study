import { __assign, __extends, __read } from "tslib";
import { Circle, } from '@antv/g';
import { isNumber, isString } from '@antv/util';
import { GUI } from '../../../core/gui';
import { classNames, deepAssign, ellipsisIt, ifShow, normalSeriesAttr, renderExtDo, scaleToPixel, select, subObject, } from '../../../util';
var CLASS_NAMES = classNames({
    layout: 'flex',
    markerGroup: 'marker-group',
    marker: 'marker',
    labelGroup: 'label-group',
    label: 'label',
    valueGroup: 'value-group',
    value: 'value',
    backgroundGroup: 'background-group',
    background: 'background',
}, 'legend-category-item');
var DEFAULT_ITEM_CFG = {
    span: [1, 1],
    marker: function () { return new Circle({ style: { r: 6 } }); },
    markerSize: 10,
    labelFill: '#646464',
    valueFill: '#646464',
    labelFontSize: 12,
    valueFontSize: 12,
    labelFontFamily: 'sans-serif',
    valueFontFamily: 'sans-serif',
    labelTextAlign: 'start',
    valueTextAlign: 'start',
    labelTextBaseline: 'middle',
    valueTextBaseline: 'middle',
};
var CategoryItem = /** @class */ (function (_super) {
    __extends(CategoryItem, _super);
    function CategoryItem(config) {
        return _super.call(this, deepAssign({}, { style: DEFAULT_ITEM_CFG }, config)) || this;
    }
    Object.defineProperty(CategoryItem.prototype, "showValue", {
        get: function () {
            var value = this.attributes.value;
            if (!value)
                return false;
            if (isString(value) || isNumber(value))
                return value !== '';
            return value.attr('text') !== '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "actualSpace", {
        get: function () {
            var label = this.labelGroup;
            var value = this.valueGroup;
            var _a = this.attributes.markerSize, markerSize = _a === void 0 ? 0 : _a;
            var _b = label.node().getBBox(), labelWidth = _b.width, labelHeight = _b.height;
            var _c = value.node().getBBox(), valueWidth = _c.width, valueHeight = _c.height;
            return {
                markerWidth: markerSize,
                labelWidth: labelWidth,
                valueWidth: valueWidth,
                height: Math.max(markerSize, labelHeight, valueHeight),
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "span", {
        get: function () {
            var attributes = this.attributes;
            if (!('span' in attributes))
                return [1, 1];
            var span = attributes.span;
            var _a = __read(normalSeriesAttr(span), 2), span1 = _a[0], innerSpan = _a[1];
            var span2 = this.showValue ? innerSpan : 0;
            var basis = span1 + span2;
            return [span1 / basis, span2 / basis];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "shape", {
        get: function () {
            var _a;
            var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
            var actualSpace = this.actualSpace;
            var markerWidth = actualSpace.markerWidth, height = actualSpace.height;
            var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
            var _d = __read(this.spacing, 2), spacing1 = _d[0], spacing2 = _d[1];
            if (fullWidth) {
                var width_1 = fullWidth - markerSize - spacing1 - spacing2;
                var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
                _a = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a[0], valueWidth = _a[1];
            }
            var width = markerWidth + labelWidth + valueWidth + spacing1 + spacing2;
            return { width: width, height: height, markerWidth: markerWidth, labelWidth: labelWidth, valueWidth: valueWidth };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "spacing", {
        get: function () {
            var spacing = this.attributes.spacing;
            if (!spacing)
                return [0, 0];
            var _a = __read(normalSeriesAttr(spacing), 2), spacing1 = _a[0], spacing2 = _a[1];
            if (this.showValue)
                return [spacing1, spacing2];
            return [spacing1, 0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "layout", {
        get: function () {
            var _a = this.shape, markerWidth = _a.markerWidth, labelWidth = _a.labelWidth, valueWidth = _a.valueWidth, width = _a.width, height = _a.height;
            var _b = __read(this.spacing, 2), spacing1 = _b[0], spacing2 = _b[1];
            return {
                height: height,
                width: width,
                markerWidth: markerWidth,
                labelWidth: labelWidth,
                valueWidth: valueWidth,
                position: [markerWidth / 2, markerWidth + spacing1, markerWidth + labelWidth + spacing1 + spacing2],
            };
        },
        enumerable: false,
        configurable: true
    });
    CategoryItem.prototype.renderMarker = function (container) {
        var _this = this;
        var _a = this.attributes, marker = _a.marker, markerSize = _a.markerSize;
        var style = subObject(this.attributes, 'marker');
        this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES.markerGroup, 'g');
        ifShow(!!marker, this.markerGroup, function () {
            _this.markerGroup.maybeAppendByClassName(CLASS_NAMES.marker, marker).styles(style);
            scaleToPixel(_this.markerGroup.node(), markerSize, true);
        });
    };
    CategoryItem.prototype.renderLabel = function (container) {
        var label = this.attributes.label;
        var style = subObject(this.attributes, 'label');
        this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES.labelGroup, 'g');
        this.labelGroup.maybeAppendByClassName(CLASS_NAMES.label, function () { return renderExtDo(label); }).styles(style);
    };
    CategoryItem.prototype.renderValue = function (container) {
        var _this = this;
        var value = this.attributes.value;
        var style = subObject(this.attributes, 'value');
        this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES.valueGroup, 'g');
        ifShow(this.showValue, this.valueGroup, function () {
            _this.valueGroup.maybeAppendByClassName(CLASS_NAMES.value, function () { return renderExtDo(value); }).styles(style);
        });
    };
    CategoryItem.prototype.renderBackground = function (container) {
        var _a = this.shape, width = _a.width, height = _a.height;
        var style = subObject(this.attributes, 'background');
        this.background = container.maybeAppendByClassName(CLASS_NAMES.backgroundGroup, 'g').style('zIndex', -1);
        this.background.maybeAppendByClassName(CLASS_NAMES.background, 'rect').styles(__assign({ width: width, height: height }, style));
    };
    CategoryItem.prototype.adjustLayout = function () {
        var _a = this.layout, markerWidth = _a.markerWidth, labelWidth = _a.labelWidth, valueWidth = _a.valueWidth, width = _a.width, height = _a.height, _b = __read(_a.position, 3), markerX = _b[0], labelX = _b[1], valueX = _b[2];
        var halfHeight = height / 2;
        this.markerGroup.styles({ x: markerX, y: halfHeight });
        this.labelGroup.styles({ x: labelX, y: halfHeight });
        ellipsisIt(this.labelGroup.select(CLASS_NAMES.label.class), labelWidth);
        if (this.showValue) {
            this.valueGroup.styles({ x: valueX, y: halfHeight });
            ellipsisIt(this.valueGroup.select(CLASS_NAMES.value.class), valueWidth);
        }
    };
    CategoryItem.prototype.render = function (attributes, container) {
        var ctn = select(container);
        this.renderMarker(ctn);
        this.renderLabel(ctn);
        this.renderValue(ctn);
        this.renderBackground(ctn);
        this.adjustLayout();
    };
    return CategoryItem;
}(GUI));
export { CategoryItem };
//# sourceMappingURL=item.js.map