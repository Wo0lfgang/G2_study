import { __assign, __read } from "tslib";
import { parseColor } from '@antv/g';
import { isFunction } from '@antv/util';
import { classNames, createComponent, select, subObjects } from '../../../util';
import { ifHorizontal } from '../utils';
import { getBlockColor } from './utils';
var CLASS_NAMES = classNames({
    trackGroup: 'background-group',
    track: 'background',
    selectionGroup: 'ribbon-group',
    selection: 'ribbon',
    clipPath: 'clip-path',
}, 'ribbon');
var DEFAULT_RIBBON_CFG = {
    type: 'color',
    orient: 'horizontal',
    size: 30,
    range: [0, 1],
    len: 200,
    block: false,
    partition: [],
    color: ['#fff', '#000'],
    trackFill: '#e5e5e5',
};
function getShape(cfg) {
    var orient = cfg.orient, size = cfg.size, len = cfg.len;
    return ifHorizontal(orient, [len, size], [size, len]);
}
function getTrackPath(cfg) {
    var type = cfg.type;
    var _a = __read(getShape(cfg), 2), cw = _a[0], ch = _a[1];
    if (type === 'size') {
        return [['M', 0, ch], ['L', 0 + cw, 0], ['L', 0 + cw, ch], ['Z']];
    }
    return [['M', 0, ch], ['L', 0, 0], ['L', 0 + cw, 0], ['L', 0 + cw, ch], ['Z']];
}
function getSelectionPath(cfg) {
    return getTrackPath(cfg);
}
function getColor(cfg) {
    var _a = cfg, orient = _a.orient, color = _a.color, block = _a.block, partition = _a.partition;
    var colors;
    if (isFunction(color)) {
        var len = 20;
        colors = new Array(len).fill(0).map(function (_, index, arr) { return color(index / (arr.length - 1)); });
    }
    else
        colors = color;
    var count = colors.length;
    var genericColor = colors.map(function (c) { return parseColor(c).toString(); });
    if (!count)
        return '';
    if (count === 1)
        return genericColor[0];
    if (block)
        return getBlockColor(partition, genericColor, orient);
    return genericColor.reduce(function (r, c, idx) { return (r += " ".concat(idx / (count - 1), ":").concat(c)); }, "l(".concat(ifHorizontal(orient, '0', '270'), ")"));
}
function getClipPath(cfg) {
    var orient = cfg.orient, range = cfg.range;
    if (!range)
        return [];
    var _a = __read(getShape(cfg), 2), width = _a[0], height = _a[1];
    var _b = __read(range, 2), st = _b[0], et = _b[1];
    var x = ifHorizontal(orient, st * width, 0);
    var y = ifHorizontal(orient, 0, st * height);
    var w = ifHorizontal(orient, et * width, width);
    var h = ifHorizontal(orient, height, et * height);
    return [['M', x, y], ['L', x, h], ['L', w, h], ['L', w, y], ['Z']];
}
function renderTrack(container, cfg, style) {
    container.maybeAppendByClassName(CLASS_NAMES.track, 'path').styles(__assign({ path: getTrackPath(cfg) }, style));
}
function renderSelection(container, cfg, style) {
    var fill = getColor(cfg);
    var ribbon = container
        .maybeAppendByClassName(CLASS_NAMES.selection, 'path')
        .styles(__assign({ path: getSelectionPath(cfg), fill: fill }, style));
    var clipPath = ribbon
        .maybeAppendByClassName(CLASS_NAMES.clipPath, 'path')
        .styles({ path: getClipPath(cfg) })
        .node();
    ribbon.style('clip-path', clipPath);
}
export var Ribbon = createComponent({
    render: function (attribute, container) {
        var _a = __read(subObjects(attribute, ['selection', 'track']), 2), selectionStyle = _a[0], trackStyle = _a[1];
        var trackGroup = select(container).maybeAppendByClassName(CLASS_NAMES.trackGroup, 'g');
        renderTrack(trackGroup, attribute, trackStyle);
        /**
         * - ribbon group
         *  |- ribbon
         * - clip path
         */
        var ribbonGroup = select(container).maybeAppendByClassName(CLASS_NAMES.selectionGroup, 'g');
        renderSelection(ribbonGroup, attribute, selectionStyle);
    },
}, __assign({}, DEFAULT_RIBBON_CFG));
//# sourceMappingURL=ribbon.js.map