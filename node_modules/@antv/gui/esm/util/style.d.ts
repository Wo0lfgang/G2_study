import type { TextStyleProps } from '@antv/g';
import type { MixAttrs, StyleState } from '../types';
/**
 * 以下属性都是可继承的，这意味着没有显式定义（值为 unset）时，是需要从未来的祖先节点中计算得到的。
 * 因此 Text 在创建之后立刻调用 getBounds 等方法获取包围盒是不准确的（例如 getShapeSpace 方法）。
 *
 * 目前 GUI 里这么做通常是为了布局。但理想的做法是使用布局属性（例如 BoxFlow 中的 margin / padding，Flex 布局的 flex 等），
 * 正如在浏览器中我们很少使用 getBoundingClientRect 而更多使用 `display: block/flex/grids`，
 * 这样可以避免手动计算（如何计算以及计算时机只有 浏览器/G 最清楚）。
 *
 * 暂时在布局实现前，先通过显式定义的值绕开该问题，当然这也放弃了继承特性（例如根节点上的 fontSize 修改也影响不到了）。
 *
 * 继承机制 & 默认值 @see https://g-next.antv.vision/zh/docs/api/css/inheritance
 */
export declare const TEXT_INHERITABLE_PROPS: Pick<TextStyleProps, 'fontSize' | 'fontFamily' | 'fontWeight' | 'fontVariant' | 'fontStyle' | 'textAlign' | 'textBaseline'>;
/**
 * 从带状态样式中返回移除了状态样式的默认样式
 */
export declare function getDefaultStyle<T>(style: MixAttrs<T> | undefined): T | undefined;
/**
 * 对于格式为:
 * style: ShapeAttrs & {
 *  [state: string]?: ShapeAttrs,
 * }
 * 的带状态样式，根据状态提取出样式
 * 默认返回默认样式
 * @param style 混合样式
 * @param state 状态
 * @param isMerge 是否将状态样式与默认样式合并
 */
export declare function getStateStyle<T>(style?: MixAttrs<T>, state?: StyleState, isMerge?: boolean): Partial<T>;
/**
 * 对给定HTML对象应用给定样式
 * @param style {[key: string]: Object}
 * 样式表参考结构
 * {
 *  '.selector': {
 *   'attrName': 'attr',
 *   'padding': '0 0 0 0',
 *   'background-color': 'red'
 *  }
 * }
 */
export declare function applyStyleSheet(element: HTMLElement, style: {
    [key: string]: Object;
}): void;
/**
 *
 * @param style
 * @param prefix
 * @param invert get the reset style
 * @param transform enable filter transform
 * @returns
 */
export declare function subObject(style: {
    [keys: string]: any;
}, prefix: string, invert?: boolean, transform?: boolean): {
    [keys: string]: any;
};
export declare function subObjects(style: any, prefix: string[]): any[];
/**
 * add prefix to style
 * @param style
 * @param prefix
 */
export declare function superObject(style: any, prefix: string): any;
/**
 * extract group style from mixin style
 * @param style
 * @param ignoreStyleDict style will be ignore from style
 * @returns shape style and rest style
 */
export declare function styleSeparator(style: {
    [keys: string]: any;
}, ignoreStyleDict?: string[]): {
    [keys: string]: any;
}[];
