"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderLabels = void 0;
var tslib_1 = require("tslib");
var matrix_util_1 = require("@antv/matrix-util");
var util_1 = require("@antv/util");
var animation_1 = require("../../../animation");
var util_2 = require("../../../util");
var constant_1 = require("../constant");
var overlap_1 = require("../overlap");
var utils_1 = require("../utils");
var axisLine_1 = require("./axisLine");
var utils_2 = require("./utils");
var angleNormalizer = function (angle) {
    var normalizedAngle = angle;
    while (normalizedAngle < 0)
        normalizedAngle += 360;
    return normalizedAngle % 360;
};
var getAngle = (0, util_1.memoize)(function (v1, v2) {
    var _a = tslib_1.__read(v1, 2), x1 = _a[0], y1 = _a[1];
    var _b = tslib_1.__read(v2, 2), x2 = _b[0], y2 = _b[1];
    var _c = tslib_1.__read([x1 * x2 + y1 * y2, x1 * y2 - y1 * x2], 2), dot = _c[0], det = _c[1];
    return Math.atan2(det, dot);
}, function (v1, v2) { return tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(v1), false), tslib_1.__read(v2), false).join(); });
function getLabelVector(value, cfg) {
    return (0, axisLine_1.getDirectionVector)(value, cfg.labelDirection, cfg);
}
/** to correct label rotation to avoid inverted character */
function correctLabelRotation(_rotate) {
    var rotate = (_rotate + 360) % 180;
    if (!(0, util_2.inRange)(rotate, -90, 90))
        rotate += 180;
    return rotate;
}
/** get rotation from preset or layout */
function getLabelRotation(datum, label, cfg) {
    var labelAlign = cfg.labelAlign;
    var customRotate = (0, util_2.getTransform)(label, 'rotate');
    if (customRotate)
        return +customRotate % 180;
    var rotate = 0;
    var labelVector = getLabelVector(datum.value, cfg);
    var tangentVector = (0, axisLine_1.getLineTangentVector)(datum.value, cfg);
    if (labelAlign === 'horizontal')
        return 0;
    if (labelAlign === 'perpendicular')
        rotate = getAngle([1, 0], labelVector);
    else
        rotate = getAngle([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
    return correctLabelRotation((0, util_2.radToDeg)(rotate));
}
/** get the label align according to its tick and label angle  */
function getLabelAlign(value, rotate, cfg) {
    var type = cfg.type, labelAlign = cfg.labelAlign;
    var labelVector = getLabelVector(value, cfg);
    var labelAngle = angleNormalizer(rotate);
    var tickAngle = angleNormalizer((0, util_2.radToDeg)(getAngle([1, 0], labelVector)));
    if ([90, 270].includes(tickAngle) && !labelAngle)
        return 'middle';
    if (!(tickAngle % 180) && [90, 270].includes(labelAngle))
        return 'middle';
    if (type === 'linear') {
        if (tickAngle === 0) {
            if ((0, util_2.inRange)(labelAngle, 0, 90, false, true))
                return 'start';
            if ((0, util_2.inRange)(labelAngle, 0, 90) || (0, util_2.inRange)(labelAngle, 270, 360))
                return 'start';
        }
        if (tickAngle === 90) {
            if ((0, util_2.inRange)(labelAngle, 0, 90, false, true))
                return 'start';
            if ((0, util_2.inRange)(labelAngle, 90, 180) || (0, util_2.inRange)(labelAngle, 270, 360))
                return 'end';
        }
        if (tickAngle === 270) {
            if ((0, util_2.inRange)(labelAngle, 0, 90, false, true))
                return 'end';
            if ((0, util_2.inRange)(labelAngle, 90, 180) || (0, util_2.inRange)(labelAngle, 270, 360))
                return 'start';
        }
        if (tickAngle === 180) {
            if (labelAngle === 90)
                return 'start';
            if ((0, util_2.inRange)(labelAngle, 0, 90) || (0, util_2.inRange)(labelAngle, 270, 360))
                return 'end';
        }
    }
    else {
        if (labelAlign === 'parallel')
            return 'middle';
        if ((0, util_2.inRange)(labelAngle, 90, 270)) {
            if ((0, util_2.inRange)(tickAngle, 90, 270))
                return 'start';
            return 'end';
        }
        if ((0, util_2.inRange)(tickAngle, 90, 270))
            return 'end';
        return 'start';
    }
    // TODO 笛卡尔坐标系倾斜状态布局
    return 'start';
    // const align = { '1': 'start', '-1': 'end' };
    // if (labelAlign === 'parallel') return 'middle';
    // if (Math.abs(tickVector[1]) === 1) {
    //   if (labelAlign === 'perpendicular') return tickVector[1] === unionFactor ? 'end' : 'start';
    //   else return 'middle';
    // }
    // if (tickVector[0] > 0) return align[unionFactor];
    // return align[-unionFactor as VerticalFactor];
}
function setRotateAndAdjustLabelAlign(rotate, group, cfg) {
    group.setLocalEulerAngles(+rotate);
    var value = group.__data__.value;
    var textAlign = getLabelAlign(value, rotate, cfg);
    var label = group.querySelector(constant_1.CLASS_NAMES.labelItem.class);
    (label === null || label === void 0 ? void 0 : label.nodeName) === 'text' && (0, util_2.select)(label).style('textAlign', textAlign);
}
function getLabelPos(datum, index, data, cfg) {
    var showTick = cfg.showTick, tickLength = cfg.tickLength, tickDirection = cfg.tickDirection, labelDirection = cfg.labelDirection, labelSpacing = cfg.labelSpacing;
    var finalLabelSpacing = (0, util_2.getCallbackValue)(labelSpacing, [datum, index, data]);
    var _a = tslib_1.__read([getLabelVector(datum.value, cfg), (0, utils_1.getFactor)(labelDirection, tickDirection)], 2), labelVector = _a[0], unionFactor = _a[1];
    var extraLength = unionFactor === 1 ? (0, util_2.getCallbackValue)(showTick ? tickLength : 0, [datum, index, data]) : 0;
    var _b = tslib_1.__read(matrix_util_1.vec2.add([0, 0], matrix_util_1.vec2.scale([0, 0], labelVector, finalLabelSpacing + extraLength), (0, axisLine_1.getValuePos)(datum.value, cfg)), 2), x = _b[0], y = _b[1];
    return { x: x, y: y };
}
function formatter(datum, index, data, cfg) {
    var labelFormatter = cfg.labelFormatter;
    var element = (0, util_1.isFunction)(labelFormatter)
        ? function () { return (0, util_2.renderExtDo)((0, util_2.getCallbackValue)(labelFormatter, [datum, index, data, getLabelVector(datum.value, cfg)])); }
        : function () { return (0, util_2.renderExtDo)(datum.label || ''); };
    return element;
}
function overlapHandler(cfg) {
    (0, overlap_1.processOverlap)(this.node().childNodes, cfg, {
        hide: function (label) {
            label.style.visibility = 'hidden';
        },
        show: function (label) {
            label.style.visibility = 'visible';
        },
        rotate: function (label, angle) {
            setRotateAndAdjustLabelAlign(+angle, label, cfg);
        },
        ellipsis: function (label, len, suffix) {
            if (len === void 0) { len = Infinity; }
            label && (0, util_2.ellipsisIt)(label, len, suffix);
        },
        getTextShape: function (label) { return label.querySelector('text'); },
    });
}
function createLabel(datum, index, data, cfg, style, animate) {
    var _this = this;
    // 1. set style
    // 2. set position
    // 3. set rotation
    // 4. set label align
    var label = (0, util_2.select)(this).append(datum.element).attr('className', constant_1.CLASS_NAMES.labelItem.name).node();
    var _a = tslib_1.__read((0, util_2.styleSeparator)((0, utils_2.getCallbackStyle)(style, [datum, index, data])), 2), labelStyle = _a[0], _b = _a[1], transform = _b.transform, groupStyle = tslib_1.__rest(_b, ["transform"]);
    (label === null || label === void 0 ? void 0 : label.nodeName) === 'text' &&
        label.attr(tslib_1.__assign({ fontSize: 12, fontFamily: 'sans-serif', fontWeight: 'normal', textAlign: 'center', textBaseline: 'middle' }, labelStyle));
    this.attr(groupStyle);
    var animation = (0, util_2.transition)(this, getLabelPos(datum, index, data, cfg), animate);
    var layout = function () {
        (0, util_2.percentTransform)(_this, transform);
        var rotate = getLabelRotation(datum, _this, cfg);
        setRotateAndAdjustLabelAlign(rotate, _this, cfg);
    };
    (0, animation_1.onAnimateFinished)(animation, layout);
    return animation;
}
function createLabels(container, element, data, cfg, style, animate) {
    var elements = (0, util_1.get)(element, '_elements');
    if (elements.length === 0)
        return null;
    var transitions = (0, util_1.get)(element, '_transitions');
    var animations = elements.map(function (el) { return createLabel.call(el, el.__data__, 0, data, cfg, style, animate); });
    animations.forEach(function (a, i) { return (transitions[i] = a); });
    // to avoid async manipulations
    if (animations.filter(function (a) { return !!a; }).length === 0)
        overlapHandler.call(container, cfg);
    else {
        Promise.all(animations).then(function () {
            overlapHandler.call(container, cfg);
        });
    }
    return animations;
}
function renderLabels(container, data, cfg, style, animate) {
    var finalData = (0, utils_2.filterExec)(data, cfg.labelFilter).map(function (datum, index, arr) { return (tslib_1.__assign({ element: formatter(datum, index, arr, cfg) }, datum)); });
    return container
        .selectAll(constant_1.CLASS_NAMES.label.class)
        .data(finalData, function (d, i) { return "".concat(d.value, "-").concat(d.label); })
        .join(function (enter) {
        return enter
            .append('g')
            .attr('className', constant_1.CLASS_NAMES.label.name)
            .call(function (element) {
            createLabels(container, element, finalData, cfg, style, false);
        });
    }, function (update) {
        return update
            .each(function () {
            (0, util_2.select)(this).node().removeChildren();
        })
            .call(function (element) {
            createLabels(container, element, finalData, cfg, style, animate.update);
        });
    }, function (exit) {
        return exit.transition(function () {
            var _this = this;
            var animation = (0, animation_1.fadeOut)(this, animate.exit);
            (0, animation_1.onAnimateFinished)(animation, function () {
                (0, util_2.select)(_this).remove();
            });
            return animation;
        });
    })
        .transitions();
}
exports.renderLabels = renderLabels;
//# sourceMappingURL=axisLabels.js.map