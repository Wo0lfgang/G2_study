"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderAxisLine = exports.isAxisVertical = exports.isAxisHorizontal = exports.getValuePos = exports.getArcValuePos = exports.getLinearValuePos = exports.getDirectionVector = exports.getLineTangentVector = exports.getLineAngle = void 0;
var tslib_1 = require("tslib");
var matrix_util_1 = require("@antv/matrix-util");
var util_1 = require("@antv/util");
var util_2 = require("../../../util");
var constant_1 = require("../constant");
var utils_1 = require("./utils");
exports.getLineAngle = (0, util_1.memoize)(function (value, cfg) {
    var _a = tslib_1.__read(cfg.angleRange, 2), startAngle = _a[0], endAngle = _a[1];
    return (endAngle - startAngle) * value + startAngle;
}, function (value, cfg) { return tslib_1.__spreadArray([value], tslib_1.__read(cfg.angleRange), false).join(); });
exports.getLineTangentVector = (0, util_1.memoize)(function (value, cfg) {
    if (cfg.type === 'linear') {
        var _a = tslib_1.__read(cfg.startPos, 2), startX = _a[0], startY = _a[1], _b = tslib_1.__read(cfg.endPos, 2), endX = _b[0], endY = _b[1];
        var _c = tslib_1.__read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
        return matrix_util_1.vec2.normalize([0, 0], [dx, dy]);
    }
    var angle = (0, util_2.degToRad)((0, exports.getLineAngle)(value, cfg));
    return [-Math.sin(angle), Math.cos(angle)];
}, function (value, cfg) {
    var dependencies = (0, utils_1.baseDependencies)(cfg);
    cfg.type === 'arc' && dependencies.push(value);
    return dependencies.join();
});
function getDirectionVector(value, direction, cfg) {
    var tangentVector = (0, exports.getLineTangentVector)(value, cfg);
    return matrix_util_1.ext.vertical([], tangentVector, direction !== 'positive');
}
exports.getDirectionVector = getDirectionVector;
exports.getLinearValuePos = (0, util_1.memoize)(function (value, cfg) {
    var _a = tslib_1.__read(cfg.startPos, 2), sx = _a[0], sy = _a[1], _b = tslib_1.__read(cfg.endPos, 2), ex = _b[0], ey = _b[1];
    var _c = tslib_1.__read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
    return [sx + dx * value, sy + dy * value];
}, function (value, cfg) { return tslib_1.__spreadArray(tslib_1.__spreadArray([value], tslib_1.__read(cfg.startPos), false), tslib_1.__read(cfg.endPos), false).join(); });
exports.getArcValuePos = (0, util_1.memoize)(function (value, cfg) {
    var radius = cfg.radius, _a = tslib_1.__read(cfg.center, 2), cx = _a[0], cy = _a[1];
    var angle = (0, util_2.degToRad)((0, exports.getLineAngle)(value, cfg));
    return [cx + radius * Math.cos(angle), cy + radius * Math.sin(angle)];
}, function (value, cfg) { return tslib_1.__spreadArray(tslib_1.__spreadArray(tslib_1.__spreadArray([value], tslib_1.__read(cfg.angleRange), false), [cfg.radius], false), tslib_1.__read(cfg.center), false).join(); });
function getValuePos(value, cfg) {
    if (cfg.type === 'linear')
        return (0, exports.getLinearValuePos)(value, cfg);
    return (0, exports.getArcValuePos)(value, cfg);
}
exports.getValuePos = getValuePos;
function isAxisHorizontal(cfg) {
    return (0, exports.getLineTangentVector)(0, cfg)[1] === 0;
}
exports.isAxisHorizontal = isAxisHorizontal;
function isAxisVertical(cfg) {
    return (0, exports.getLineTangentVector)(0, cfg)[0] === 0;
}
exports.isAxisVertical = isAxisVertical;
function isCircle(startAngle, endAngle) {
    return endAngle - startAngle === 360;
}
function getArcPath(startAngle, endAngle, cx, cy, radius) {
    var diffAngle = endAngle - startAngle;
    var _a = tslib_1.__read([radius, radius], 2), rx = _a[0], ry = _a[1];
    var _b = tslib_1.__read([(0, util_2.degToRad)(startAngle), (0, util_2.degToRad)(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
    var getPosByAngle = function (angle) { return [cx + radius * Math.cos(angle), cy + radius * Math.sin(angle)]; };
    var _c = tslib_1.__read(getPosByAngle(startAngleRadians), 2), x1 = _c[0], y1 = _c[1];
    var _d = tslib_1.__read(getPosByAngle(endAngleRadians), 2), x2 = _d[0], y2 = _d[1];
    if (isCircle(startAngle, endAngle)) {
        var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
        var _e = tslib_1.__read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
        return "M".concat(x1, ",").concat(y1, " A ").concat(rx, ",").concat(ry, " 0 1,0 ").concat(xm, ", ").concat(ym, " A ").concat(rx, ",").concat(ry, " 0 1,0 ").concat(x2, ", ").concat(y2);
    }
    // 大小弧
    var large = diffAngle > 180 ? 1 : 0;
    // 1-顺时针 0-逆时针
    var sweep = startAngle > endAngle ? 0 : 1;
    var isClosePath = false;
    return isClosePath
        ? "M".concat(cx, ",").concat(cy, ",L").concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x2, ",").concat(y2, ",L").concat(cx, ",").concat(cy)
        : "M".concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x2, ",").concat(y2);
}
function getArcAttr(arc) {
    var _a = arc.attributes, angleRange = _a.angleRange, center = _a.center, radius = _a.radius;
    return tslib_1.__spreadArray(tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(angleRange), false), tslib_1.__read(center), false), [radius], false);
}
function renderArc(container, cfg, style, animate) {
    var angleRange = cfg.angleRange, center = cfg.center, radius = cfg.radius;
    return container
        .selectAll(constant_1.CLASS_NAMES.line.class)
        .data([{ path: getArcPath.apply(void 0, tslib_1.__spreadArray(tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(angleRange), false), tslib_1.__read(center), false), [radius], false)) }], function (d, i) { return i; })
        .join(function (enter) {
        return enter
            .append('path')
            .attr('className', constant_1.CLASS_NAMES.line.name)
            .styles(tslib_1.__assign({ angleRange: angleRange, center: center, radius: radius }, style))
            .style('path', function (d) { return d.path; });
    }, function (update) {
        return update
            .styles(style)
            .transition(function () {
            var _this = this;
            var animation = (0, util_2.keyframeInterpolate)(this, getArcAttr(this), tslib_1.__spreadArray(tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(angleRange), false), tslib_1.__read(center), false), [radius], false), animate.update);
            if (animation) {
                var layout = function () {
                    var data = (0, util_1.get)(_this.style, '__keyframe_data__');
                    _this.style.path = getArcPath.apply(void 0, tslib_1.__spreadArray([], tslib_1.__read(data), false));
                };
                animation.onframe = layout;
                animation.onfinish = layout;
            }
            return animation;
        })
            .styles({ angleRange: angleRange, center: center, radius: radius });
    }, function (exit) { return exit.remove(); })
        .styles(style)
        .transitions();
}
function renderTruncation(container, _a, style) {
    var truncRange = _a.truncRange, truncShape = _a.truncShape, lineExtension = _a.lineExtension;
    // TODO
}
function extendLine(startPos, endPos, range) {
    if (range === void 0) { range = [0, 0]; }
    var _a = tslib_1.__read([startPos, endPos, range], 3), _b = tslib_1.__read(_a[0], 2), x1 = _b[0], y1 = _b[1], _c = tslib_1.__read(_a[1], 2), x2 = _c[0], y2 = _c[1], _d = tslib_1.__read(_a[2], 2), l1 = _d[0], l2 = _d[1];
    var _e = tslib_1.__read([x2 - x1, y2 - y1], 2), x = _e[0], y = _e[1];
    var L = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    var _f = tslib_1.__read([-l1 / L, l2 / L], 2), s1 = _f[0], s2 = _f[1];
    return [s1 * x, s1 * y, s2 * x, s2 * y];
}
function getLinePath(points) {
    var _a = tslib_1.__read(points, 2), _b = tslib_1.__read(_a[0], 2), x1 = _b[0], y1 = _b[1], _c = tslib_1.__read(_a[1], 2), x2 = _c[0], y2 = _c[1];
    return { x1: x1, y1: y1, x2: x2, y2: y2 };
}
function renderLinear(container, cfg, style, animate) {
    var startPos = cfg.startPos, endPos = cfg.endPos, truncRange = cfg.truncRange, lineExtension = cfg.lineExtension;
    var _a = tslib_1.__read([startPos, endPos], 2), _b = tslib_1.__read(_a[0], 2), x1 = _b[0], y1 = _b[1], _c = tslib_1.__read(_a[1], 2), x2 = _c[0], y2 = _c[1];
    var _d = tslib_1.__read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
    var renderLine = function (data) {
        return container
            .selectAll(constant_1.CLASS_NAMES.line.class)
            .data(data, function (d, i) { return i; })
            .join(function (enter) {
            return enter
                .append('line')
                .attr('className', function (d) { return "".concat(constant_1.CLASS_NAMES.line.name, " ").concat(d.className); })
                .styles(style)
                .transition(function (_a) {
                var line = _a.line;
                return (0, util_2.transition)(this, getLinePath(line), false);
            });
        }, function (update) {
            return update.styles(style).transition(function (_a) {
                var line = _a.line;
                return (0, util_2.transition)(this, getLinePath(line), animate.update);
            });
        }, function (exit) { return exit.remove(); })
            .transitions();
    };
    if (!truncRange) {
        return renderLine([
            {
                line: [
                    [x1 + ox1, y1 + oy1],
                    [x2 + ox2, y2 + oy2],
                ],
                className: constant_1.CLASS_NAMES.line.name,
            },
        ]);
    }
    var _e = tslib_1.__read(truncRange, 2), r1 = _e[0], r2 = _e[1];
    var _f = tslib_1.__read([x1 + (x2 - x1) * r1, y1 + (y2 - y1) * r1], 2), x3 = _f[0], y3 = _f[1];
    var _g = tslib_1.__read([x1 + (x2 - x1) * r2, y1 + (y2 - y1) * r2], 2), x4 = _g[0], y4 = _g[1];
    var animation = renderLine([
        {
            line: [
                [x1 + ox1, y1 + oy1],
                [x3, y3],
            ],
            className: constant_1.CLASS_NAMES.lineFirst.name,
        },
        {
            line: [
                [x4, y4],
                [x2 + ox2, y2 + oy2],
            ],
            className: constant_1.CLASS_NAMES.lineSecond.name,
        },
    ]);
    renderTruncation(container, cfg, style);
    return animation;
}
function renderAxisArrow(container, type, cfg, style) {
    var showArrow = cfg.showArrow, lineArrow = cfg.lineArrow, truncRange = cfg.truncRange, _a = cfg.lineArrowOffset, lineArrowOffset = _a === void 0 ? 0 : _a, lineArrowSize = cfg.lineArrowSize;
    var shapeToAddArrow;
    if (type === 'arc')
        shapeToAddArrow = container.select(constant_1.CLASS_NAMES.line.class);
    else if (truncRange)
        shapeToAddArrow = container.select(constant_1.CLASS_NAMES.lineSecond.class);
    else
        shapeToAddArrow = container.select(constant_1.CLASS_NAMES.line.class);
    if (!showArrow || !lineArrow || (cfg.type === 'arc' && isCircle.apply(void 0, tslib_1.__spreadArray([], tslib_1.__read(cfg.angleRange), false)))) {
        shapeToAddArrow.style('markerEnd', null);
        return;
    }
    var arrow = (0, util_2.renderExtDo)(lineArrow);
    arrow.attr(style);
    (0, util_2.scaleToPixel)(arrow, lineArrowSize, true);
    shapeToAddArrow.style('markerEnd', arrow).style('markerEndOffset', -lineArrowOffset);
}
function renderAxisLine(container, cfg, style, animate) {
    var type = cfg.type;
    var animation;
    if (type === 'linear')
        animation = renderLinear(container, cfg, style, animate);
    else
        animation = renderArc(container, cfg, style, animate);
    renderAxisArrow(container, type, cfg, style);
    return animation;
}
exports.renderAxisLine = renderAxisLine;
//# sourceMappingURL=axisLine.js.map