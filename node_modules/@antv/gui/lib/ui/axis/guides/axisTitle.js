"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderTitle = void 0;
var tslib_1 = require("tslib");
var matrix_util_1 = require("@antv/matrix-util");
var util_1 = require("../../../util");
var title_1 = require("../../title");
var constant_1 = require("../constant");
function getTitlePosition(mainGroup, titleGroup, cfg) {
    var _a = cfg.titlePosition, position = _a === void 0 ? 'lb' : _a, _b = cfg.titleSpacing, spacing = _b === void 0 ? 0 : _b;
    var pos = (0, title_1.parsePosition)(position);
    var _c = mainGroup.node().getBBox(), ax = _c.x, ay = _c.y;
    var _d = tslib_1.__read(mainGroup.node().getBounds().halfExtents, 2), aHw = _d[0], aHh = _d[1];
    var _e = tslib_1.__read(titleGroup.node().getBounds().halfExtents, 2), tHw = _e[0], tHh = _e[1];
    var _f = tslib_1.__read([ax + aHw, ay + aHh], 2), lcx = _f[0], lcy = _f[1];
    var _g = tslib_1.__read([lcx, lcy], 2), x = _g[0], y = _g[1];
    if (['start', 'end'].includes(position) && cfg.type === 'linear') {
        var startPos = cfg.startPos, endPos = cfg.endPos;
        // todo did not consider the truncate case
        var _h = tslib_1.__read(position === 'start' ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
        var direction = matrix_util_1.vec2.normalize([0, 0], [-to[0] + from[0], -to[1] + from[1]]);
        var _j = tslib_1.__read(matrix_util_1.vec2.scale([0, 0], direction, spacing), 2), dx = _j[0], dy = _j[1];
        return { x: from[0] + dx, y: from[1] + dy };
    }
    if (pos.includes('l'))
        x -= aHw + tHw + spacing;
    if (pos.includes('r'))
        x += aHw + tHw + spacing;
    if (pos.includes('t'))
        y -= aHh + tHh + spacing;
    if (pos.includes('b'))
        y += aHh + tHh + spacing;
    return { x: x, y: y };
}
function getTitleLayout(axis, titleGroup, cfg) {
    var mainGroup = axis.select(constant_1.CLASS_NAMES.mainGroup.class);
    return getTitlePosition(mainGroup, titleGroup, cfg);
}
function createTitle(container, cfg) {
    var title = cfg.title;
    var titleEl = container.maybeAppendByClassName(constant_1.CLASS_NAMES.title, function () { return (0, util_1.renderExtDo)(title); });
    return [container, titleEl];
}
function applyTitleStyle(title, group, axis, cfg, style) {
    var _a = tslib_1.__read((0, util_1.styleSeparator)(style), 2), titleStyle = _a[0], _b = _a[1], _c = _b.transform, transform = _c === void 0 ? '' : _c, groupStyle = tslib_1.__rest(_b, ["transform"]);
    title.styles(titleStyle);
    group.styles(groupStyle);
    var _d = getTitleLayout(axis, group, cfg), x = _d.x, y = _d.y;
    group.node().setPosition(x, y);
    (0, util_1.percentTransform)(title, transform);
}
function renderTitle(container, axis, cfg, style, animate) {
    if (!cfg.title)
        return null;
    var _a = tslib_1.__read(createTitle(container, cfg), 2), group = _a[0], title = _a[1];
    var apply = function () { return applyTitleStyle(title, group, axis, cfg, style); };
    if (!animate.update) {
        apply();
        return null;
    }
    var animation = title.node().animate([], animate.update);
    if (animation) {
        animation.onframe = function () { return apply(); };
        animation.onfinish = function () { return apply(); };
    }
    else
        apply();
    return animation;
}
exports.renderTitle = renderTitle;
//# sourceMappingURL=axisTitle.js.map