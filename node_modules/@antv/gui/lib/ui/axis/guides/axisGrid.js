"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderGrid = void 0;
var tslib_1 = require("tslib");
var matrix_util_1 = require("@antv/matrix-util");
var util_1 = require("@antv/util");
var util_2 = require("../../../util");
var grid_1 = require("../../grid");
var constant_1 = require("../constant");
var axisLine_1 = require("./axisLine");
var utils_1 = require("./utils");
function getGridVector(value, cfg) {
    return (0, axisLine_1.getDirectionVector)(value, cfg.gridDirection, cfg);
}
function getGridCenter(cfg) {
    var type = cfg.type, gridCenter = cfg.gridCenter;
    if (type === 'linear')
        return gridCenter;
    return gridCenter || cfg.center;
}
function renderStraight(data, cfg) {
    var _a = cfg.gridLength, gridLength = _a === void 0 ? 0 : _a;
    return data.map(function (_a) {
        var value = _a.value;
        var _b = tslib_1.__read((0, axisLine_1.getValuePos)(value, cfg), 2), x = _b[0], y = _b[1];
        var _c = tslib_1.__read(matrix_util_1.vec2.scale([0, 0], getGridVector(value, cfg), gridLength), 2), dx = _c[0], dy = _c[1];
        return {
            points: [
                [x, y],
                [x + dx, y + dy],
            ],
        };
    });
}
function renderSurround(data, cfg, style) {
    var controlAngles = style.controlAngles;
    var center = getGridCenter(cfg);
    if (!center)
        throw new Error('grid center is not provide');
    if (data.length < 2)
        throw new Error('Invalid grid data');
    if (!controlAngles || controlAngles.length === 0)
        throw new Error('Invalid gridControlAngles');
    var _a = tslib_1.__read(center, 2), cx = _a[0], cy = _a[1];
    return data.map(function (_a) {
        var value = _a.value;
        var _b = tslib_1.__read((0, axisLine_1.getValuePos)(value, cfg), 2), sx = _b[0], sy = _b[1];
        var _c = tslib_1.__read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
        var points = [];
        controlAngles.forEach(function (angle) {
            var angleInRad = (0, util_2.degToRad)(angle);
            var _a = tslib_1.__read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a[0], sina = _a[1];
            var x = dx * cosa - dy * sina + cx;
            var y = dx * sina + dy * cosa + cy;
            points.push([x, y]);
        });
        return { points: points };
    });
}
function renderGrid(container, data, cfg, style, animate) {
    var type = style.type, closed = style.closed, areaFill = style.areaFill, connect = style.connect;
    var center = getGridCenter(cfg);
    var finalData = (0, utils_1.filterExec)(data, cfg.gridFilter);
    var gridItems = type === 'segment' ? renderStraight(finalData, cfg) : renderSurround(finalData, cfg, style);
    container
        .maybeAppendByClassName(constant_1.CLASS_NAMES.grid, function () { return new grid_1.Grid({}); })
        .update(tslib_1.__assign(tslib_1.__assign({ type: type, animate: animate, connect: connect, closed: closed, center: center }, style), { items: gridItems, areaFill: (0, util_1.isFunction)(areaFill)
            ? finalData.map(function (datum, index) { return (0, util_2.getCallbackValue)(areaFill, [datum, index, finalData]); })
            : areaFill }));
}
exports.renderGrid = renderGrid;
//# sourceMappingURL=axisGrid.js.map