"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processOverlap = exports.canProcessOverlap = exports.OverlapUtils = void 0;
var tslib_1 = require("tslib");
var autoEllipsis_1 = tslib_1.__importDefault(require("./autoEllipsis"));
var autoHide_1 = tslib_1.__importDefault(require("./autoHide"));
var autoRotate_1 = tslib_1.__importDefault(require("./autoRotate"));
exports.OverlapUtils = new Map([
    ['hide', autoHide_1.default],
    ['rotate', autoRotate_1.default],
    ['ellipsis', autoEllipsis_1.default],
]);
function canProcessOverlap(labels, cfg, type) {
    if (!cfg.labelTransforms)
        return false;
    // if (type === 'rotate') return !labels.some((label) => hasSetRotate(label.attr('transform')));
    if (type === 'ellipsis')
        return labels.map(function (item) { return item.querySelector('text'); }).length > 1;
    return true;
}
exports.canProcessOverlap = canProcessOverlap;
function processOverlap(labels, cfg, utils) {
    var _a = cfg.labelTransforms, overlapOrder = _a === void 0 ? [] : _a;
    if (!overlapOrder.length)
        return;
    overlapOrder.forEach(function (overlapCfg) {
        var type = overlapCfg.type;
        var util = exports.OverlapUtils.get(type);
        if (canProcessOverlap(labels, cfg, type))
            util === null || util === void 0 ? void 0 : util(labels, overlapCfg, cfg, utils);
    });
}
exports.processOverlap = processOverlap;
//# sourceMappingURL=index.js.map