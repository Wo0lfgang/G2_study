"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.greedy = void 0;
var tslib_1 = require("tslib");
var util_1 = require("../../../util");
var intersect_1 = require("../../../layout/intersect");
var axisLine_1 = require("../guides/axisLine");
var helper_1 = require("../utils/helper");
var methods = {
    parity: function (items, _a) {
        var _b = _a.seq, seq = _b === void 0 ? 2 : _b;
        return items.filter(function (item, i) { return (i % seq ? ((item.style.visibility = 'hidden'), false) : true); });
    },
};
var filterDefined = function (arr) { return arr.filter(function (d) { return (0, util_1.defined)(d); }); };
function equidistance(labels, overlapCfg, cfg, utils) {
    var count = labels.length;
    var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
    if (count <= 1)
        return;
    if (count === 2 && keepHeader && keepTail)
        return;
    var parityHide = methods.parity;
    var reset = function (els) { return (els.forEach(utils.show), els); };
    var seq = 2;
    // 浅复制
    var source = labels.slice();
    var target = labels.slice();
    // Generally, 100 ticks cost less than 20ms. If cost time exceed, means ticks count is too large to see.
    var timeout = 200;
    var now = Date.now();
    var minLabelWidth = Math.min.apply(Math, tslib_1.__spreadArray([1], tslib_1.__read(labels.map(function (d) { return d.getBBox().width; })), false));
    if (cfg.type === 'linear' && ((0, axisLine_1.isAxisHorizontal)(cfg) || (0, axisLine_1.isAxisVertical)(cfg))) {
        var minX = (0, util_1.getLocalBBox)(labels[0]).left;
        var maxX = (0, util_1.getLocalBBox)(labels[count - 1]).right;
        var distance = Math.abs(maxX - minX) || 1;
        seq = Math.max(Math.floor((count * minLabelWidth) / distance), seq);
    }
    var first;
    var last;
    if (keepHeader) {
        first = source.splice(0, 1)[0];
    }
    if (keepTail) {
        last = source.splice(-1, 1)[0];
        source.reverse();
    }
    while ((0, helper_1.boundTest)(filterDefined(last ? tslib_1.__spreadArray(tslib_1.__spreadArray([last], tslib_1.__read(target), false), [first], false) : tslib_1.__spreadArray([first], tslib_1.__read(target), false)), overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
        // 每两步，减一个 (不需要考虑保留 first)
        if (last && !first && seq % 2 === 0) {
            var rest = source.splice(0, 1);
            rest.forEach(utils.hide);
        }
        else if (last && first) {
            // 如果有 first 的话，每一步，减一个（增加迭代次数）
            var rest = source.splice(0, 1);
            rest.forEach(utils.hide);
        }
        target = parityHide(reset(source), { seq: seq });
        seq++;
        // layout time exceeded;
        if (Date.now() - now > timeout)
            return;
    }
}
exports.default = equidistance;
function greedy(labels, overlapCfg) {
    var count = labels.length;
    if (count <= 1)
        return;
    var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
    if (count === 2 && keepHeader && keepTail)
        return;
    // 浅复制
    var source = labels.slice();
    var a;
    source.forEach(function (b, i) {
        if (!i || !a || !(0, intersect_1.intersect)(a, b, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin)) {
            a = b;
        }
        else if (i === count - 1 && keepTail) {
            a.style.visibility = 'hidden';
        }
        else {
            b.style.visibility = 'hidden';
        }
    });
}
exports.greedy = greedy;
//# sourceMappingURL=autoHide.js.map