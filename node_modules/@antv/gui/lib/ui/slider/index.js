"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Slider = void 0;
var tslib_1 = require("tslib");
var g_1 = require("@antv/g");
var util_1 = require("@antv/util");
var gui_1 = require("../../core/gui");
var util_2 = require("../../util");
var sparkline_1 = require("../sparkline");
var constant_1 = require("./constant");
var handle_1 = require("./handle");
var Slider = /** @class */ (function (_super) {
    tslib_1.__extends(Slider, _super);
    function Slider(options) {
        var _this = _super.call(this, (0, util_1.deepMix)({}, Slider.defaultOptions, options)) || this;
        _this.range = [0, 1];
        _this.animation = {
            duration: 100,
            fill: 'both',
        };
        _this.onDragStart = function (target) { return function (e) {
            e.stopPropagation();
            _this.target = target;
            _this.prevPos = _this.getOrientVal((0, util_2.getEventPos)(e));
            var _a = _this.availableSpace, x = _a.x, y = _a.y;
            var _b = _this.attributes, X = _b.x, Y = _b.y;
            _this.selectionStartPos = _this.getRatio(_this.prevPos - _this.getOrientVal([x, y]) - _this.getOrientVal([+X, +Y]));
            _this.selectionWidth = 0;
            document.addEventListener('mousemove', _this.onDragging);
            document.addEventListener('touchmove', _this.onDragging);
            document.addEventListener('mouseup', _this.onDragEnd);
            document.addEventListener('touchend', _this.onDragEnd);
        }; };
        _this.onDragging = function (e) {
            var _a = _this.attributes, slidable = _a.slidable, brushable = _a.brushable;
            e.stopPropagation();
            var currPos = _this.getOrientVal((0, util_2.getEventPos)(e));
            var diffPos = currPos - _this.prevPos;
            if (!diffPos)
                return;
            var deltaVal = _this.getRatio(diffPos);
            switch (_this.target) {
                case 'start':
                    if (slidable)
                        _this.setValuesOffset(deltaVal);
                    break;
                case 'end':
                    if (slidable)
                        _this.setValuesOffset(0, deltaVal);
                    break;
                case 'selection':
                    if (slidable)
                        _this.setValuesOffset(deltaVal, deltaVal);
                    break;
                case 'track':
                    if (!brushable)
                        return;
                    // 绘制蒙板
                    _this.selectionWidth += deltaVal;
                    _this.innerSetValues([_this.selectionStartPos, _this.selectionStartPos + _this.selectionWidth].sort(), true);
                    break;
                default:
                    break;
            }
            _this.prevPos = currPos;
        };
        _this.onDragEnd = function () {
            document.removeEventListener('mousemove', _this.onDragging);
            document.removeEventListener('mousemove', _this.onDragging);
            document.removeEventListener('mouseup', _this.onDragEnd);
            document.removeEventListener('touchend', _this.onDragEnd);
        };
        _this.onValueChange = function (oldValue) {
            var evt = new g_1.CustomEvent('valuechange', {
                detail: {
                    oldValue: oldValue,
                    value: _this.getValues(),
                },
            });
            _this.dispatchEvent(evt);
        };
        _this.selectionStartPos = 0;
        _this.selectionWidth = 0;
        _this.prevPos = 0;
        _this.target = '';
        return _this;
    }
    Object.defineProperty(Slider.prototype, "values", {
        get: function () {
            return this.getAttribute('values');
        },
        set: function (values) {
            this.setAttribute('values', this.clampValues(values));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "sparklineShapeCfg", {
        get: function () {
            var orient = this.attributes.orient;
            // 暂时只在水平模式下绘制
            if (orient !== 'horizontal')
                return null;
            var _a = (0, util_2.subObject)(this.attributes, 'sparkline'), padding = _a.padding, sparklineStyle = tslib_1.__rest(_a, ["padding"]);
            var _b = tslib_1.__read((0, util_2.normalSeriesAttr)(padding), 4), top = _b[0], right = _b[1], bottom = _b[2], left = _b[3];
            var _c = this.availableSpace, width = _c.width, height = _c.height;
            var _d = this.attributes.trackLineWidth, trackLineWidth = _d === void 0 ? 0 : _d;
            var bkgLW = +trackLineWidth;
            return tslib_1.__assign(tslib_1.__assign({ x: bkgLW / 2 + left, y: bkgLW / 2 + top }, sparklineStyle), { zIndex: 0, width: width - bkgLW - left - right, height: height - bkgLW - top - bottom });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "shape", {
        get: function () {
            var _a = this.attributes, trackLength = _a.trackLength, trackSize = _a.trackSize;
            var _b = tslib_1.__read(this.getOrientVal([
                [trackLength, trackSize],
                [trackSize, trackLength],
            ]), 2), width = _b[0], height = _b[1];
            return { width: width, height: height };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "availableSpace", {
        get: function () {
            var padding = this.attributes.padding;
            var _a = tslib_1.__read((0, util_2.normalSeriesAttr)(padding), 4), top = _a[0], right = _a[1], bottom = _a[2], left = _a[3];
            var _b = this.shape, width = _b.width, height = _b.height;
            return {
                x: left,
                y: top,
                width: width - (left + right),
                height: height - (top + bottom),
            };
        },
        enumerable: false,
        configurable: true
    });
    Slider.prototype.getValues = function () {
        return this.values;
    };
    /** 不触发重绘 */
    Slider.prototype.setValues = function (values, animate) {
        if (values === void 0) { values = [0, 0]; }
        if (animate === void 0) { animate = false; }
        this.attr('values', values);
        var animation = animate === false ? false : this.animation;
        (0, util_2.transition)(this.selectionShape.node(), this.selectionCfg, animation);
        (0, util_2.transition)(this.startHandle.node(), this.getHandleShapeCfg('start'), animation);
        (0, util_2.transition)(this.endHandle.node(), this.getHandleShapeCfg('end'), animation);
    };
    Slider.prototype.innerSetValues = function (values, trigger) {
        if (values === void 0) { values = [0, 0]; }
        if (trigger === void 0) { trigger = false; }
        var oldValues = this.values;
        var newValues = this.clampValues(values);
        this.update({ values: newValues });
        if (trigger) {
            this.onValueChange(oldValues);
        }
    };
    Slider.prototype.renderTrack = function (container) {
        var brushable = this.attributes.brushable;
        var trackStyle = (0, util_2.subObject)(this.attributes, 'track');
        this.trackShape = (0, util_2.select)(container)
            .maybeAppendByClassName('slider-track', 'rect')
            .styles(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this.shape), trackStyle), { cursor: brushable ? 'crosshair' : 'default' }));
    };
    Slider.prototype.renderSparkline = function (container) {
        var _this = this;
        var orient = this.attributes.orient;
        var sparklineGroup = (0, util_2.select)(container).maybeAppendByClassName('slider-sparkline-group', 'g');
        (0, util_2.ifShow)(orient === 'horizontal', sparklineGroup, function (group) {
            var sparklineStyle = _this.sparklineShapeCfg;
            group
                .maybeAppendByClassName('slider-sparkline', function () { return new sparkline_1.Sparkline({ style: sparklineStyle }); })
                .call(function (selection) {
                selection.node().update(sparklineStyle);
            });
        });
    };
    Object.defineProperty(Slider.prototype, "selectionCfg", {
        get: function () {
            var selectionStyle = (0, util_2.subObject)(this.attributes, 'selection');
            return tslib_1.__assign(tslib_1.__assign({}, selectionStyle), this.calcMask());
        },
        enumerable: false,
        configurable: true
    });
    Slider.prototype.renderSelection = function (container) {
        var _this = this;
        this.foregroundGroup = (0, util_2.select)(container).maybeAppendByClassName('slider-foreground', 'g');
        this.selectionShape = this.foregroundGroup
            .maybeAppendByClassName('slider-selection', 'rect')
            .styles(this.selectionCfg);
        var createHandle = function (type) {
            var className = "".concat(type, "-handle");
            var style = _this.getHandleShapeCfg(type);
            var handle = _this.foregroundGroup
                .maybeAppendByClassName(className, function () { return new handle_1.Handle({ style: style }); })
                .style('type', type)
                .update(style);
            return handle;
        };
        this.startHandle = createHandle('start');
        this.endHandle = createHandle('end');
    };
    Slider.prototype.render = function (attributes, container) {
        this.renderTrack(container);
        this.renderSparkline(container);
        this.renderSelection(container);
    };
    Slider.prototype.clampValues = function (values, precision) {
        var _a;
        if (precision === void 0) { precision = 4; }
        var _b = tslib_1.__read(this.range, 2), min = _b[0], max = _b[1];
        var _c = tslib_1.__read(this.getValues().map(function (num) { return (0, util_2.toPrecision)(num, precision); }), 2), prevStart = _c[0], prevEnd = _c[1];
        var _d = tslib_1.__read((values || [prevStart, prevEnd]).map(function (num) { return (0, util_2.toPrecision)(num, precision); }), 2), startVal = _d[0], endVal = _d[1];
        // 交换startVal endVal
        if (startVal > endVal) {
            _a = tslib_1.__read([endVal, startVal], 2), startVal = _a[0], endVal = _a[1];
        }
        var range = endVal - startVal;
        // 超出范围就全选
        if (range > max - min)
            return [min, max];
        if (startVal < min) {
            if (prevStart === min && prevEnd === endVal)
                return [min, endVal];
            return [min, range + min];
        }
        if (endVal > max) {
            if (prevEnd === max && prevStart === startVal)
                return [startVal, max];
            return [max - range, max];
        }
        // 保留小数
        return [startVal, endVal];
    };
    /**
     * 计算蒙板坐标和宽高
     * 默认用来计算前景位置大小
     */
    Slider.prototype.calcMask = function (values) {
        var _a = tslib_1.__read(this.clampValues(values), 2), start = _a[0], end = _a[1];
        var _b = this.availableSpace, x = _b.x, y = _b.y, width = _b.width, height = _b.height;
        return this.getOrientVal([
            {
                y: y,
                height: height,
                x: start * width + x,
                width: (end - start) * width,
            },
            {
                x: x,
                width: width,
                y: start * height + y,
                height: (end - start) * height,
            },
        ]);
    };
    /**
     * 计算手柄的x y
     */
    Slider.prototype.calcHandlePosition = function (handleType) {
        var _a = this.availableSpace, width = _a.width, height = _a.height;
        var _b = tslib_1.__read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
        var L = (handleType === 'start' ? stVal : endVal) * this.getOrientVal([width, height]);
        return {
            x: this.getOrientVal([L, width / 2]),
            y: this.getOrientVal([height / 2, L]),
        };
    };
    /**
     * 计算手柄应当处于的位置
     * @param handleType start手柄还是end手柄
     * @returns
     */
    Slider.prototype.calcHandleText = function (handleType) {
        var _a = this.attributes, orient = _a.orient, formatter = _a.formatter;
        var handleStyle = (0, util_2.subObject)(this.attributes, 'handle');
        var labelStyle = (0, util_2.subObject)(handleStyle, 'label');
        var spacing = handleStyle.spacing;
        var size = this.getHandleSize();
        var values = this.clampValues();
        // 相对于获取两端可用空间
        var _b = this.availableSpace, iW = _b.width, iH = _b.height;
        var _c = this.calcMask(), fX = _c.x, fY = _c.y, fW = _c.width, fH = _c.height;
        var value = handleType === 'start' ? values[0] : values[1];
        var formattedText = formatter(value);
        var temp = this.appendChild(new g_1.Text({
            style: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ visibility: 'hidden' }, util_2.TEXT_INHERITABLE_PROPS), labelStyle), { text: formattedText }),
        }));
        // 文字包围盒的宽高
        var _d = temp.getBBox(), textWidth = _d.width, textHeight = _d.height;
        temp.destroy();
        var x = 0;
        var y = 0;
        if (orient === 'horizontal') {
            var totalSpacing = spacing + size;
            var finalWidth = totalSpacing + textWidth / 2;
            if (handleType === 'start') {
                var left = fX - totalSpacing - textWidth;
                x = left > 0 ? -finalWidth : finalWidth;
            }
            else {
                var sign = iW - fX - fW - totalSpacing > textWidth;
                x = sign ? finalWidth : -finalWidth;
            }
        }
        else {
            var finalWidth = spacing + size;
            if (handleType === 'start') {
                y = fY - size > textHeight ? -finalWidth : finalWidth;
            }
            else {
                y = iH - fY - fH - size > textHeight ? finalWidth : -finalWidth;
            }
        }
        return { x: x, y: y, text: formattedText };
    };
    Slider.prototype.getHandleLabelShapeCfg = function (handleType) {
        var showLabel = this.attributes.showLabel;
        if (!showLabel)
            return {};
        var labelStyle = (0, util_2.subObject)(this.attributes, 'handleLabel');
        return tslib_1.__assign(tslib_1.__assign({}, labelStyle), this.calcHandleText(handleType));
    };
    Slider.prototype.getHandleIconShapeCfg = function () {
        var _a = this.attributes, orient = _a.orient, handleIconShape = _a.handleIconShape;
        var labelStyle = (0, util_2.subObject)(this.attributes, 'handleIcon');
        var cursor = this.getOrientVal(['ew-resize', 'ns-resize']);
        var size = this.getHandleSize();
        return tslib_1.__assign(tslib_1.__assign({}, labelStyle), { shape: handleIconShape, orient: orient, cursor: cursor, size: size });
    };
    Slider.prototype.getHandleShapeCfg = function (handleType) {
        var _a = this.attributes, showHandle = _a.showHandle, showLabel = _a.showLabel;
        var _b = this.calcHandlePosition(handleType), x = _b.x, y = _b.y;
        var textCfg = this.calcHandleText(handleType);
        return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ zIndex: 3, showLabel: showLabel, visibility: showHandle ? 'visible' : 'hidden' }, (0, util_2.superObject)(this.getHandleIconShapeCfg(), 'icon')), (0, util_2.superObject)(tslib_1.__assign(tslib_1.__assign({}, this.getHandleLabelShapeCfg(handleType)), textCfg), 'label')), { x: x, y: y });
    };
    Slider.prototype.getHandleSize = function () {
        var size = this.attributes.handleIconSize;
        if (size)
            return size;
        // 没设置 size 的话，高度就取 height + 4 高度，手柄宽度是高度的 1/ 2.4
        var _a = this.attributes, width = _a.width, height = _a.height;
        return Math.floor((this.getOrientVal([+height, +width]) + 4) / 2.4);
    };
    Slider.prototype.getOrientVal = function (_a) {
        var _b = tslib_1.__read(_a, 2), x = _b[0], y = _b[1];
        var orient = this.attributes.orient;
        return orient === 'horizontal' ? x : y;
    };
    Slider.prototype.setValuesOffset = function (stOffset, endOffset, animate) {
        if (endOffset === void 0) { endOffset = 0; }
        if (animate === void 0) { animate = false; }
        var _a = tslib_1.__read(this.getValues(), 2), oldStartVal = _a[0], oldEndVal = _a[1];
        var values = [oldStartVal + stOffset, oldEndVal + endOffset].sort();
        if (animate)
            this.setValues(values);
        else
            this.innerSetValues(values, true);
    };
    Slider.prototype.getRatio = function (val) {
        var _a = this.availableSpace, width = _a.width, height = _a.height;
        return val / this.getOrientVal([width, height]);
    };
    Slider.prototype.dispatchCustomEvent = function (target, event, name) {
        var _this = this;
        target.on(event, function (e) {
            e.stopPropagation();
            _this.dispatchEvent(new g_1.CustomEvent(name, { detail: e }));
        });
    };
    Slider.prototype.bindEvents = function () {
        var _this = this;
        var selection = this.selectionShape;
        // scroll 事件
        this.addEventListener('wheel', this.onScroll);
        // 选区drag事件
        selection.on('mousedown', this.onDragStart('selection'));
        selection.on('touchstart', this.onDragStart('selection'));
        // 选区hover事件
        this.dispatchCustomEvent(selection, 'mouseenter', 'selectionMouseenter');
        this.dispatchCustomEvent(selection, 'mouseleave', 'selectionMouseleave');
        this.dispatchCustomEvent(selection, 'click', 'selectionClick');
        [this.startHandle, this.endHandle].forEach(function (handle) {
            var type = handle.node().attr('type');
            handle.on('mousedown', function (e) {
                _this.onDragStart(type)(e);
            });
            handle.on('touchstart', function (e) {
                _this.onDragStart(type)(e);
            });
        });
        var track = this.trackShape;
        this.dispatchCustomEvent(track, 'click', 'trackClick');
        this.dispatchCustomEvent(track, 'mouseenter', 'trackMouseenter');
        this.dispatchCustomEvent(track, 'mouseleave', 'trackMouseleave');
        // Drag and brush
        track.on('mousedown', this.onDragStart('track'));
        track.on('touchstart', this.onDragStart('track'));
    };
    Slider.prototype.onScroll = function (event) {
        var scrollable = this.attributes.scrollable;
        if (scrollable) {
            var deltaX = event.deltaX, deltaY = event.deltaY;
            var offset = deltaY || deltaX;
            var deltaVal = this.getRatio(offset);
            this.setValuesOffset(deltaVal, deltaVal, true);
        }
    };
    Slider.tag = 'slider';
    Slider.defaultOptions = {
        style: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ values: [0, 1], trackLength: 200, trackSize: 20, slidable: true, brushable: true, scrollable: true, orient: 'horizontal', trackZIndex: -1, trackFill: '#416180', trackOpacity: 0.05, selectionCursor: 'move', selectionZIndex: 2, selectionFill: '#5B8FF9', selectionFillOpacity: 0.45, sparklinePadding: 1, padding: 0, showHandle: true, showLabel: true, handleSpacing: 2, formatter: function (val) { return val; } }, (0, util_2.superObject)(constant_1.HANDLE_DEFAULT_CFG, 'handle')), (0, util_2.superObject)(constant_1.HANDLE_ICON_DEFAULT_CFG, 'handleIcon')), (0, util_2.superObject)(constant_1.HANDLE_LABEL_DEFAULT_CFG, 'handleLabel')),
    };
    return Slider;
}(gui_1.GUI));
exports.Slider = Slider;
//# sourceMappingURL=index.js.map