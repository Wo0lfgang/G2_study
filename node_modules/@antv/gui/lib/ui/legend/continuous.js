"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Continuous = void 0;
var tslib_1 = require("tslib");
var g_1 = require("@antv/g");
var scale_1 = require("@antv/scale");
var util_1 = require("@antv/util");
var gui_1 = require("../../core/gui");
var util_2 = require("../../util");
var axis_1 = require("../axis");
var constant_1 = require("../axis/constant");
var indicator_1 = require("../indicator");
var title_1 = require("../title");
var constant_2 = require("./constant");
var handle_1 = require("./continuous/handle");
var ribbon_1 = require("./continuous/ribbon");
var utils_1 = require("./continuous/utils");
var utils_2 = require("./utils");
var getMinMax = (0, util_1.memoize)(function (data) {
    return {
        min: Math.min.apply(Math, tslib_1.__spreadArray([], tslib_1.__read(data.map(function (d) { return d.value; })), false)),
        max: Math.max.apply(Math, tslib_1.__spreadArray([], tslib_1.__read(data.map(function (d) { return d.value; })), false)),
    };
}, function (data) { return data.map(function (d) { return d.id; }); });
var Continuous = /** @class */ (function (_super) {
    tslib_1.__extends(Continuous, _super);
    function Continuous(config) {
        var _this = _super.call(this, (0, util_2.deepAssign)({}, constant_2.CONTINUOUS_DEFAULT_OPTIONS, config)) || this;
        _this.eventToOffsetScale = new scale_1.Linear({});
        _this.innerRibbonScale = new scale_1.Linear({});
        _this.cacheLabelBBox = null;
        _this.cacheHandleBBox = null;
        _this.onHovering = function (e) {
            var _a = _this.attributes, data = _a.data, block = _a.block;
            e.stopPropagation();
            var value = _this.getValueByCanvasPoint(e);
            if (block) {
                var range = (0, utils_1.getNextTickValue)(data.map(function (_a) {
                    var value = _a.value;
                    return value;
                }), value).range;
                _this.showIndicator((range[0] + range[1]) / 2, "".concat(range[0], "-").concat(range[1]));
                _this.dispatchIndicated(value, range);
            }
            else {
                var safetyValue = _this.getTickValue(value);
                _this.showIndicator(safetyValue);
                _this.dispatchIndicated(safetyValue);
            }
        };
        _this.onDragStart = function (target) { return function (e) {
            e.stopPropagation();
            // 关闭滑动
            if (!_this.attributes.slidable)
                return;
            _this.target = target;
            _this.prevValue = _this.getTickValue(_this.getValueByCanvasPoint(e));
            document.addEventListener('mousemove', _this.onDragging);
            document.addEventListener('touchmove', _this.onDragging);
            document.addEventListener('mouseleave', _this.onDragEnd);
            document.addEventListener('mouseup', _this.onDragEnd);
            document.addEventListener('mouseup', _this.onDragEnd);
            document.addEventListener('touchend', _this.onDragEnd);
        }; };
        _this.onDragging = function (e) {
            var target = _this.target;
            _this.updateMouse();
            var _a = tslib_1.__read(_this.selection, 2), start = _a[0], end = _a[1];
            var currValue = _this.getTickValue(_this.getValueByCanvasPoint(e));
            var diffValue = currValue - _this.prevValue;
            if (target === 'start')
                start !== currValue && _this.updateSelection(currValue, end);
            else if (target === 'end')
                end !== currValue && _this.updateSelection(start, currValue);
            else if (target === 'ribbon' && diffValue !== 0) {
                _this.prevValue = currValue;
                _this.updateSelection(diffValue, diffValue, true);
            }
        };
        _this.onDragEnd = function () {
            _this.style.cursor = 'default';
            document.removeEventListener('mousemove', _this.onDragging);
            document.removeEventListener('touchmove', _this.onDragging);
            document.removeEventListener('mouseup', _this.onDragEnd);
            document.removeEventListener('touchend', _this.onDragEnd);
        };
        return _this;
    }
    Object.defineProperty(Continuous.prototype, "handleOffsetRatio", {
        get: function () {
            return this.ifHorizontal(0.7, 0.9);
        },
        enumerable: false,
        configurable: true
    });
    Continuous.prototype.getBBox = function () {
        var _a = this.attributes, width = _a.width, height = _a.height;
        return new util_2.BBox(0, 0, width, height);
    };
    Continuous.prototype.render = function (attributes, container) {
        // 渲染顺序
        // 1. 绘制 title, 获得可用空间
        // 2. 绘制 label, handle
        // 3. 基于可用空间、label高度、handle 宽高，计算 ribbon 宽高
        // 4. 绘制 ribbon
        // 5. 调整 label、handle 位置
        var _this = this;
        /** title */
        this.renderTitle((0, util_2.select)(container));
        var _a = this.title.node().getAvailableSpace(), x = _a.x, y = _a.y;
        /** label */
        var showLabel = attributes.showLabel;
        /** content */
        var contentGroup = (0, util_2.select)(container).maybeAppendByClassName(constant_2.CLASS_NAMES.contentGroup, 'g').styles({ x: x, y: y });
        var labelGroup = contentGroup.maybeAppendByClassName(constant_2.CLASS_NAMES.labelGroup, 'g').styles({ zIndex: 1 });
        (0, util_2.ifShow)(!!showLabel, labelGroup, function (group) {
            _this.renderLabel(group);
        });
        var ribbonGroup = contentGroup.maybeAppendByClassName(constant_2.CLASS_NAMES.ribbonGroup, 'g');
        /** handle */
        this.handlesGroup = contentGroup.maybeAppendByClassName(constant_2.CLASS_NAMES.handlesGroup, 'g').styles({ zIndex: 2 });
        this.renderHandles();
        /** ribbon */
        this.renderRibbon(ribbonGroup);
        this.renderIndicator(contentGroup);
        /** adjust */
        this.adjustLabel();
        this.adjustHandles();
    };
    Object.defineProperty(Continuous.prototype, "range", {
        get: function () {
            var data = this.attributes.data;
            return getMinMax(data);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "ribbonScale", {
        get: function () {
            var _a = this.range, min = _a.min, max = _a.max;
            this.innerRibbonScale.update({
                domain: [min, max],
                range: [0, 1],
            });
            return this.innerRibbonScale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "ribbonRange", {
        get: function () {
            var _a = tslib_1.__read(this.selection, 2), min = _a[0], max = _a[1];
            var scale = this.ribbonScale;
            return [scale.map(min), scale.map(max)];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "selection", {
        get: function () {
            var _a = this.range, min = _a.min, max = _a.max;
            var _b = this.attributes.defaultValue, _c = _b === void 0 ? [min, max] : _b, _d = tslib_1.__read(_c, 2), start = _d[0], end = _d[1];
            return [start, end];
        },
        enumerable: false,
        configurable: true
    });
    Continuous.prototype.ifHorizontal = function (a, b) {
        return (0, utils_2.ifHorizontal)(this.style.orient, typeof a === 'function' ? a() : a, typeof b === 'function' ? b() : b);
    };
    Continuous.prototype.renderTitle = function (container) {
        var _a = this.attributes, showTitle = _a.showTitle, _b = _a.titleText, titleText = _b === void 0 ? '' : _b, width = _a.width, height = _a.height;
        var style = (0, util_2.subObject)(this.attributes, 'title');
        var finalTitleStyle = tslib_1.__assign(tslib_1.__assign({ width: width, height: height }, style), { text: showTitle ? titleText : '' });
        this.title = container
            .maybeAppendByClassName(constant_2.CLASS_NAMES.title, function () { return new title_1.Title({ style: finalTitleStyle }); })
            .update(finalTitleStyle);
    };
    Object.defineProperty(Continuous.prototype, "labelFixedSpacing", {
        get: function () {
            var labelShowTick = this.attributes.labelShowTick;
            return labelShowTick ? 5 : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "labelPosition", {
        get: function () {
            var _a = this.attributes, orient = _a.orient, labelDirection = _a.labelDirection;
            var positions = {
                vertical: { positive: 'right', negative: 'left' },
                horizontal: { positive: 'bottom', negative: 'top' },
            };
            return positions[orient][labelDirection];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "labelBBox", {
        get: function () {
            var _a;
            var showLabel = this.attributes.showLabel;
            if (!showLabel)
                return new util_2.BBox(0, 0, 0, 0);
            if (this.cacheLabelBBox)
                return this.cacheLabelBBox;
            var _b = ((_a = this.label.querySelector(constant_1.CLASS_NAMES.labelGroup.class)) === null || _a === void 0 ? void 0 : _a.children.slice(-1)[0]).getBBox(), width = _b.width, height = _b.height;
            this.cacheLabelBBox = new util_2.BBox(0, 0, width, height);
            return this.cacheLabelBBox;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "labelShape", {
        get: function () {
            var _a = this.attributes, showLabel = _a.showLabel, _b = _a.labelSpacing, labelSpacing = _b === void 0 ? 0 : _b;
            if (!showLabel)
                return { width: 0, height: 0, size: 0, len: 0 };
            var _c = this.labelBBox, width = _c.width, height = _c.height;
            var size = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;
            var len = this.ifHorizontal(width, height);
            return { width: width, height: height, size: size, len: len };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "ribbonBBox", {
        get: function () {
            var showHandle = this.attributes.showHandle;
            var _a = this.title.node().getAvailableSpace(), availableWidth = _a.width, availableHeight = _a.height;
            var _b = this.labelShape, labelSize = _b.size, labelLength = _b.len;
            var _c = tslib_1.__read(this.ifHorizontal([availableHeight, availableWidth], [availableWidth, availableHeight]), 2), availableSize = _c[0], availableLength = _c[1];
            var _d = showHandle ? this.handleShape : { size: 0, len: 0 }, handleSize = _d.size, handleLength = _d.len;
            // const handleMarkerSize = showHandle ? this.attributes.handleMarkerSize || 0 : 0;
            var handleRatio = this.handleOffsetRatio;
            var ribbonSize = 0;
            var labelPosition = this.labelPosition;
            if (['bottom', 'right'].includes(labelPosition)) {
                ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);
            }
            else if (availableSize * (1 - handleRatio) > handleSize) {
                ribbonSize = Math.max(availableSize - labelSize, 0);
            }
            else
                ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);
            var edgeLength = Math.max(handleLength, labelLength);
            var ribbonLength = availableLength - edgeLength;
            var _e = tslib_1.__read(this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]), 2), width = _e[0], height = _e[1];
            // 需要考虑 handle 的占用空间
            // todo 为了防止因为 handle 文本变化导致的 ribbon 位置变化，handle size 取最大值
            var finalLabelOccupy = ['top', 'left'].includes(labelPosition) ? labelSize : 0;
            var _f = tslib_1.__read(this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]), 2), x = _f[0], y = _f[1];
            return new util_2.BBox(x, y, width, height);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "ribbonShape", {
        get: function () {
            var _a = this.ribbonBBox, width = _a.width, height = _a.height;
            return this.ifHorizontal({ size: height, len: width }, { size: width, len: height });
        },
        enumerable: false,
        configurable: true
    });
    Continuous.prototype.renderRibbon = function (container) {
        var _a = this.attributes, type = _a.type, orient = _a.orient, color = _a.color, block = _a.block, data = _a.data;
        var style = (0, util_2.subObject)(this.attributes, 'ribbon');
        var _b = this.range, min = _b.min, max = _b.max;
        var _c = this.ribbonBBox, x = _c.x, y = _c.y;
        var _d = this.ribbonShape, len = _d.len, size = _d.size;
        this.ribbon = container
            .maybeAppendByClassName(constant_2.CLASS_NAMES.ribbon, function () { return new ribbon_1.Ribbon({}); })
            .update(tslib_1.__assign({ x: x, y: y, len: len, size: size, type: type, orient: orient, color: color, block: block, partition: data.map(function (d) { return (d.value - min) / (max - min); }), range: this.ribbonRange }, style));
    };
    Continuous.prototype.getHandleClassName = function (type) {
        // @ts-ignore
        return "".concat(constant_2.CLASS_NAMES.prefix("".concat(type, "-handle")));
    };
    Continuous.prototype.renderHandles = function () {
        var _this = this;
        var _a = this.attributes, showHandle = _a.showHandle, orient = _a.orient;
        var _b = (0, util_2.subObject)(this.attributes, 'handle'), formatter = _b.formatter, handleStyle = tslib_1.__rest(_b, ["formatter"]);
        var _c = tslib_1.__read(this.selection, 2), min = _c[0], max = _c[1];
        var style = tslib_1.__assign({ orient: orient }, handleStyle);
        var that = this;
        this.handlesGroup
            .selectAll(constant_2.CLASS_NAMES.handle.class)
            .data(showHandle
            ? [
                { value: min, type: 'start' },
                { value: max, type: 'end' },
            ]
            : [], function (d) { return d.type; })
            .join(function (enter) {
            return enter
                .append(function () { return new handle_1.Handle({}); })
                .attr('className', function (d) { return "".concat(constant_2.CLASS_NAMES.handle, " ").concat(_this.getHandleClassName(d.type)); })
                .styles(style)
                .style('labelText', function (d) { return d.value; })
                .each(function (d) {
                var handle = (0, util_2.select)(this);
                if (d.type === 'start')
                    that.startHandle = handle;
                else
                    that.endHandle = handle;
            });
        }, function (update) { return update.styles(style).style('labelText', function (d) { return d.value; }); }, function (exit) { return exit.remove(); });
    };
    Continuous.prototype.adjustHandles = function () {
        var _a = tslib_1.__read(this.selection, 2), min = _a[0], max = _a[1];
        this.setHandlePosition('start', min);
        this.setHandlePosition('end', max);
    };
    Object.defineProperty(Continuous.prototype, "handleBBox", {
        get: function () {
            if (this.cacheHandleBBox)
                return this.cacheHandleBBox;
            if (!this.attributes.showHandle)
                return new util_2.BBox(0, 0, 0, 0);
            var _a = this.startHandle.node().getBBox(), startHandleWidth = _a.width, startHandleHeight = _a.height;
            var _b = this.endHandle.node().getBBox(), endHandleWidth = _b.width, endHandleHeight = _b.height;
            var _c = tslib_1.__read([Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)], 2), width = _c[0], height = _c[1];
            this.cacheHandleBBox = new util_2.BBox(0, 0, width, height);
            return this.cacheHandleBBox;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "handleShape", {
        /**
         *  因为 handle label 的宽高是动态的，所以 handle bbox 是第一次渲染时的 bbox
         */
        get: function () {
            var _a = this.handleBBox, width = _a.width, height = _a.height;
            var _b = tslib_1.__read(this.ifHorizontal([height, width], [width, height]), 2), size = _b[0], len = _b[1];
            return { width: width, height: height, size: size, len: len };
        },
        enumerable: false,
        configurable: true
    });
    Continuous.prototype.setHandlePosition = function (type, value) {
        var handleFormatter = this.attributes.handleFormatter;
        var _a = this.ribbonBBox, ribbonX = _a.x, ribbonY = _a.y;
        var ribbonSize = this.ribbonShape.size;
        var offset = this.getOffset(value);
        var _b = tslib_1.__read(this.ifHorizontal([ribbonX + offset, ribbonY + ribbonSize * this.handleOffsetRatio], [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset]), 2), x = _b[0], y = _b[1];
        // @ts-ignore
        var handle = this.handlesGroup.select(".".concat(this.getHandleClassName(type))).node();
        handle === null || handle === void 0 ? void 0 : handle.attr('formatter', handleFormatter);
        // const [prevX, prevY] = handle.getLocalPosition();
        handle === null || handle === void 0 ? void 0 : handle.setLocalPosition(x, y);
    };
    Continuous.prototype.renderIndicator = function (container) {
        var style = (0, util_2.subObject)(this.attributes, 'indicator');
        this.indicator = container
            .maybeAppendByClassName(constant_2.CLASS_NAMES.indicator, function () { return new indicator_1.Indicator({ style: style }); })
            .update(style);
    };
    Object.defineProperty(Continuous.prototype, "labelData", {
        get: function () {
            var _this = this;
            var data = this.attributes.data;
            return data.reduce(function (acc, curr, index, arr) {
                var _a, _b;
                var id = (_a = curr === null || curr === void 0 ? void 0 : curr.id) !== null && _a !== void 0 ? _a : index.toString();
                acc.push(tslib_1.__assign(tslib_1.__assign({}, curr), { id: id, index: index, type: 'value', label: (_b = curr === null || curr === void 0 ? void 0 : curr.label) !== null && _b !== void 0 ? _b : curr.value.toString(), value: _this.ribbonScale.map(curr.value) }));
                if (index < arr.length - 1) {
                    var next = arr[index + 1];
                    var _c = tslib_1.__read([curr.value, next.value], 2), cr = _c[0], nx = _c[1];
                    var midVal = (cr + nx) / 2;
                    acc.push(tslib_1.__assign(tslib_1.__assign({}, curr), { id: id, index: index, type: 'range', range: [cr, nx], label: [cr, nx].join('~'), value: _this.ribbonScale.map(midVal) }));
                }
                return acc;
            }, []);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Continuous.prototype, "labelStyle", {
        get: function () {
            var _a = tslib_1.__read(['center', 'middle'], 2), labelTextAlign = _a[0], labelTextBaseline = _a[1];
            var labelPosition = this.labelPosition;
            if (labelPosition === 'top')
                labelTextBaseline = 'bottom';
            else if (labelPosition === 'bottom')
                labelTextBaseline = 'top';
            else if (labelPosition === 'left')
                labelTextAlign = 'end';
            else if (labelPosition === 'right')
                labelTextAlign = 'start';
            return {
                labelTextAlign: labelTextAlign,
                labelTextBaseline: labelTextBaseline,
            };
        },
        enumerable: false,
        configurable: true
    });
    Continuous.prototype.renderLabel = function (container) {
        var _a = (0, util_2.subObject)(this.attributes, 'label'), formatter = _a.formatter, filtrate = _a.filtrate, filter = _a.filter, align = _a.align, labelDirection = _a.labelDirection, tickLength = _a.tickLength, _b = _a.showTick, showTick = _b === void 0 ? false : _b, restStyle = tslib_1.__rest(_a, ["formatter", "filtrate", "filter", "align", "labelDirection", "tickLength", "showTick"]);
        var _c = tslib_1.__read((0, util_2.subObjects)(restStyle, ['tick']), 2), tickStyle = _c[0], labelStyle = _c[1];
        var style = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ type: 'linear', startPos: [0, 0], endPos: [0, 0], data: this.labelData, showLine: false, showGrid: false, showTick: showTick, tickDirection: labelDirection, labelTransform: 'rotate(0)' }, this.labelStyle), Object.fromEntries(Object.entries(tickStyle).map(function (_a) {
            var _b = tslib_1.__read(_a, 2), k = _b[0], v = _b[1];
            return ["tick".concat((0, util_2.capitalize)(k)), v];
        }))), Object.fromEntries(Object.entries(labelStyle).map(function (_a) {
            var _b = tslib_1.__read(_a, 2), k = _b[0], v = _b[1];
            return ["label".concat((0, util_2.capitalize)(k)), v];
        })));
        var functionStyle = {
            tickFilter: function (datum, index, data) {
                if ((datum === null || datum === void 0 ? void 0 : datum.type) !== 'value')
                    return false;
                if (filtrate)
                    return filtrate(datum, datum.index, data.filter(function (d) { return d.type !== 'value'; }));
                return true;
            },
            labelFilter: function (datum, index, data) {
                if ((datum === null || datum === void 0 ? void 0 : datum.type) !== align)
                    return false;
                if (filtrate)
                    return filtrate(datum, datum.index, data.filter(function (d) { return d.type === align; }));
                return true;
            },
            labelFormatter: formatter,
        };
        var finalLabelStyle = tslib_1.__assign(tslib_1.__assign({}, style), functionStyle);
        this.label = container.maybeAppendByClassName(constant_2.CLASS_NAMES.label, function () { return new axis_1.Axis({ style: finalLabelStyle }); }).node();
        this.label.update(finalLabelStyle, false);
    };
    Object.defineProperty(Continuous.prototype, "labelAxisCfg", {
        get: function () {
            var _a = this.attributes, labelDirection = _a.labelDirection, labelShowTick = _a.labelShowTick, labelSpacing = _a.labelSpacing;
            var ribbonSize = this.ribbonShape.size;
            var labelPosition = this.labelPosition;
            var labelFixedSpacing = this.labelFixedSpacing;
            var _b = tslib_1.__read([0, 0, 0], 3), offset = _b[0], spacing = _b[1], tickLength = _b[2];
            var internalVal = ribbonSize + labelSpacing;
            if (labelShowTick) {
                tickLength = internalVal;
                spacing = labelFixedSpacing;
                if (labelDirection === 'positive') {
                    if (labelPosition === 'right') {
                        offset = internalVal;
                        tickLength = internalVal;
                    }
                    else if (labelPosition === 'bottom')
                        offset = tickLength;
                }
                else if (labelDirection === 'negative') {
                    if (labelPosition === 'top')
                        offset = ribbonSize;
                    else if (labelPosition === 'left')
                        offset = ribbonSize;
                }
            }
            else if (labelDirection === 'positive') {
                if (labelPosition === 'right')
                    spacing = internalVal;
                else if (labelPosition === 'bottom') {
                    offset = ribbonSize + labelFixedSpacing;
                    spacing = labelSpacing;
                }
            }
            else if (labelDirection === 'negative') {
                if (labelPosition === 'left')
                    spacing = labelSpacing;
                else if (labelPosition === 'top')
                    spacing = labelSpacing;
            }
            return { offset: offset, spacing: spacing, tickLength: tickLength };
        },
        enumerable: false,
        configurable: true
    });
    Continuous.prototype.adjustLabel = function () {
        var showLabel = this.attributes.showLabel;
        if (!showLabel)
            return;
        var _a = this.ribbonBBox, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        var _b = this.labelAxisCfg, axisOffset = _b.offset, axisSpacing = _b.spacing, axisTickLength = _b.tickLength;
        var _c = tslib_1.__read(this.ifHorizontal([
            [x, y + axisOffset],
            [x + width, y + axisOffset],
        ], [
            [x + axisOffset, y + height],
            [x + axisOffset, y],
        ]), 2), startPos = _c[0], endPos = _c[1];
        this.label.update({
            startPos: startPos,
            endPos: endPos,
            tickLength: axisTickLength,
            labelSpacing: axisSpacing,
        }, false);
    };
    Continuous.prototype.bindEvents = function () {
        var _this = this;
        var _a, _b;
        // 如果！slidable，则不绑定事件或者事件响应不生效
        // 放置需要绑定drag事件的对象
        var dragObject = new Map();
        dragObject.set('ribbon', this.ribbon);
        dragObject.set('start', this.startHandle);
        dragObject.set('end', this.endHandle);
        // 绑定 drag 开始事件
        dragObject.forEach(function (obj, key) {
            obj === null || obj === void 0 ? void 0 : obj.on('mousedown', _this.onDragStart(key));
            obj === null || obj === void 0 ? void 0 : obj.on('touchstart', _this.onDragStart(key));
        });
        (_a = this.startHandle) === null || _a === void 0 ? void 0 : _a.on('mouseover', function () { return _this.updateMouse(); });
        (_b = this.endHandle) === null || _b === void 0 ? void 0 : _b.on('mouseover', function () { return _this.updateMouse(); });
        this.ribbon.on('mousemove', this.onHovering);
        this.addEventListener('mouseout', this.hideIndicator);
    };
    Continuous.prototype.showIndicator = function (value, text) {
        var _a;
        if (text === void 0) { text = "".concat(value); }
        var showIndicator = this.attributes.showIndicator;
        if (!showIndicator || typeof value !== 'number') {
            this.hideIndicator();
            return;
        }
        var _b = this.range, min = _b.min, max = _b.max;
        var _c = this.ribbonBBox, x = _c.x, y = _c.y;
        var safeValue = (0, util_1.clamp)(value, min, max);
        var offset = this.getOffset(safeValue);
        var pos = this.ifHorizontal([offset + x, y], [x, offset + y]);
        this.indicator.update({
            visibility: 'visible',
            position: this.ifHorizontal('top', 'left'),
            value: text,
        });
        (_a = this.indicator.node()).setLocalPosition.apply(_a, tslib_1.__spreadArray([], tslib_1.__read(pos), false));
    };
    Continuous.prototype.hideIndicator = function () {
        var _a;
        (_a = this.indicator) === null || _a === void 0 ? void 0 : _a.style('visibility', 'hidden');
    };
    Continuous.prototype.updateMouse = function () {
        if (this.style.slidable)
            this.style.cursor = 'grabbing';
    };
    Continuous.prototype.setSelection = function (start, end) {
        this.updateSelection(start, end);
    };
    Continuous.prototype.updateSelection = function (stVal, endVal, isOffset) {
        var _a;
        if (isOffset === void 0) { isOffset = false; }
        var _b = tslib_1.__read(this.selection, 2), currSt = _b[0], currEnd = _b[1];
        var _c = tslib_1.__read([stVal, endVal], 2), start = _c[0], end = _c[1];
        if (isOffset) {
            // 获取当前值
            start += currSt;
            end += currEnd;
        }
        // 值校验
        var _d = this.range, min = _d.min, max = _d.max;
        _a = tslib_1.__read((0, utils_2.getSafetySelections)([min, max], [start, end], this.selection), 2), start = _a[0], end = _a[1];
        this.update({ defaultValue: [start, end] });
        this.dispatchSelection();
    };
    Object.defineProperty(Continuous.prototype, "step", {
        get: function () {
            var _a = this.attributes.step, step = _a === void 0 ? 1 : _a;
            var _b = this.range, min = _b.min, max = _b.max;
            if ((0, util_1.isUndefined)(step))
                return (0, util_2.toPrecision)((max - min) * constant_2.STEP_RATIO, 0);
            return step;
        },
        enumerable: false,
        configurable: true
    });
    Continuous.prototype.getTickValue = function (value) {
        var _a = this.attributes, data = _a.data, block = _a.block;
        var min = this.range.min;
        if (block)
            return (0, utils_1.getNextTickValue)(data.map(function (_a) {
                var value = _a.value;
                return value;
            }), value).tick;
        return (0, utils_2.getStepValueByValue)(value, this.step, min);
    };
    /**
     * 事件触发的位置对应的value值
     * @param limit {boolean} 我也忘了要干啥了
     */
    Continuous.prototype.getValueByCanvasPoint = function (e, limit) {
        if (limit === void 0) { limit = false; }
        var _a = this.range, min = _a.min, max = _a.max;
        var _b = tslib_1.__read(this.ribbon.node().getPosition(), 2), x = _b[0], y = _b[1];
        var startPos = this.ifHorizontal(x, y);
        var currValue = this.ifHorizontal.apply(this, tslib_1.__spreadArray([], tslib_1.__read((0, util_2.getEventPos)(e)), false));
        var offset = currValue - startPos;
        var value = (0, util_1.clamp)(this.getOffset(offset, true), min, max);
        return value;
    };
    /** reverse: 屏幕偏移量 -> 值 */
    Continuous.prototype.getOffset = function (value, reverse) {
        if (reverse === void 0) { reverse = false; }
        var _a = this.range, min = _a.min, max = _a.max;
        var ribbonLen = this.ribbonShape.len;
        var scale = this.eventToOffsetScale;
        scale.update({ domain: [min, max], range: [0, ribbonLen] });
        if (reverse)
            return scale.invert(value);
        return scale.map(value);
    };
    Continuous.prototype.dispatchSelection = function () {
        var evt = new g_1.CustomEvent('valuechange', {
            detail: {
                value: this.selection,
            },
        });
        this.dispatchEvent(evt);
    };
    Continuous.prototype.dispatchIndicated = function (value, range) {
        var evt = new g_1.CustomEvent('indicate', {
            detail: { value: value, range: range },
        });
        this.dispatchEvent(evt);
    };
    tslib_1.__decorate([
        (0, util_2.throttle)(100)
    ], Continuous.prototype, "dispatchSelection", null);
    tslib_1.__decorate([
        (0, util_2.throttle)(100)
    ], Continuous.prototype, "dispatchIndicated", null);
    return Continuous;
}(gui_1.GUI));
exports.Continuous = Continuous;
//# sourceMappingURL=continuous.js.map