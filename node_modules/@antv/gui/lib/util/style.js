"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.styleSeparator = exports.superObject = exports.subObjects = exports.subObject = exports.applyStyleSheet = exports.getStateStyle = exports.getDefaultStyle = exports.TEXT_INHERITABLE_PROPS = void 0;
var tslib_1 = require("tslib");
var util_1 = require("@antv/util");
var constant_1 = require("../constant");
var filter_transform_1 = require("./filter-transform");
/**
 * 以下属性都是可继承的，这意味着没有显式定义（值为 unset）时，是需要从未来的祖先节点中计算得到的。
 * 因此 Text 在创建之后立刻调用 getBounds 等方法获取包围盒是不准确的（例如 getShapeSpace 方法）。
 *
 * 目前 GUI 里这么做通常是为了布局。但理想的做法是使用布局属性（例如 BoxFlow 中的 margin / padding，Flex 布局的 flex 等），
 * 正如在浏览器中我们很少使用 getBoundingClientRect 而更多使用 `display: block/flex/grids`，
 * 这样可以避免手动计算（如何计算以及计算时机只有 浏览器/G 最清楚）。
 *
 * 暂时在布局实现前，先通过显式定义的值绕开该问题，当然这也放弃了继承特性（例如根节点上的 fontSize 修改也影响不到了）。
 *
 * 继承机制 & 默认值 @see https://g-next.antv.vision/zh/docs/api/css/inheritance
 */
exports.TEXT_INHERITABLE_PROPS = {
    fontSize: '16px',
    fontFamily: 'sans-serif',
    fontWeight: 'normal',
    fontVariant: 'normal',
    fontStyle: 'normal',
    textAlign: 'start',
    textBaseline: 'alphabetic',
};
/**
 * 从带状态样式中返回移除了状态样式的默认样式
 */
// @ts-ignore
function getDefaultStyle(style) {
    if (style === undefined)
        ({});
    if (style) {
        return style === null || style === void 0 ? void 0 : style.default;
    }
    var duplicateStyle = (0, util_1.clone)(style) || {};
    // 移除其他带状态的样式得到默认样式
    constant_1.STATE_LIST.forEach(function (state) {
        if (state in duplicateStyle)
            delete duplicateStyle[state];
    });
    return duplicateStyle;
}
exports.getDefaultStyle = getDefaultStyle;
/**
 * 对于格式为:
 * style: ShapeAttrs & {
 *  [state: string]?: ShapeAttrs,
 * }
 * 的带状态样式，根据状态提取出样式
 * 默认返回默认样式
 * @param style 混合样式
 * @param state 状态
 * @param isMerge 是否将状态样式与默认样式合并
 */
// @ts-ignore
function getStateStyle(style, state, isMerge) {
    if (isMerge === void 0) { isMerge = false; }
    if (!state) {
        var temp = getDefaultStyle(style);
        if (temp)
            return temp;
        return {};
    }
    var stateStyle = (0, util_1.get)(style, state);
    if (isMerge) {
        return (0, util_1.deepMix)({}, getDefaultStyle(style), stateStyle);
    }
    return stateStyle;
}
exports.getStateStyle = getStateStyle;
/**
 * 对给定HTML对象应用给定样式
 * @param style {[key: string]: Object}
 * 样式表参考结构
 * {
 *  '.selector': {
 *   'attrName': 'attr',
 *   'padding': '0 0 0 0',
 *   'background-color': 'red'
 *  }
 * }
 */
function applyStyleSheet(element, style) {
    Object.entries(style).forEach(function (_a) {
        var _b = tslib_1.__read(_a, 2), selector = _b[0], styleString = _b[1];
        // apply styles to element and children
        tslib_1.__spreadArray([element], tslib_1.__read(element.querySelectorAll(selector)), false).filter(function (el) { return el.matches(selector); })
            .forEach(function (target) {
            if (!target)
                return;
            var temp = target;
            temp.style.cssText += Object.entries(styleString).reduce(function (total, currVal) {
                return "".concat(total).concat(currVal.join(':'), ";");
            }, '');
        });
    });
}
exports.applyStyleSheet = applyStyleSheet;
/**
 *
 * @param style
 * @param prefix
 * @param invert get the reset style
 * @param transform enable filter transform
 * @returns
 */
function subObject(style, prefix, invert, transform) {
    if (invert === void 0) { invert = false; }
    if (transform === void 0) { transform = true; }
    var internalStyle = transform ? (0, filter_transform_1.filterTransform)(style) : style;
    var startsWith = function (str, prefix) { return new RegExp("^".concat(prefix, "[A-Z].*")).test(str); };
    var capitalizeFirstLetter = function (str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    };
    return Object.keys(internalStyle).reduce(function (acc, curr) {
        if (startsWith(curr, prefix) !== invert) {
            if (invert)
                acc[curr] = internalStyle[curr];
            else
                acc[capitalizeFirstLetter(curr.slice(prefix.length))] = internalStyle[curr];
        }
        return acc;
    }, {});
}
exports.subObject = subObject;
function subObjects(style, prefix) {
    var internalStyle = style;
    var finalStyle = Object.keys(style).reduce(function (acc, curr, index) {
        if (index >= prefix.length)
            return acc;
        var pre = prefix[index];
        acc.push(subObject(internalStyle, pre));
        internalStyle = subObject(internalStyle, pre, true);
        return acc;
    }, []);
    finalStyle.push(internalStyle);
    return finalStyle;
}
exports.subObjects = subObjects;
/**
 * add prefix to style
 * @param style
 * @param prefix
 */
function superObject(style, prefix) {
    var capitalizeFirstLetter = function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    };
    return Object.keys(style).reduce(function (acc, curr) {
        acc["".concat(prefix).concat(capitalizeFirstLetter(curr))] = style[curr];
        return acc;
    }, {});
}
exports.superObject = superObject;
/**
 * extract group style from mixin style
 * @param style
 * @param ignoreStyleDict style will be ignore from style
 * @returns shape style and rest style
 */
function styleSeparator(style, ignoreStyleDict) {
    if (ignoreStyleDict === void 0) { ignoreStyleDict = ['x', 'y', 'class']; }
    var groupStyleDict = [
        'transform',
        'transformOrigin',
        'anchor',
        'visibility',
        'pointerEvents',
        'zIndex',
        'cursor',
        'clipPath',
        'clipPathTargets',
        'offsetPath',
        'offsetPathTargets',
        'offsetDistance',
        'draggable',
        'droppable',
    ];
    var output = {};
    var groupStyle = {};
    Object.entries(style).forEach(function (_a) {
        var _b = tslib_1.__read(_a, 2), key = _b[0], val = _b[1];
        if (ignoreStyleDict.includes(key)) {
            // do nothing
        }
        else if (groupStyleDict.indexOf(key) !== -1)
            groupStyle[key] = val;
        else
            output[key] = val;
    });
    return [output, groupStyle];
}
exports.styleSeparator = styleSeparator;
//# sourceMappingURL=style.js.map