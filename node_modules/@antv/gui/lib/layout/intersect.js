"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.intersect = exports.IntersectUtils = void 0;
var tslib_1 = require("tslib");
var util_1 = require("../util");
var bounds_1 = require("./bounds");
/**
 * Detect whether line-line collision.
 * From: https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
 */
function lineToLine(line1, line2) {
    var _a = tslib_1.__read(line1, 4), x0 = _a[0], y0 = _a[1], x1 = _a[2], y1 = _a[3];
    var _b = tslib_1.__read(line2, 4), x2 = _b[0], y2 = _b[1], x3 = _b[2], y3 = _b[3];
    var s10x = x1 - x0;
    var s10y = y1 - y0;
    var s32x = x3 - x2;
    var s32y = y3 - y2;
    var denom = s10x * s32y - s32x * s10y;
    if (denom === 0)
        return false;
    var denomPositive = denom > 0;
    var s02x = x0 - x2;
    var s02y = y0 - y2;
    var sNum = s10x * s02y - s10y * s02x;
    if (sNum < 0 === denomPositive)
        return false;
    var tNum = s32x * s02y - s32y * s02x;
    if (tNum < 0 === denomPositive)
        return false;
    if (sNum > denom === denomPositive || tNum > denom === denomPositive)
        return false;
    return true;
}
function intersectBoxLine(box /** 八个顶点 */, line) {
    var lines = [
        [box[0], box[1], box[2], box[3]],
        [box[2], box[3], box[4], box[5]],
        [box[4], box[5], box[6], box[7]],
        [box[6], box[7], box[0], box[1]],
    ];
    return lines.some(function (boxLine) { return lineToLine(line, boxLine); });
}
function bound(bounds, item, margin) {
    if (margin === void 0) { margin = [0, 0, 0, 0]; }
    var angle = item.getEulerAngles() || 0;
    item.setEulerAngles(0);
    // get dimensions
    var _a = item.getLocalBounds(), min = _a.min, max = _a.max, halfExtents = _a.halfExtents;
    var left = min[0];
    var w = halfExtents[0] * 2;
    var h = halfExtents[1] * 2;
    var x = left;
    var y = min[1];
    var right = max[0];
    var bottom = max[1];
    var height = h;
    var dx = 0;
    var dy = 0;
    var anchorX = x;
    var anchorY = y;
    if (item.tagName === 'text') {
        // [to fix] 目前 G 上计算 bbox 有一点误差
        height -= 1.5;
        var a = item.style.textAlign;
        var b_1 = item.style.textBaseline;
        dx = +item.style.dx;
        dy = +item.style.dy;
        // horizontal alignment
        if (a === 'center') {
            anchorX = (x + right) / 2;
        }
        else if (a === 'right' || a === 'end') {
            anchorX = right;
        }
        else {
            // left by default, do nothing
        }
        // vertical alignment
        if (b_1 === 'middle') {
            anchorY = (y + bottom) / 2;
        }
        else if (b_1 === 'bottom' || b_1 === 'baseline') {
            anchorY = bottom;
        }
    }
    var _b = tslib_1.__read(margin, 4), _c = _b[0], t = _c === void 0 ? 0 : _c, _d = _b[1], r = _d === void 0 ? 0 : _d, _e = _b[2], b = _e === void 0 ? t : _e, _f = _b[3], l = _f === void 0 ? r : _f;
    bounds.set((dx += x) - l, (dy += y) - t, dx + w + r, dy + height + b);
    item.setEulerAngles(angle);
    return bounds.rotatedPoints((0, util_1.degToRad)(angle), anchorX, anchorY);
}
exports.IntersectUtils = { lineToLine: lineToLine, intersectBoxLine: intersectBoxLine, bound: bound };
function intersect(a, b, margin) {
    var p = bound(new bounds_1.Bounds(), a, margin);
    var q = bound(new bounds_1.Bounds(), b, margin);
    var result = intersectBoxLine(q, [p[0], p[1], p[2], p[3]]) ||
        intersectBoxLine(q, [p[0], p[1], p[4], p[5]]) ||
        intersectBoxLine(q, [p[4], p[5], p[6], p[7]]) ||
        intersectBoxLine(q, [p[2], p[3], p[6], p[7]]);
    return result;
}
exports.intersect = intersect;
//# sourceMappingURL=intersect.js.map