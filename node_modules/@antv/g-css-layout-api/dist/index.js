'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// export const ContextNode = Syringe.defineToken('');
var FragmentResult = function FragmentResult(_layoutContext, _node, options) {
  this._layoutContext = void 0;
  this._node = void 0;
  this.options = void 0;
  this.layoutContext = void 0;
  this.inlineSize = void 0;
  this.blockSize = void 0;
  this.node = void 0;
  this.childFragments = void 0;
  this.data = void 0;
  this._layoutContext = _layoutContext;
  this._node = _node;
  this.options = options;
  this.layoutContext = _layoutContext;
  this.inlineSize = options === null || options === void 0 ? void 0 : options.inlineSize;
  this.blockSize = options === null || options === void 0 ? void 0 : options.blockSize;
  this.childFragments = options === null || options === void 0 ? void 0 : options.childFragments;
  this.data = options.data;
  this.node = _node;
};

(function (LayoutTaskType) {
  LayoutTaskType["Layout"] = "layout";
  LayoutTaskType["IntrinsicSizes"] = "intrinsic-sizes";
})(exports.LayoutTaskType || (exports.LayoutTaskType = {}));
var ChildDisplayType;
(function (ChildDisplayType) {
  ChildDisplayType[ChildDisplayType["block"] = 0] = "block";
  ChildDisplayType[ChildDisplayType["normal"] = 1] = "normal";
})(ChildDisplayType || (ChildDisplayType = {}));
var LayoutSizingMode;
(function (LayoutSizingMode) {
  LayoutSizingMode[LayoutSizingMode["block-like"] = 0] = "block-like";
  LayoutSizingMode[LayoutSizingMode["manual"] = 1] = "manual";
})(LayoutSizingMode || (LayoutSizingMode = {}));
(function (PropertyName) {
  PropertyName["LAYOUT"] = "display";
  PropertyName["LEFT"] = "left";
  PropertyName["TOP"] = "top";
  PropertyName["BOTTOM"] = "bottom";
  PropertyName["RIGHT"] = "right";
  PropertyName["WIDTH"] = "width";
  PropertyName["HEIGHT"] = "height";
  PropertyName["MIN_WIDTH"] = "minWidth";
  PropertyName["MAX_WIDTH"] = "maxWidth";
  PropertyName["MIN_HEIGHT"] = "minHeight";
  PropertyName["MAX_HEIGHT"] = "maxHeight";
  PropertyName["BOX_SIZING"] = "boxSizing";
  PropertyName["PADDING"] = "padding";
  PropertyName["PADDING_TOP"] = "paddingTop";
  PropertyName["PADDING_BOTTOM"] = "paddingBottom";
  PropertyName["PADDING_START"] = "paddingLeft";
  PropertyName["PADDING_END"] = "paddingRight";
  PropertyName["MARGIN"] = "margin";
  PropertyName["MARGIN_TOP"] = "marginTop";
  PropertyName["MARGIN_BOTTOM"] = "marginBottom";
  PropertyName["MARGIN_START"] = "marginLeft";
  PropertyName["MARGIN_END"] = "marginRight";
  PropertyName["BORDER"] = "border";
  PropertyName["BORDER_TOP"] = "borderTop";
  PropertyName["BORDER_BOTTOM"] = "borderBottom";
  PropertyName["BORDER_START"] = "borderLeft";
  PropertyName["BORDER_END"] = "borderRight";
  PropertyName["FLEX_DIRECTION"] = "flexDirection";
  PropertyName["FLEX_WRAP"] = "flexWrap";
  PropertyName["FLEX_FLOW"] = "flexFlow";
  PropertyName["ALIGN_ITEMS"] = "alignItems";
  PropertyName["ALIGN_CONTENT"] = "alignContent";
  PropertyName["JUSTIFY_CONTENT"] = "justifyContent";
  PropertyName["FLEX"] = "flex";
  PropertyName["ALIGN_SELF"] = "alignSelf";
  PropertyName["FLEX_SHRINK"] = "flexShrink";
  PropertyName["FLEX_BASIS"] = "flexBasis";
  PropertyName["FLEX_GROW"] = "flexGrow";
  PropertyName["OFFSET_WIDTH"] = "offsetWidth";
  PropertyName["OFFSET_HEIGHT"] = "offsetHeight";
  PropertyName["ORDER"] = "order";
})(exports.PropertyName || (exports.PropertyName = {}));

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

/**
 * This function allow you to modify a JS Promise by adding some status properties.
 * Based on: http://stackoverflow.com/questions/21485545/is-there-a-way-to-tell-if-an-es6-promise-is-fulfilled-rejected-resolved
 * But modified according to the specs of promises : https://promisesaplus.com/
 */
var makeQuerablePromise = function makeQuerablePromise(promise) {
  // Don't modify any promise that has been already modified.
  if (promise.isRejected || promise.isFulfilled) return promise;
  // Set initial state
  var isPending = true;
  var isRejected = false;
  var isFulfilled = false;
  var fullFilledValue;
  // Observe the promise, saving the fulfillment in a closure scope.
  var result = promise.then(function (v) {
    isFulfilled = true;
    isPending = false;
    fullFilledValue = v;
    return v;
  }, function (e) {
    isRejected = true;
    isPending = false;
    throw e;
  });
  result.isFulfilled = function () {
    return isFulfilled;
  };
  result.isPending = function () {
    return isPending;
  };
  result.isRejected = function () {
    return isRejected;
  };
  result.getFullFilledValue = function () {
    return fullFilledValue;
  };
  return result;
};
/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
var Deferred = function Deferred() {
  var _this = this;
  this.resolve = void 0;
  this.reject = void 0;
  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
};

var LayoutChildren = /*#__PURE__*/function () {
  function LayoutChildren(_layoutContext, options) {
    this._layoutContext = void 0;
    this.options = void 0;
    this.node = void 0;
    this.styleMap = void 0;
    this.layoutContext = void 0;
    this._layoutContext = _layoutContext;
    this.options = options;
    this.layoutContext = _layoutContext;
    this.node = options.node;
    this.styleMap = options.node.getAllStyle();
  }
  var _proto = LayoutChildren.prototype;
  _proto.intrinsicSizes = function intrinsicSizes() {
    // if (this.contextId !== this.layoutContext.contextId) {
    //   throw new Error('Invalid State: wrong layout context');
    // }
    var deferred = new Deferred();
    this.layoutContext.appendWorkTask({
      layoutChild: this,
      taskType: exports.LayoutTaskType.IntrinsicSizes,
      deferred: deferred
    });
    return deferred.promise;
  };
  _proto.layoutNextFragment = function layoutNextFragment(constraints) {
    // if (this.layoutContext.contextId !== this.layoutContext.contextId) {
    //   throw new Error('Invalid State: wrong layout context');
    // }
    if (this.layoutContext.mode === exports.LayoutTaskType.IntrinsicSizes) {
      throw new Error('Not Supported: cant call layoutNextFragment in intrinsicSizes');
    }
    var deferred = new Deferred();
    this.layoutContext.appendWorkTask({
      layoutConstraints: constraints,
      layoutChild: this,
      taskType: exports.LayoutTaskType.Layout,
      deferred: deferred
    });
    return deferred.promise;
  };
  return LayoutChildren;
}();

var guid = 0;
/**
 * 每次layout 有单独的 context
 */
var LayoutContext = /*#__PURE__*/function () {
  function LayoutContext(options) {
    this.options = void 0;
    this.contextId = void 0;
    this.workQueue = [];
    this.mode = void 0;
    this.layoutChildrenFactory = void 0;
    this.fragmentResultFactory = void 0;
    this.layoutFragmentFactory = void 0;
    this.options = options;
    this.contextId = "" + guid++;
    this.mode = options.mode;
    this.layoutChildrenFactory = options.layoutChildrenFactory;
    this.fragmentResultFactory = options.fragmentResultFactory;
    this.layoutFragmentFactory = options.layoutFragmentFactory;
  }
  var _proto = LayoutContext.prototype;
  _proto.appendWorkTask = function appendWorkTask(work) {
    this.workQueue.push(work);
  };
  _proto.clearWorkQueue = function clearWorkQueue() {
    this.workQueue = [];
  };
  return LayoutContext;
}();

var AbstractLayoutDefinition = function AbstractLayoutDefinition() {};
AbstractLayoutDefinition.inputProperties = void 0;
AbstractLayoutDefinition.childrenInputProperties = void 0;
AbstractLayoutDefinition.layoutOptions = void 0;

var SCROLLBAR_SIZES = [0, 0, 0, 0];
/**
 * https://drafts.css-houdini.org/css-layout-api/#layoutedges
 * the size of border, scrollbar, padding
 */
var LayoutEdges =
// Convenience attributes for the sum in one direction.

function LayoutEdges(options) {
  var _styleMap$get$value, _styleMap$get, _styleMap$get$value2, _styleMap$get2, _styleMap$get$value3, _styleMap$get3, _styleMap$get$value4, _styleMap$get4, _styleMap$get$value5, _styleMap$get5, _styleMap$get$value6, _styleMap$get6, _styleMap$get$value7, _styleMap$get7, _styleMap$get$value8, _styleMap$get8;
  this.options = void 0;
  this.inlineStart = void 0;
  this.inlineEnd = void 0;
  this.blockStart = void 0;
  this.blockEnd = void 0;
  this.inline = void 0;
  this.block = void 0;
  this.options = options;
  var node = options.node;
  var styleMap = node.getAllStyle();
  var borderTopWidth = (_styleMap$get$value = (_styleMap$get = styleMap.get(exports.PropertyName.PADDING_TOP)) === null || _styleMap$get === void 0 ? void 0 : _styleMap$get.value) !== null && _styleMap$get$value !== void 0 ? _styleMap$get$value : 0;
  var borderRightWidth = (_styleMap$get$value2 = (_styleMap$get2 = styleMap.get(exports.PropertyName.PADDING_END)) === null || _styleMap$get2 === void 0 ? void 0 : _styleMap$get2.value) !== null && _styleMap$get$value2 !== void 0 ? _styleMap$get$value2 : 0;
  var borderBottomWidth = (_styleMap$get$value3 = (_styleMap$get3 = styleMap.get(exports.PropertyName.PADDING_BOTTOM)) === null || _styleMap$get3 === void 0 ? void 0 : _styleMap$get3.value) !== null && _styleMap$get$value3 !== void 0 ? _styleMap$get$value3 : 0;
  var borderLeftWidth = (_styleMap$get$value4 = (_styleMap$get4 = styleMap.get(exports.PropertyName.PADDING_START)) === null || _styleMap$get4 === void 0 ? void 0 : _styleMap$get4.value) !== null && _styleMap$get$value4 !== void 0 ? _styleMap$get$value4 : 0;
  var paddingTopWidth = (_styleMap$get$value5 = (_styleMap$get5 = styleMap.get(exports.PropertyName.PADDING_TOP)) === null || _styleMap$get5 === void 0 ? void 0 : _styleMap$get5.value) !== null && _styleMap$get$value5 !== void 0 ? _styleMap$get$value5 : 0;
  var paddingRightWidth = (_styleMap$get$value6 = (_styleMap$get6 = styleMap.get(exports.PropertyName.PADDING_END)) === null || _styleMap$get6 === void 0 ? void 0 : _styleMap$get6.value) !== null && _styleMap$get$value6 !== void 0 ? _styleMap$get$value6 : 0;
  var paddingBottomWidth = (_styleMap$get$value7 = (_styleMap$get7 = styleMap.get(exports.PropertyName.PADDING_BOTTOM)) === null || _styleMap$get7 === void 0 ? void 0 : _styleMap$get7.value) !== null && _styleMap$get$value7 !== void 0 ? _styleMap$get$value7 : 0;
  var paddingLeftWidth = (_styleMap$get$value8 = (_styleMap$get8 = styleMap.get(exports.PropertyName.PADDING_START)) === null || _styleMap$get8 === void 0 ? void 0 : _styleMap$get8.value) !== null && _styleMap$get$value8 !== void 0 ? _styleMap$get$value8 : 0;
  this.blockStart = borderTopWidth + SCROLLBAR_SIZES[0] + paddingTopWidth;
  this.inlineStart = borderRightWidth + SCROLLBAR_SIZES[1] + paddingRightWidth;
  this.blockEnd = borderBottomWidth + SCROLLBAR_SIZES[2] + paddingBottomWidth;
  this.inlineEnd = borderLeftWidth + SCROLLBAR_SIZES[3] + paddingLeftWidth;
  this.block = this.blockStart + this.blockEnd;
  this.inline = this.inlineStart + this.inlineEnd;
};

var delay = function delay(minisecond) {
  if (minisecond === void 0) {
    minisecond = 0;
  }
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve();
    }, minisecond);
  });
};
var LayoutEngine = /*#__PURE__*/function () {
  function LayoutEngine(_layoutRegistry, _layoutContextFactory, _layoutEdgesFactory) {
    this._layoutRegistry = void 0;
    this._layoutContextFactory = void 0;
    this._layoutEdgesFactory = void 0;
    this.layoutRegistry = void 0;
    this.layoutContextFactory = void 0;
    this.layoutEdgesFactory = void 0;
    this._layoutRegistry = _layoutRegistry;
    this._layoutContextFactory = _layoutContextFactory;
    this._layoutEdgesFactory = _layoutEdgesFactory;
    this.layoutRegistry = _layoutRegistry;
    this.layoutContextFactory = _layoutContextFactory;
    this.layoutEdgesFactory = _layoutEdgesFactory;
    // layoutContributions.getContributions().forEach((layoutContrib) => {
    //   layoutContrib.registerLayout(_layoutRegistry);
    // });
  }
  /**
   * This function takes the root of the box-tree, a LayoutConstraints object, and compute the position of every node in the tree
   * @param rootNode root node of the layout object tree
   * @param rootPageConstraints layout constraints
   * @returns
   */
  var _proto = LayoutEngine.prototype;
  _proto.computeLayout =
  /*#__PURE__*/
  function () {
    var _computeLayout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(rootNode, rootPageConstraints) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.determineIntrinsicSizes(rootNode, rootNode.children);
            case 2:
              _context.next = 4;
              return this.calculateLayout(rootNode, rootNode.children, rootPageConstraints);
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function computeLayout(_x, _x2) {
      return _computeLayout.apply(this, arguments);
    }
    return computeLayout;
  }()
  /**
   * calculate intrinsicSize of node tree, use depth dirst / post order traversal
   * @param rootNode
   */
  ;
  _proto.determineAllIntrinsicSizes =
  /*#__PURE__*/
  function () {
    var _determineAllIntrinsicSizes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(rootNode) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    function determineAllIntrinsicSizes(_x3) {
      return _determineAllIntrinsicSizes.apply(this, arguments);
    }
    return determineAllIntrinsicSizes;
  }();
  _proto.getLayoutDefinitionName = function getLayoutDefinitionName(node) {
    var layoutStyle = node.getAllStyle().get(exports.PropertyName.LAYOUT);
    if (!layoutStyle) {
      throw new Error('layout property not found');
    }
    return layoutStyle.value;
  }
  /**
   * calculate the min/max content size of node
   * @param node current layout object
   * @param childNodes children of the current node
   */;
  _proto.determineIntrinsicSizes =
  /*#__PURE__*/
  function () {
    var _determineIntrinsicSizes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(node, childNodes) {
      var layoutName;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              layoutName = this.getLayoutDefinitionName(node);
              _context3.next = 3;
              return this.invokeIntrinsicSizesCallback(layoutName, node, childNodes);
            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
    function determineIntrinsicSizes(_x4, _x5) {
      return _determineIntrinsicSizes.apply(this, arguments);
    }
    return determineIntrinsicSizes;
  }();
  _proto.invokeIntrinsicSizesCallback = /*#__PURE__*/function () {
    var _invokeIntrinsicSizesCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(layoutName, node, childNodes) {
      var LayoutDef, layoutInstance, context, _LayoutDef$inputPrope, inputProperties, children, edges, styleMap, value, generator, intrinsicSizesValue;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              LayoutDef = this.layoutRegistry.getLayout(layoutName);
              layoutInstance = new LayoutDef();
              context = this.layoutContextFactory({
                mode: exports.LayoutTaskType.IntrinsicSizes
              });
              _LayoutDef$inputPrope = LayoutDef.inputProperties, inputProperties = _LayoutDef$inputPrope === void 0 ? [] : _LayoutDef$inputPrope;
              children = [];
              childNodes.forEach(function (childNode) {
                var layoutChild = context.layoutChildrenFactory({
                  node: childNode
                });
                children.push(layoutChild);
              });
              edges = this.layoutEdgesFactory({
                node: node
              });
              styleMap = node.getStyle.apply(node, inputProperties); // TODO compare to cache ( children edges styleMap )
              value = layoutInstance.intrinsicSizes(children, edges, styleMap);
              generator = this.runWorkQueue(value, context.workQueue);
              generator.next();
              _context4.next = 13;
              return delay();
            case 13:
              intrinsicSizesValue = generator.next().value;
              context.clearWorkQueue();
              node.setIntrisicSizes(intrinsicSizesValue);
            case 16:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));
    function invokeIntrinsicSizesCallback(_x6, _x7, _x8) {
      return _invokeIntrinsicSizesCallback.apply(this, arguments);
    }
    return invokeIntrinsicSizesCallback;
  }();
  _proto.calculateLayout = /*#__PURE__*/function () {
    var _calculateLayout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(node, childNodes, layoutConstraints) {
      var layoutName;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              layoutName = this.getLayoutDefinitionName(node);
              _context5.next = 3;
              return this.invokeLayoutCallback(layoutName, node, childNodes, layoutConstraints);
            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));
    function calculateLayout(_x9, _x10, _x11) {
      return _calculateLayout.apply(this, arguments);
    }
    return calculateLayout;
  }();
  _proto.invokeLayoutCallback = /*#__PURE__*/function () {
    var _invokeLayoutCallback = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(layoutName, node, childNodes, layoutConstraints) {
      var LayoutDef, layoutInstance, context, _LayoutDef$inputPrope2, inputProperties, children, edges, styleMap, value, generator, fragmentResultvalue, fragmentResult, layoutFragment;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              LayoutDef = this.layoutRegistry.getLayout(layoutName);
              layoutInstance = new LayoutDef();
              context = this.layoutContextFactory({
                mode: exports.LayoutTaskType.Layout
              });
              _LayoutDef$inputPrope2 = LayoutDef.inputProperties, inputProperties = _LayoutDef$inputPrope2 === void 0 ? [] : _LayoutDef$inputPrope2;
              children = [];
              childNodes.forEach(function (childNode) {
                var layoutChild = context.layoutChildrenFactory({
                  node: childNode
                });
                children.push(layoutChild);
              });
              edges = this.layoutEdgesFactory({
                node: node
              });
              styleMap = node.getStyle.apply(node, inputProperties); // TODO compare to cache ( children styleMap layoutConstraints )
              value = layoutInstance.layout(children, edges, layoutConstraints, styleMap);
              generator = this.runWorkQueue(value, context.workQueue);
              generator.next();
              _context6.next = 13;
              return delay();
            case 13:
              fragmentResultvalue = generator.next().value;
              context.clearWorkQueue();
              fragmentResult = fragmentResultvalue instanceof FragmentResult ? fragmentResultvalue : context.fragmentResultFactory(fragmentResultvalue);
              layoutFragment = context.layoutFragmentFactory({
                inlineSize: fragmentResult.inlineSize,
                blockSize: fragmentResult.blockSize,
                data: fragmentResult.data
              });
              node.setComputedLayout(layoutFragment);
              childNodes.forEach(function (childNode, index) {
                childNode.setComputedLayout(fragmentResult.childFragments[index]);
              });
            case 19:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));
    function invokeLayoutCallback(_x12, _x13, _x14, _x15) {
      return _invokeLayoutCallback.apply(this, arguments);
    }
    return invokeLayoutCallback;
  }();
  _proto.runWorkQueue = /*#__PURE__*/_regeneratorRuntime().mark(function runWorkQueue(promise, workQueue) {
    var _this = this;
    var querablePromise;
    return _regeneratorRuntime().wrap(function runWorkQueue$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            querablePromise = makeQuerablePromise(promise);
            if (workQueue.length > 0 && querablePromise.isPending()) {
              workQueue.forEach(function (workTask) {
                if (workTask.taskType === exports.LayoutTaskType.IntrinsicSizes) {
                  var layoutChild = workTask.layoutChild,
                    deferred = workTask.deferred;
                  var node = layoutChild.node;
                  deferred.resolve(_this.getNodeIntrisicSizes(node));
                }
                if (workTask.taskType === exports.LayoutTaskType.Layout) {
                  var _layoutChild = workTask.layoutChild,
                    _deferred = workTask.deferred,
                    layoutConstraints = workTask.layoutConstraints;
                  var _node = _layoutChild.node,
                    layoutContext = _layoutChild.layoutContext;
                  var fragment = _this.getNodeFragment(_node, layoutConstraints);
                  _deferred.resolve(layoutContext.layoutFragmentFactory(fragment));
                }
              });
            }
            // wait promise to resolve
            _context7.next = 4;
            return;
          case 4:
            if (querablePromise.isFulfilled()) {
              _context7.next = 6;
              break;
            }
            throw new Error('promise not fullfilled!');
          case 6:
            return _context7.abrupt("return", querablePromise.getFullFilledValue());
          case 7:
          case "end":
            return _context7.stop();
        }
      }
    }, runWorkQueue);
  });
  _proto.getNodeIntrisicSizes = function getNodeIntrisicSizes(node) {
    var _styleMap$get, _node$intrisicSizes, _styleMap$get2, _styleMap$get3, _node$intrisicSizes2, _styleMap$get4, _styleMap$get5, _node$intrisicSizes3, _styleMap$get6, _styleMap$get7, _node$intrisicSizes4, _styleMap$get8;
    // calculate from border box, depend on writing mode of current layout
    var styleMap = node.getAllStyle();
    var minWidth = ((_styleMap$get = styleMap.get(exports.PropertyName.MIN_WIDTH)) === null || _styleMap$get === void 0 ? void 0 : _styleMap$get.value) || ((_node$intrisicSizes = node.intrisicSizes) === null || _node$intrisicSizes === void 0 ? void 0 : _node$intrisicSizes.minContentInlineSize) || ((_styleMap$get2 = styleMap.get(exports.PropertyName.WIDTH)) === null || _styleMap$get2 === void 0 ? void 0 : _styleMap$get2.value) || 0;
    var maxWidth = ((_styleMap$get3 = styleMap.get(exports.PropertyName.MAX_WIDTH)) === null || _styleMap$get3 === void 0 ? void 0 : _styleMap$get3.value) || ((_node$intrisicSizes2 = node.intrisicSizes) === null || _node$intrisicSizes2 === void 0 ? void 0 : _node$intrisicSizes2.maxContentInlineSize) || ((_styleMap$get4 = styleMap.get(exports.PropertyName.WIDTH)) === null || _styleMap$get4 === void 0 ? void 0 : _styleMap$get4.value) || 0;
    var minHeight = ((_styleMap$get5 = styleMap.get(exports.PropertyName.MIN_HEIGHT)) === null || _styleMap$get5 === void 0 ? void 0 : _styleMap$get5.value) || ((_node$intrisicSizes3 = node.intrisicSizes) === null || _node$intrisicSizes3 === void 0 ? void 0 : _node$intrisicSizes3.minContentBlockSize) || ((_styleMap$get6 = styleMap.get(exports.PropertyName.HEIGHT)) === null || _styleMap$get6 === void 0 ? void 0 : _styleMap$get6.value) || 0;
    var maxHeight = ((_styleMap$get7 = styleMap.get(exports.PropertyName.MAX_HEIGHT)) === null || _styleMap$get7 === void 0 ? void 0 : _styleMap$get7.value) || ((_node$intrisicSizes4 = node.intrisicSizes) === null || _node$intrisicSizes4 === void 0 ? void 0 : _node$intrisicSizes4.maxContentBlockSize) || ((_styleMap$get8 = styleMap.get(exports.PropertyName.HEIGHT)) === null || _styleMap$get8 === void 0 ? void 0 : _styleMap$get8.value) || 0;
    return {
      minContentInlineSize: minWidth,
      maxContentInlineSize: maxWidth,
      minContentBlockSize: minHeight,
      maxContentBlockSize: maxHeight
    };
  };
  _proto.getNodeFragment = function getNodeFragment(node, constraints) {
    var _node$getComputedLayo, _node$getAllStyle$get, _node$getAllStyle$get2, _node$getComputedLayo2, _node$getAllStyle$get3, _node$getAllStyle$get4;
    // TODO
    var width = ((_node$getComputedLayo = node.getComputedLayout()) === null || _node$getComputedLayo === void 0 ? void 0 : _node$getComputedLayo.inlineSize) || ((_node$getAllStyle$get = node.getAllStyle().get(exports.PropertyName.MIN_WIDTH)) === null || _node$getAllStyle$get === void 0 ? void 0 : _node$getAllStyle$get.value) || ((_node$getAllStyle$get2 = node.getAllStyle().get(exports.PropertyName.WIDTH)) === null || _node$getAllStyle$get2 === void 0 ? void 0 : _node$getAllStyle$get2.value) || 0;
    var height = ((_node$getComputedLayo2 = node.getComputedLayout()) === null || _node$getComputedLayo2 === void 0 ? void 0 : _node$getComputedLayo2.blockSize) || ((_node$getAllStyle$get3 = node.getAllStyle().get(exports.PropertyName.MIN_HEIGHT)) === null || _node$getAllStyle$get3 === void 0 ? void 0 : _node$getAllStyle$get3.value) || ((_node$getAllStyle$get4 = node.getAllStyle().get(exports.PropertyName.HEIGHT)) === null || _node$getAllStyle$get4 === void 0 ? void 0 : _node$getAllStyle$get4.value) || 0;
    return {
      inlineSize: width,
      blockSize: height,
      data: constraints.data
    };
  };
  return LayoutEngine;
}();

/**
 * 布局的结果
 */
var LayoutFragment = function LayoutFragment(_layoutContext, options) {
  this._layoutContext = void 0;
  this.options = void 0;
  this.layoutContext = void 0;
  this.inlineSize = void 0;
  this.blockSize = void 0;
  this.inlineOffset = void 0;
  this.blockOffset = void 0;
  this.data = void 0;
  this._layoutContext = _layoutContext;
  this.options = options;
  this.layoutContext = _layoutContext;
  this.inlineSize = options.inlineSize;
  this.blockSize = options.blockSize;
  this.inlineOffset = 0;
  this.blockOffset = 0;
  this.data = options.data;
};

var id = 1;
var LayoutObject = /*#__PURE__*/function () {
  function LayoutObject(style) {
    if (style === void 0) {
      style = new Map();
    }
    this.id = void 0;
    this.style = void 0;
    this.dirty = void 0;
    this.parent = void 0;
    this.children = void 0;
    this.internalIntrisicSizes = void 0;
    this.computedLayout = void 0;
    this.measureFn = void 0;
    this.id = id++;
    this.style = style;
    this.parent = undefined;
    this.children = [];
    this.dirty = false;
  }
  /**
   * set the intrinsic size of leaf node, different basic shape has different size, compsed shape has
   * @param measure measure function
   */
  var _proto = LayoutObject.prototype;
  _proto.setMeasure = function setMeasure(measure) {
    this.measureFn = measure;
  };
  _proto.setIntrisicSizes = function setIntrisicSizes(intrisicSizes) {
    this.internalIntrisicSizes = intrisicSizes;
  };
  _proto.addChild = function addChild(child) {
    var _this$children;
    (_this$children = this.children) === null || _this$children === void 0 ? void 0 : _this$children.push(child);
  };
  _proto.insertChild = function insertChild(index, child) {
    this.children.splice(index, 0, child);
  };
  _proto.removeChild = function removeChild(child) {
    var _this$children2;
    var index = (_this$children2 = this.children) === null || _this$children2 === void 0 ? void 0 : _this$children2.findIndex(function (node) {
      return node.id === child.id;
    });
    this.removeChildAtIndex(index);
  };
  _proto.removeChildAtIndex = function removeChildAtIndex(index) {
    this.children.splice(index, 1);
  };
  _proto.replaceChildAtIndex = function replaceChildAtIndex(index, child) {
    this.children.splice(index, 1, child);
  };
  _proto.setStyle = function setStyle(property, value) {
    this.style.set(property, value);
  }
  // setStyles(styles: Record<StyleProperty, StyleInputValue>) {
  //   this.style = StylePropertyMap.create({ styles }).styles;
  // }
  ;
  _proto.getStyle = function getStyle() {
    var _this = this;
    var returnStyle = new Map();
    for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {
      properties[_key] = arguments[_key];
    }
    properties.forEach(function (prop) {
      var propertyValue = _this.style.get(prop);
      if (propertyValue) {
        returnStyle.set(prop, propertyValue);
      }
    });
    return returnStyle;
  };
  _proto.getAllStyle = function getAllStyle() {
    return this.style;
  };
  _proto.markDirty = function markDirty() {
    this.dirty = true;
  };
  _proto.idDirty = function idDirty() {
    return this.dirty;
  };
  _proto.getSize = function getSize() {
    var _this$style$get$value, _this$style$get, _this$style$get$value2, _this$style$get2;
    var width = (_this$style$get$value = (_this$style$get = this.style.get(exports.PropertyName.WIDTH)) === null || _this$style$get === void 0 ? void 0 : _this$style$get.value) !== null && _this$style$get$value !== void 0 ? _this$style$get$value : 0;
    var height = (_this$style$get$value2 = (_this$style$get2 = this.style.get(exports.PropertyName.HEIGHT)) === null || _this$style$get2 === void 0 ? void 0 : _this$style$get2.value) !== null && _this$style$get$value2 !== void 0 ? _this$style$get$value2 : 0;
    return {
      width: width,
      height: height
    };
  };
  _proto.computeLayout = /*#__PURE__*/function () {
    var _computeLayout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var size;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              size = this.getSize();
              _context.next = 3;
              return layoutEngine.computeLayout(this, {
                availableInlineSize: size.width,
                availableBlockSize: size.height,
                fixedInlineSize: size.width,
                fixedBlockSize: size.height,
                percentageInlineSize: size.width,
                percentageBlockSize: size.height,
                data: undefined
              });
            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function computeLayout() {
      return _computeLayout.apply(this, arguments);
    }
    return computeLayout;
  }();
  _proto.setComputedLayout = function setComputedLayout(computedLayout) {
    this.computedLayout = computedLayout;
  };
  _proto.getComputedLayout = function getComputedLayout() {
    return this.computedLayout;
  };
  _proto.getAllComputedLayout = function getAllComputedLayout() {};
  _proto.toString = function toString() {
    return "LayoutObject " + this.id;
  };
  _createClass(LayoutObject, [{
    key: "intrisicSizes",
    get: function get() {
      return this.internalIntrisicSizes;
    }
  }, {
    key: "childCount",
    get: function get() {
      return this.children.length;
    }
  }]);
  return LayoutObject;
}();

var DefaultLayoutRegistry = /*#__PURE__*/function () {
  function DefaultLayoutRegistry() {
    this.registry = new Map();
  }
  var _proto = DefaultLayoutRegistry.prototype;
  _proto.hasLayout = function hasLayout(name) {
    return this.registry.has(name);
  }
  /**
   *
   * @param name layout name, default to 'absolute'
   * @returns layout object
   */;
  _proto.getLayout = function getLayout(name) {
    if (name === void 0) {
      name = 'absolute';
    }
    if (!this.hasLayout(name)) {
      throw new Error("invalid layout property: " + name);
    }
    return this.registry.get(name);
  };
  _proto.updateLayout = function updateLayout(name, layout) {
    this.registry.set(name, layout);
  };
  _proto.registerLayout = function registerLayout(name, layout) {
    if (name === '') {
      throw new TypeError("layout name cant't be empty");
    }
    if (DefaultLayoutRegistry.reservedLayout.includes(name)) {
      throw new Error("layout name '" + name + "' is a system reserved layout name, please use another name");
    }
    if (this.hasLayout(name)) {
      throw new Error("layout '" + name + "' already exist.");
    }
    this.registry.set(name, layout);
  };
  _proto.deleteLayout = function deleteLayout(name) {
    this.registry.delete(name);
  };
  _createClass(DefaultLayoutRegistry, [{
    key: "size",
    get: function get() {
      return this.registry.size;
    }
  }]);
  return DefaultLayoutRegistry;
}();
DefaultLayoutRegistry.reservedLayout = [];

// import { LayoutEdges, LayoutEdgesOptions } from './LayoutEdges';
// const layoutRegistry = new DefaultLayoutRegistry();
// const layoutEdgesFactory = (options: LayoutEdgesOptions) => {
//   return new LayoutEdges(options);
// };
// const layoutContextFactory = (options: LayoutEdgesOptions) => {
//   // const layoutChildrenFactory = (childOptions: LayoutChildrenOptions) => {
//   //   return new LayoutChildren(childOptions);
//   // };
//   // container.register({
//   //   token: LayoutChildrenFactory,
//   //   useFactory: (childContext) => {
//   //     return (childOptions: LayoutChildrenOptions) => {
//   //       const childContainer = childContext.container.createChild();
//   //       childContainer.register({
//   //         token: LayoutChildrenOptions,
//   //         useValue: childOptions,
//   //       });
//   //       return childContainer.get(LayoutChildren);
//   //     };
//   //   },
//   // });
//   // container.register(FragmentResult);
//   // container.register({
//   //   token: FragmentResultFactory,
//   //   useFactory: (childContext) => {
//   //     return (childOptions, node) => {
//   //       const childContainer = childContext.container.createChild();
//   //       childContainer.register({
//   //         token: FragmentResultOptions,
//   //         useValue: childOptions,
//   //       });
//   //       childContainer.register({
//   //         token: ContextNode,
//   //         useValue: node,
//   //       });
//   //       return childContainer.get(FragmentResult);
//   //     };
//   //   },
//   // });
//   // container.register(LayoutFragment);
//   // container.register({
//   //   token: LayoutFragmentFactory,
//   //   useFactory: (childContext) => {
//   //     return (childOptions) => {
//   //       const childContainer = childContext.container.createChild();
//   //       childContainer.register({
//   //         token: LayoutFragmentOptions,
//   //         useValue: childOptions,
//   //       });
//   //       return childContainer.get(LayoutFragment);
//   //     };
//   //   },
//   // });
//   // const layoutChildrenFactory = container.get(LayoutChildrenFactory);
//   // const layoutFragmentFactory = (childContext) => {
//   //   return (childOptions) => {
//   //     return new LayoutFragment(childOptions);
//   //   };
//   // };
//   // const fragmentResultFactory = container.get(FragmentResultFactory);
//   // const layoutContext = new LayoutContext({
//   //   ...options,
//   //   layoutChildrenFactory,
//   //   layoutFragmentFactory,
//   //   fragmentResultFactory,
//   // });
//   // return layoutContext;
// }
// export const layoutEngine = new LayoutEngine(layoutRegistry);
var layoutEngine = null;

exports.AbstractLayoutDefinition = AbstractLayoutDefinition;
exports.DefaultLayoutRegistry = DefaultLayoutRegistry;
exports.FragmentResult = FragmentResult;
exports.LayoutChildren = LayoutChildren;
exports.LayoutContext = LayoutContext;
exports.LayoutEdges = LayoutEdges;
exports.LayoutEngine = LayoutEngine;
exports.LayoutFragment = LayoutFragment;
exports.LayoutObject = LayoutObject;
exports.layoutEngine = layoutEngine;
