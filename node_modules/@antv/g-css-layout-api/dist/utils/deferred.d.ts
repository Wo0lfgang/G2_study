interface PromiseStatus<T> {
    isPending: () => boolean;
    isRejected: () => boolean;
    isFulfilled: () => boolean;
    getFullFilledValue: () => T;
}
/**
 * This function allow you to modify a JS Promise by adding some status properties.
 * Based on: http://stackoverflow.com/questions/21485545/is-there-a-way-to-tell-if-an-es6-promise-is-fulfilled-rejected-resolved
 * But modified according to the specs of promises : https://promisesaplus.com/
 */
export declare const makeQuerablePromise: <T>(promise: Promise<T>) => PromiseStatus<T>;
/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
export declare class Deferred<T = void> {
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (err?: any) => void;
    promise: Promise<T>;
}
export declare const equalSet: (as: Set<any>, bs: Set<any>) => boolean;
/**
 * Nicely typed aliases for some `Object` Methods
 * - PSA: Don't mutate `yourObject`s
 * - Numerical keys are BAD, resolve that issue upstream
 * - Discussion: https://stackoverflow.com/a/65117465/565877
 */
export declare const ObjectTyped: {
    /**
     * Object.keys, but with nice typing (`Array<keyof T>`)
     */
    keys: <T extends Record<string, unknown>>(yourObject: T) => (keyof T)[];
    /**
     * Object.values, but with nice typing
     */
    values: <T_1 extends Record<string, unknown>>(yourObject: T_1) => T_1[keyof T_1][];
    /**
     * Object.entries, but with nice typing
     */
    entries: <T_2 extends Record<string, unknown>>(yourObject: T_2) => [keyof T_2, T_2[keyof T_2]][];
};
export {};
//# sourceMappingURL=deferred.d.ts.map