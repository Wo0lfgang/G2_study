var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { group } from 'd3-array';
import { isEqual } from '@antv/util';
import { defined } from '../utils/helper';
import { getPolarOptions, getRadialOptions, } from '../coordinate';
import { combine } from '../utils/array';
import { coordOf, isHelix, isParallel, isPolar, isRadar, isRadial, isReflect, isReflectY, isTheta, isTranspose, } from './coordinate';
import { useLibrary } from './library';
import { isValidScale, useRelationScale } from './scale';
import { ContinuousScale, DiscreteScale, DistributionScale, } from './types/scale';
export function inferComponent(scales, partialOptions, library) {
    const { component: partialComponents = [], coordinates = [], title, theme, } = partialOptions;
    const [, createGuideComponent] = useLibrary('component', library);
    const displayedScales = scales.filter(({ guide, name }) => {
        if (guide === null)
            return false;
        return true;
    });
    const sliders = inferScrollableComponents(partialOptions, scales, library);
    const components = [...partialComponents, ...sliders];
    if (title) {
        const { props } = createGuideComponent('title');
        const { defaultPosition, defaultOrientation, defaultOrder, defaultSize } = props;
        const titleOptions = typeof title === 'string' ? { title } : title;
        components.push(Object.assign({ type: 'title', position: defaultPosition, orientation: defaultOrientation, order: defaultOrder, size: defaultSize }, titleOptions));
    }
    const inferedComponents = inferComponentsType(displayedScales, coordinates);
    inferedComponents.forEach(([type, relativeScales]) => {
        const { props } = createGuideComponent(type);
        const { defaultPosition, defaultOrientation, defaultSize, defaultOrder } = props;
        // @todo to be comfirm if the scale can be merged.
        const scale = Object.assign({}, ...relativeScales);
        const { guide: guideOptions, field } = scale;
        // A scale may have multiple guides.
        const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];
        for (const partialGuide of guides) {
            const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
            // Skip if position and orientation are not specified.
            // @example the last axis of radar chart
            if (!position && !orientation)
                continue;
            const { size = defaultSize, order = defaultOrder } = partialGuide;
            components.push(Object.assign(Object.assign({ title: field }, partialGuide), { position,
                orientation,
                order,
                size,
                type, scales: relativeScales }));
        }
    });
    return components;
}
export function renderComponent(component, coordinates, theme, library) {
    const [useGuideComponent] = useLibrary('component', library);
    const { scales: scaleDescriptors = [], bbox } = component, options = __rest(component, ["scales", "bbox"]);
    const scales = scaleDescriptors.map((descriptor) => useRelationScale(descriptor, library));
    const value = { bbox, scales: scaleDescriptors, library };
    const render = useGuideComponent(options);
    return render(scales, value, coordinates, theme);
}
function inferLegendComponentType(scales, coordinates) {
    const scalesByField = group(scales, (d) => d.field || d.name);
    const createStrategy = (arr, main) => {
        const result = combine(arr);
        result.forEach((c) => c.unshift(main));
        result.push([main]);
        return result.sort((a, b) => b.length - a.length);
    };
    // [legend type, [[channels, scale types]]][]
    const strategy = [
        [
            'legendCategory',
            createStrategy([
                // @todo now haven't provide constant scale of color channel,
                // so won't display the single shape scale.
                ['shape', 'discrete'],
                ['size', 'discrete'],
                ['opacity', 'discrete'],
            ], ['color', 'discrete']),
        ],
        [
            'legendContinuousSize',
            [
                [
                    ['color', 'continuous'],
                    ['opacity', 'continuous'],
                    ['size', 'continuous'],
                ],
                [
                    ['color', 'continuous'],
                    ['size', 'continuous'],
                ],
            ],
        ],
        [
            'legendContinuousBlockSize',
            [
                [
                    ['color', 'distribution'],
                    ['opacity', 'distribution'],
                    ['size', 'distribution'],
                ],
                [
                    ['color', 'distribution'],
                    ['size', 'distribution'],
                ],
            ],
        ],
        [
            'legendContinuousBlock',
            createStrategy([['opacity', 'continuous']], ['color', 'distribution']),
        ],
        [
            'legendContinuous',
            createStrategy([['opacity', 'continuous']], ['color', 'continuous']),
        ],
    ];
    function getScaleType(scale) {
        const { type } = scale;
        if (typeof type !== 'string')
            return null;
        if (type in ContinuousScale)
            return 'continuous';
        if (type in DiscreteScale)
            return 'discrete';
        if (type in DistributionScale)
            return 'distribution';
        return null;
    }
    const components = Array.from(scalesByField)
        .map(([, scs]) => {
        const combinations = combine(scs).sort((a, b) => b.length - a.length);
        const options = combinations.map((combination) => ({
            combination,
            option: combination.map((scale) => [scale.name, getScaleType(scale)]),
        }));
        const sort = (arr) => arr.sort((a, b) => a[0].localeCompare(b[0]));
        for (const [componentType, accords] of strategy) {
            for (const { option, combination } of options) {
                if (accords.some((accord) => isEqual(sort(accord), sort(option)))) {
                    return [componentType, combination];
                }
            }
        }
        return null;
    })
        .filter(defined);
    return components;
}
function inferAxisComponentType(scales, coordinates) {
    return scales
        .map((scale) => {
        const { name } = scale;
        // todo wait for gui provide helix axis
        if (isHelix(coordinates) || isTheta(coordinates))
            return null;
        if (isTranspose(coordinates) &&
            (isPolar(coordinates) || isRadial(coordinates)))
            return null;
        // infer axis
        if (name.startsWith('x')) {
            if (isPolar(coordinates))
                return ['axisArc', [scale]];
            if (isRadial(coordinates))
                return ['axisLinear', [scale]];
            return [isTranspose(coordinates) ? 'axisY' : 'axisX', [scale]];
        }
        if (name.startsWith('y')) {
            if (isPolar(coordinates))
                return ['axisLinear', [scale]];
            if (isRadial(coordinates))
                return ['axisArc', [scale]];
            return [isTranspose(coordinates) ? 'axisX' : 'axisY', [scale]];
        }
        if (name.startsWith('position')) {
            if (isRadar(coordinates))
                return ['axisRadar', [scale]];
            if (!isPolar(coordinates))
                return ['axisY', [scale]];
        }
        return null;
    })
        .filter(defined);
}
function inferComponentsType(scales, coordinates) {
    const avaliableScales = scales.filter((scale) => isValidScale(scale));
    return [
        ...inferLegendComponentType(avaliableScales, coordinates),
        ...inferAxisComponentType(avaliableScales, coordinates),
    ];
}
function angleOf(coordinates) {
    const polar = coordOf(coordinates, 'polar');
    if (polar.length) {
        const lastPolar = polar[polar.length - 1];
        const { startAngle, endAngle } = getPolarOptions(lastPolar);
        return [startAngle, endAngle];
    }
    const radial = coordOf(coordinates, 'radial');
    if (radial.length) {
        const lastRadial = radial[radial.length - 1];
        const { startAngle, endAngle } = getRadialOptions(lastRadial);
        return [startAngle, endAngle];
    }
    return [-Math.PI / 2, (Math.PI / 2) * 3];
}
/**
 * match index of position
 */
function matchPosition(name) {
    const match = /position(\d*)/g.exec(name);
    if (!match)
        return null;
    return +match[1];
}
function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
    // a axis only has one scale
    const { name } = relativeScales[0];
    // todo, in current resolution, the radar chart is implement by parallel + polar coordinate.
    // implementation plan to be confirmed.
    // in current implementation, it must to add the first position encode to it's last.
    // so we won't render the last axis repeatly.
    if (type === 'axisRadar') {
        const positions = scales.filter((scale) => scale.name.startsWith('position'));
        const index = matchPosition(name);
        if (name === positions.slice(-1)[0].name || index === null)
            return [null, null];
        // infer radar axis orientation
        const [startAngle, endAngle] = angleOf(coordinates);
        const angle = ((endAngle - startAngle) / (positions.length - 1)) * index + startAngle;
        return ['center', angle];
    }
    // There are multiple axes for parallel coordinate.
    // Place the first one in the border area and put others in the center.
    if (type === 'axisY' && isParallel(coordinates)) {
        // name looks like `position${number}`
        const index = matchPosition(name);
        if (index === null)
            return ordinalPosition;
        if (isTranspose(coordinates)) {
            return index === 0 ? ['top', null] : ['center', 'horizontal'];
        }
        return index === 0 ? ordinalPosition : ['center', 'vertical'];
    }
    // in non-cartesian coordinate systems, infer the arc axis angle
    if (type === 'axisLinear') {
        const [startAngle] = angleOf(coordinates);
        return ['center', startAngle];
    }
    if (type === 'axisArc') {
        if (ordinalPosition[0] === 'inner')
            return ['inner', null];
        return ['outer', null];
    }
    if (isPolar(coordinates))
        return ['center', null];
    if (isRadial(coordinates))
        return ['center', null];
    if ((type === 'axisX' && isReflect(coordinates)) ||
        (type === 'axisX' && isReflectY(coordinates))) {
        return ['top', null];
    }
    // if (type === 'axisX') return ['bottom', null];
    return ordinalPosition;
}
// @todo Infer position by coordinates.
function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
    const [startAngle] = angleOf(coordinates);
    const ordinalPositionAndOrientation = [
        guide.position || defaultPosition,
        startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation,
    ];
    if (typeof type === 'string' && type.startsWith('axis')) {
        return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
    }
    if (typeof type === 'string' &&
        type.startsWith('legend') &&
        isPolar(coordinates)) {
        if (guide.position === 'center')
            return ['center', 'vertical'];
    }
    // for general component, use default position
    return ordinalPositionAndOrientation;
}
function inferSrollableType(name, type, coordinates = []) {
    if (name === 'x')
        return isTranspose(coordinates) ? `${type}Y` : `${type}X`;
    if (name === 'y')
        return isTranspose(coordinates) ? `${type}X` : `${type}Y`;
    return null;
}
/**
 * Infer scrollable components, such as slider and scrollbar.
 */
function inferScrollableComponents(partialOptions, scales, library) {
    const [, createGuideComponent] = useLibrary('component', library);
    const { coordinates } = partialOptions;
    function normalized(type, channelName, scale, options) {
        const componentType = inferSrollableType(channelName, type, coordinates);
        if (!options || !componentType)
            return;
        const { props } = createGuideComponent(componentType);
        const { defaultPosition, defaultSize, defaultOrder } = props;
        return Object.assign(Object.assign({ position: defaultPosition, size: defaultSize, order: defaultOrder, type: componentType }, options), { scales: [scale] });
    }
    return scales
        .filter((d) => d.slider || d.scrollbar)
        .flatMap((scale) => {
        const { slider, scrollbar, name: channelName } = scale;
        return [
            normalized('slider', channelName, scale, slider),
            normalized('scrollbar', channelName, scale, scrollbar),
        ];
    })
        .filter((d) => !!d);
}
//# sourceMappingURL=component.js.map