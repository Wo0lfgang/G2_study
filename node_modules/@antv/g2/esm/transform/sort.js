var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { deepMix } from '@antv/util';
import { groupSort, max, min, sum, mean, median, sort, } from 'd3-array';
import { columnOf } from './utils/helper';
function createReducer(channel, options, encode) {
    const { by = channel, reducer = 'max' } = options;
    const [V] = columnOf(encode, by);
    if (typeof reducer === 'function')
        return (GI) => reducer(GI, V);
    if (reducer === 'max')
        return (GI) => max(GI, (i) => +V[i]);
    if (reducer === 'min')
        return (GI) => min(GI, (i) => +V[i]);
    if (reducer === 'sum')
        return (GI) => sum(GI, (i) => +V[i]);
    if (reducer === 'median')
        return (GI) => median(GI, (i) => +V[i]);
    if (reducer === 'mean')
        return (GI) => mean(GI, (i) => +V[i]);
    if (reducer === 'first')
        return (GI) => V[GI[0]];
    if (reducer === 'last')
        return (GI) => V[GI[GI.length - 1]];
    throw new Error(`Unknown reducer: ${reducer}`);
}
function sortQuantitative(I, mark, options) {
    const { reverse, slice, channel } = options;
    const { encode } = mark;
    const [V] = columnOf(encode, channel);
    const sortedI = sort(I, (i) => V[i]);
    if (reverse)
        sortedI.reverse();
    // const s = typeof slice === 'number' ? [0, slice] : slice;
    return [sortedI, mark];
}
function sortOrdinal(I, mark, options) {
    const { reverse, slice, channel } = options, rest = __rest(options, ["reverse", "slice", "channel"]);
    const { encode } = mark;
    const [T] = columnOf(encode, channel);
    const normalizeReducer = createReducer(channel, rest, encode);
    const sortedDomain = groupSort(I, normalizeReducer, (i) => T[i]);
    if (reverse)
        sortedDomain.reverse();
    const s = typeof slice === 'number' ? [0, slice] : slice;
    const slicedDomain = slice ? sortedDomain.slice(...s) : sortedDomain;
    return [
        I,
        deepMix(mark, {
            scale: {
                [channel]: {
                    domain: slicedDomain,
                },
            },
        }),
    ];
}
/**
 * Sort marks groups by groups.
 */
export const Sort = (options = {}) => {
    const { reverse = false, slice, channel, ordinal = true } = options, rest = __rest(options, ["reverse", "slice", "channel", "ordinal"]);
    return (I, mark) => {
        if (!ordinal) {
            return sortQuantitative(I, mark, Object.assign({ reverse,
                slice,
                channel }, rest));
        }
        return sortOrdinal(I, mark, Object.assign({ reverse, slice, channel }, rest));
    };
};
Sort.props = {};
//# sourceMappingURL=sort.js.map