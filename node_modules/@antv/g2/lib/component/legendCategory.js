"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LegendCategory = void 0;
const gui_1 = require("@antv/gui");
const d3_format_1 = require("d3-format");
const library_1 = require("../runtime/library");
const utils_1 = require("./utils");
function inferLayout(position, gridRow, gridCol) {
    const [gridRowLimit, gridColLimit] = [gridRow || 100, gridCol || 100];
    switch (position) {
        case 'top':
        case 'bottom':
        case 'top-left':
        case 'top-right':
        case 'bottom-left':
        case 'bottom-right':
            return [1, gridColLimit];
        case 'left':
        case 'right':
            return [gridRowLimit, 1];
        default:
            return [gridRow, gridCol];
    }
}
function createShape(shape, library, coordinate, theme, style = {}) {
    const [useShape] = (0, library_1.useLibrary)('shape', library);
    return () => useShape({ type: `point.${shape}` })([
        [0, 0],
        [0, 0],
    ], Object.assign({ size: 6 }, style), coordinate, theme);
}
function inferItemMarker(scales, options, library, coordinate, theme) {
    const shapeScale = (0, utils_1.scaleOf)(scales, 'shape');
    const { itemMarker } = options;
    if (shapeScale && !itemMarker) {
        const { range } = shapeScale.getOptions();
        return (d, i) => createShape(range[i], library, coordinate, theme, {
            color: d.color,
        });
    }
    if (typeof itemMarker === 'function') {
        return itemMarker;
    }
    return (d, i) => createShape(itemMarker || 'point', library, coordinate, theme, {
        color: d.color,
    });
}
function inferItemMarkerOpacity(scales) {
    const scale = (0, utils_1.scaleOf)(scales, 'opacity');
    if (scale) {
        const { range } = scale.getOptions();
        return (d, i) => range[i];
    }
    return undefined;
}
function inferCategoryStyle(scales, options, library, coordinate, theme) {
    const { labelFormatter = (d) => `${d}` } = options;
    const baseStyle = {
        itemMarker: inferItemMarker(scales, options, library, coordinate, theme),
        itemMarkerOpacity: inferItemMarkerOpacity(scales),
    };
    const finalLabelFormatter = typeof labelFormatter === 'string'
        ? (0, d3_format_1.format)(labelFormatter)
        : labelFormatter;
    // here must exists a color scale
    const scale = (0, utils_1.scaleOf)(scales, 'color');
    return Object.assign(Object.assign({}, baseStyle), { data: scale.getOptions().domain.map((d) => ({
            id: d,
            label: finalLabelFormatter(d),
            color: scale.map(d),
        })) });
}
/**
 * Guide Component for ordinal color scale.
 */
const LegendCategory = (options) => {
    const { order, size, position, orientation, itemMarker, labelFormatter, dx = 0, dy = 0, title, gridCol, gridRow, layout } = options, rest = __rest(options, ["order", "size", "position", "orientation", "itemMarker", "labelFormatter", "dx", "dy", "title", "gridCol", "gridRow", "layout"]);
    return (scales, value, coordinate, theme) => {
        var _a, _b, _c;
        const { library, bbox } = value;
        const { x, y, width, height } = bbox;
        const finalLayout = (0, utils_1.inferComponentLayout)(position, (_c = (_b = (_a = value.scales) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.guide) === null || _c === void 0 ? void 0 : _c.layout);
        const [finalGridRow, finalGridCol] = inferLayout(position, gridRow, gridCol);
        const legendStyle = Object.assign({ orient: ['right', 'left', 'center'].includes(position)
                ? 'vertical'
                : 'horizontal', width,
            height, gridCol: gridCol !== null && gridCol !== void 0 ? gridCol : finalGridCol, gridRow: gridRow !== null && gridRow !== void 0 ? gridRow : finalGridRow, rowPadding: 0, colPadding: 8, titleText: (0, utils_1.titleContent)(title) }, inferCategoryStyle(scales, options, library, coordinate, theme));
        const { legend: legendTheme = {} } = theme;
        const layoutWrapper = new utils_1.G2Layout({
            style: Object.assign({ x: x + dx, y: y + dy, width,
                height }, finalLayout),
        });
        layoutWrapper.appendChild(new gui_1.Category({
            className: 'legend-category',
            style: Object.assign({}, legendTheme, legendStyle, rest),
        }));
        return layoutWrapper;
    };
};
exports.LegendCategory = LegendCategory;
exports.LegendCategory.props = {
    defaultPosition: 'top',
    defaultOrder: 1,
    defaultSize: 40,
};
//# sourceMappingURL=legendCategory.js.map