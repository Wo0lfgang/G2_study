"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaleOf = exports.G2Layout = exports.inferComponentLayout = exports.titleContent = exports.maybeAppend = exports.createComponent = void 0;
const g_1 = require("@antv/g");
const util_1 = require("@antv/util");
const gui_1 = require("@antv/gui");
const selection_1 = require("../utils/selection");
function createComponent(descriptor) {
    return class extends g_1.CustomElement {
        constructor(config) {
            super(config);
            this.descriptor = descriptor;
        }
        connectedCallback() {
            var _a, _b;
            (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
        }
        update(cfg = {}) {
            var _a, _b;
            this.attr((0, util_1.deepMix)({}, this.attributes, cfg));
            (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
        }
    };
}
exports.createComponent = createComponent;
function maybeAppend(parent, selector, node) {
    if (!parent.querySelector(selector)) {
        return (0, selection_1.select)(parent).append(node);
    }
    return (0, selection_1.select)(parent).select(selector);
}
exports.maybeAppend = maybeAppend;
function titleContent(field) {
    return Array.isArray(field) ? field.join(', ') : `${field || ''}`;
}
exports.titleContent = titleContent;
function inferComponentLayout(position, userDefinitions) {
    const preset = {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'flex-start',
        alignItems: 'center',
    };
    if (userDefinitions) {
        return Object.assign(Object.assign({}, preset), userDefinitions);
    }
    let { flexDirection, justifyContent, alignItems } = preset;
    const layout = {
        top: ['row', 'center', 'center'],
        bottom: ['row', 'center', 'center'],
        left: ['colunm', 'center', 'center'],
        right: ['colunm', 'center', 'center'],
        center: ['column', 'center', 'center'],
    };
    if (position in layout) {
        [flexDirection, justifyContent, alignItems] = layout[position];
    }
    return { display: 'flex', flexDirection, justifyContent, alignItems };
}
exports.inferComponentLayout = inferComponentLayout;
class G2Layout extends gui_1.Layout {
    update(options) {
        var _a, _b;
        this.attr(options);
        const { width, height } = options, restOptions = __rest(options, ["width", "height"]);
        (_b = (_a = this.children) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.update(restOptions);
    }
}
exports.G2Layout = G2Layout;
function scaleOf(scales, type) {
    var _a;
    return (_a = scales.filter((s) => s.getOptions().name === type)) === null || _a === void 0 ? void 0 : _a[0];
}
exports.scaleOf = scaleOf;
//# sourceMappingURL=utils.js.map