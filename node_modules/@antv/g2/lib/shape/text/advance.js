"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Advance = void 0;
const gui_1 = require("@antv/gui");
const d3_shape_1 = require("d3-shape");
const createElement_1 = require("../createElement");
const utils_1 = require("../utils");
const helper_1 = require("../../utils/helper");
const selection_1 = require("../../utils/selection");
const vector_1 = require("../../utils/vector");
function getConnectorPoint(shape) {
    const { min: [x0, y0], max: [x1, y1], } = shape.getLocalBounds();
    let x = 0;
    let y = 0;
    if (x0 > 0)
        x = x0;
    if (x1 < 0)
        x = x1;
    if (y0 > 0)
        y = y0;
    if (y1 < 0)
        y = y1;
    return [x, y];
}
function inferBackgroundBounds(textShape, padding = []) {
    const [top = 0, right = 0, bottom = top, left = right] = padding;
    const container = textShape.parentNode;
    const angle = container.getEulerAngles();
    container.setEulerAngles(0);
    const { min, halfExtents } = textShape.getLocalBounds();
    const [x, y] = min;
    const [hw, hh] = halfExtents;
    container.setEulerAngles(angle);
    return {
        x: x - left,
        y: y - top,
        width: hw * 2 + left + right,
        height: hh * 2 + top + bottom,
    };
}
const cos = (p0, p1, p2) => {
    const a = (0, vector_1.dist)(p0, p1);
    const b = (0, vector_1.dist)(p1, p2);
    const c = (0, vector_1.dist)(p2, p0);
    return (Math.pow(a, 2) + Math.pow(b, 2) - Math.pow(c, 2)) / (2 * a * b);
};
function inferConnectorPath(shape, points, controlPoints, coordCenter) {
    const [[x0, y0], [x1, y1]] = points;
    const [x, y] = getConnectorPoint(shape);
    // Straight connector line.
    if (x0 === x1 && y0 === y1) {
        return (0, d3_shape_1.line)()([
            [0, 0],
            [x, y],
        ]);
    }
    const P = [[x0 - x1, y0 - y1]].concat(controlPoints.length ? controlPoints : [0, 0]);
    const p0 = [coordCenter[0] - x1, coordCenter[1] - y1];
    const [p1, p2] = P;
    // If angle is smaller than 90, which will cause connector overlap with element.
    if (cos(p0, p1, p2) > 0) {
        const x2 = (() => {
            const { min, max } = shape.getLocalBounds();
            // A(x1,y2) perpendicular to B(x2,y2) => x1*x2 + y1*y2 = 0
            const vx = p1[0] + ((p1[1] - p0[1]) * (p1[1] - 0)) / (p1[0] - p0[0]);
            if (max[0] < p0[0])
                return Math.min(max[0], vx);
            return Math.max(min[0], vx);
        })();
        P.splice(1, 1, [x2, 0]);
    }
    return (0, d3_shape_1.line)()(P);
}
exports.Advance = (0, createElement_1.createElement)((g) => {
    const _a = g.attributes, { 
    // Do not pass className
    class: className, transform, 
    // @ts-ignore
    rotate, x, y, x0 = x, y0 = y, background, connector, startMarker, endMarker, coordCenter } = _a, rest = __rest(_a, ["class", "transform", "rotate", "x", "y", "x0", "y0", "background", "connector", "startMarker", "endMarker", "coordCenter"]);
    const _b = (0, helper_1.subObject)(rest, 'background'), { padding } = _b, backgroundStyle = __rest(_b, ["padding"]);
    const _c = (0, helper_1.subObject)(rest, 'connector'), { points = [] } = _c, connectorStyle = __rest(_c, ["points"]);
    const endPoints = [
        [+x0, +y0],
        [+x, +y],
    ];
    const shape1 = (0, selection_1.select)(g)
        .maybeAppend('text', 'text')
        .call(utils_1.applyStyle, rest)
        .node();
    const shape2 = (0, selection_1.select)(g)
        .maybeAppend('background', 'rect')
        .style('zIndex', -1)
        .call(utils_1.applyStyle, inferBackgroundBounds(shape1, padding))
        .call(utils_1.applyStyle, background ? backgroundStyle : {})
        .node();
    const connectorPath = inferConnectorPath(shape2, endPoints, points, coordCenter);
    const markerStart = startMarker &&
        new gui_1.Marker({
            id: 'startMarker',
            style: Object.assign({ x: 0, y: 0 }, (0, helper_1.subObject)(rest, 'startMarker')),
        });
    const markerEnd = endMarker &&
        new gui_1.Marker({
            id: 'endMarker',
            style: Object.assign({ x: 0, y: 0 }, (0, helper_1.subObject)(rest, 'endMarker')),
        });
    (0, selection_1.select)(g)
        .maybeAppend('connector', 'path')
        .style('path', connectorPath)
        .style('markerStart', markerStart)
        .style('markerEnd', markerEnd)
        .call(utils_1.applyStyle, connector ? connectorStyle : {});
});
//# sourceMappingURL=advance.js.map