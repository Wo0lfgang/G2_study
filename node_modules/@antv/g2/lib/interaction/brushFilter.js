"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrushFilter = exports.brushFilter = void 0;
const util_1 = require("@antv/util");
const helper_1 = require("../utils/helper");
const scale_1 = require("../utils/scale");
const brushHighlight_1 = require("./brushHighlight");
const utils_1 = require("./utils");
// Mock dblclick events.
function dblclick(interval = 300) {
    let preTimeStamp = null;
    return (e) => {
        const { timeStamp } = e;
        if (preTimeStamp !== null && timeStamp - preTimeStamp < interval) {
            preTimeStamp = timeStamp;
            return true;
        }
        preTimeStamp = timeStamp;
        return false;
    };
}
function brushFilter(root, _a) {
    var { filter, reset, brushRegion, extent: optionalExtent, reverse, series = false } = _a, rest = __rest(_a, ["filter", "reset", "brushRegion", "extent", "reverse", "series"]);
    const brushStyle = (0, helper_1.subObject)(rest, 'mask');
    const { width: rootWidth, height: rootHeight } = root.getBBox();
    const extent = optionalExtent
        ? optionalExtent
        : [0, 0, rootWidth, rootHeight];
    const isDblclick = dblclick();
    const brush = (0, brushHighlight_1.brush)(root, Object.assign(Object.assign({}, brushStyle), { extent,
        brushRegion,
        reverse,
        brushcreated }));
    root.addEventListener('click', click);
    // Filter when brush created.
    function brushcreated(x, y, x1, y1) {
        filter(x, y, x1, y1);
        brush.remove();
    }
    // Reset when dblclick.
    function click(e) {
        if (isDblclick(e))
            reset();
    }
    return () => {
        brush.destroy();
        root.removeEventListener('click', click);
    };
}
exports.brushFilter = brushFilter;
function BrushFilter(_a) {
    var { hideX = true, hideY = true } = _a, rest = __rest(_a, ["hideX", "hideY"]);
    return (target, viewInstances) => {
        const { container, view, options: viewOptions, update } = target;
        const plotArea = (0, utils_1.selectPlotArea)(container);
        const defaultOptions = {
            maskFill: '#777',
            maskFillOpacity: '0.3',
            maskStroke: '#fff',
            unhighlightedOpacity: 0.5,
            reverse: false,
        };
        let filtered = false;
        let filtering = false;
        let newView = view;
        return brushFilter(plotArea, Object.assign(Object.assign({ brushRegion: (x, y, x1, y1) => [x, y, x1, y1], filter: (x, y, x1, y1) => __awaiter(this, void 0, void 0, function* () {
                // Avoid redundant filter.
                if (filtering)
                    return;
                filtering = true;
                // Invert visual range to abstract domain.
                const { scale, coordinate } = newView;
                const { x: scaleX, y: scaleY } = scale;
                const abstractDomain = (point, start) => {
                    const [x, y] = coordinate.invert(point);
                    return [(0, scale_1.invert)(scaleX, x, start), (0, scale_1.invert)(scaleY, y, start)];
                };
                const p0 = abstractDomain([x, y], true);
                const p1 = abstractDomain([x1, y1], false);
                // Update the domain of x and y scale to filter data.
                const { marks } = viewOptions;
                const newMarks = marks.map((mark) => (0, util_1.deepMix)({
                    // Hide label to keep smooth transition.
                    axis: Object.assign(Object.assign({}, (hideX && { x: { labelTransform: [{ type: 'hide' }] } })), (hideY && { y: { labelTransform: [{ type: 'hide' }] } })),
                }, mark, {
                    scale: {
                        x: { domain: (0, scale_1.domainOf)(scaleX, [p0[0], p1[0]]) },
                        y: { domain: (0, scale_1.domainOf)(scaleY, [p0[1], p1[1]]) },
                    },
                }));
                // Rerender and update view.
                const newOptions = Object.assign(Object.assign({}, viewOptions), { marks: newMarks, clip: true });
                const newState = yield update(newOptions);
                newView = newState.view;
                filtering = false;
                filtered = true;
            }), reset: () => {
                if (filtering || !filtered)
                    return;
                filtered = false;
                newView = view;
                update(viewOptions);
            }, extent: undefined }, defaultOptions), rest));
    };
}
exports.BrushFilter = BrushFilter;
//# sourceMappingURL=brushFilter.js.map