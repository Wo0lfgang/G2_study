/* eslint-disable @typescript-eslint/no-unused-vars */
// https://github.com/d3/d3-plugins/blob/master/fisheye/fisheye.js
import { Linear } from '@antv/scale';
function fisheyeTransform(x, focus, distortion, min, max) {
    var left = x < focus;
    var m = (left ? focus - min : max - focus) || max - min;
    var f = left ? -1 : 1;
    return (f * m * (distortion + 1)) / (distortion + m / ((x - focus) * f)) + focus;
}
function fisheyeUntransform(tx, focus, distortion, min, max) {
    var left = tx < focus;
    var m = (left ? focus - min : max - focus) || max - min;
    var f = left ? -1 : 1;
    return m / ((m * (distortion + 1)) / (tx - focus) - distortion * f) + focus;
}
/**
 * Map actual visual point to abstract focus point(0, 1)
 */
function normalize(focus, length, isVisual) {
    if (!isVisual)
        return focus;
    var s = new Linear({
        range: [0, 1],
        domain: [0, length],
    });
    return s.map(focus);
}
/**
 * Applies cartesian fisheye transforms for the first dimension of vector2.
 * @param params [focus, distortion]
 * @param x x of the the bounding box of coordinate
 * @param y y of the the bounding box of coordinate
 * @param width width of the the bounding box of coordinate
 * @param height height of the the bounding box of coordinate
 * @returns transformer
 */
export var fisheyeX = function (params, x, y, width, height) {
    var _a = params, focus = _a[0], distortion = _a[1], _b = _a[2], isVisual = _b === void 0 ? false : _b;
    var normalizedFocusX = normalize(focus, width, isVisual);
    return {
        transform: function (vector) {
            var vx = vector[0], vy = vector[1];
            var fx = fisheyeTransform(vx, normalizedFocusX, distortion, 0, 1);
            return [fx, vy];
        },
        untransform: function (vector) {
            var fx = vector[0], vy = vector[1];
            var vx = fisheyeUntransform(fx, normalizedFocusX, distortion, 0, 1);
            return [vx, vy];
        },
    };
};
/**
 * Applies cartesian fisheye transforms for the second dimension of vector2.
 * @param params [focus, distortion]
 * @param x x of the the bounding box of coordinate
 * @param y y of the the bounding box of coordinate
 * @param width width of the the bounding box of coordinate
 * @param height height of the the bounding box of coordinate
 * @returns transformer
 */
export var fisheyeY = function (params, x, y, width, height) {
    var _a = params, focus = _a[0], distortion = _a[1], _b = _a[2], isVisual = _b === void 0 ? false : _b;
    var normalizedFocusY = normalize(focus, height, isVisual);
    return {
        transform: function (vector) {
            var vx = vector[0], vy = vector[1];
            var fy = fisheyeTransform(vy, normalizedFocusY, distortion, 0, 1);
            return [vx, fy];
        },
        untransform: function (vector) {
            var vx = vector[0], fy = vector[1];
            var vy = fisheyeUntransform(fy, normalizedFocusY, distortion, 0, 1);
            return [vx, vy];
        },
    };
};
/**
 * Applies cartesian fisheye transforms for both dimensions of vector2.
 * @param params [focusX, focusY, distortionX, distortionY]
 * @param x x of the the bounding box of coordinate
 * @param y y of the the bounding box of coordinate
 * @param width width of the the bounding box of coordinate
 * @param height height of the the bounding box of coordinate
 * @returns transformer
 */
export var fisheye = function (params, x, y, width, height) {
    var _a = params, focusX = _a[0], focusY = _a[1], distortionX = _a[2], distortionY = _a[3], _b = _a[4], isVisual = _b === void 0 ? false : _b;
    var normalizedFocusX = normalize(focusX, width, isVisual);
    var normalizedFocusY = normalize(focusY, height, isVisual);
    return {
        transform: function (vector) {
            var vx = vector[0], vy = vector[1];
            var fx = fisheyeTransform(vx, normalizedFocusX, distortionX, 0, 1);
            var fy = fisheyeTransform(vy, normalizedFocusY, distortionY, 0, 1);
            return [fx, fy];
        },
        untransform: function (vector) {
            var fx = vector[0], fy = vector[1];
            var vx = fisheyeUntransform(fx, normalizedFocusX, distortionX, 0, 1);
            var vy = fisheyeUntransform(fy, normalizedFocusY, distortionY, 0, 1);
            return [vx, vy];
        },
    };
};
/**
 * Applies circular fisheye transforms.
 * @param params [focusX, focusY, radius, distortion, isVisual?]
 * @param x x of the the bounding box of coordinate
 * @param y y of the the bounding box of coordinate
 * @param width width of the the bounding box of coordinate
 * @param height height of the the bounding box of coordinate
 * @returns transformer
 */
export var fisheyeCircular = function (params, x, y, width, height) {
    var _a = params, focusX = _a[0], focusY = _a[1], radius = _a[2], distortion = _a[3], _b = _a[4], isVisual = _b === void 0 ? false : _b;
    var scaleX = new Linear({
        range: [0, width],
    });
    var scaleY = new Linear({
        range: [0, height],
    });
    // focus point => visual point
    var nx = isVisual ? focusX : scaleX.map(focusX);
    var ny = isVisual ? focusY : scaleY.map(focusY);
    return {
        transform: function (vector) {
            var x = vector[0], y = vector[1];
            // focus point => visual point
            var dx = scaleX.map(x) - nx;
            var dy = scaleY.map(y) - ny;
            var dd = Math.sqrt(dx * dx + dy * dy);
            if (dd > radius)
                return [x, y];
            var r = fisheyeTransform(dd, 0, distortion, 0, radius);
            var theta = Math.atan2(dy, dx);
            var fx = nx + r * Math.cos(theta);
            var fy = ny + r * Math.sin(theta);
            // visual point => focus point
            return [scaleX.invert(fx), scaleY.invert(fy)];
        },
        untransform: function (vector) {
            var tx = vector[0], ty = vector[1];
            var dx = scaleX.map(tx) - nx;
            var dy = scaleY.map(ty) - ny;
            var dd = Math.sqrt(dx * dx + dy * dy);
            if (dd > radius)
                return [tx, ty];
            var x = fisheyeUntransform(dd, 0, distortion, 0, radius);
            var theta = Math.atan2(dy, dx);
            var fx = nx + x * Math.cos(theta);
            var fy = ny + x * Math.sin(theta);
            return [scaleX.invert(fx), scaleY.invert(fy)];
        },
    };
};
//# sourceMappingURL=fisheye.js.map